diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..fa6bd6d295
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,52 @@
+
+import django
+from django.conf import settings
+from django.db.models import Sum, F, Window
+from django.db.models.functions import Coalesce
+
+# Configure minimal Django settings
+if not settings.configured:
+    settings.configure(
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.auth',
+            'django.contrib.contenttypes',
+        ],
+        USE_TZ=True,
+    )
+    django.setup()
+
+    # Run migrations to create necessary tables
+    from django.core.management import call_command
+    call_command('migrate', interactive=False)
+
+# Assuming a model with fields 'DJR' and 'date'
+from django.contrib.auth.models import User  # Using User as a placeholder
+
+# Workaround for PostgreSQL: Use a subquery or CTE to compute window function first
+# Note: SQLite does not fully support this, but PostgreSQL should work with this approach
+# Below is the intended ORM approach, but for PostgreSQL, you might need raw SQL or adjust based on Django version
+subquery = User.objects.all().annotate(
+    cumul_id=Coalesce(Window(Sum("id"), order_by=F("date_joined").asc()), 0.0, output_field=django.db.models.FloatField())
+).values('id', 'cumul_id')
+
+# Then aggregate over the subquery results
+aggregate = subquery.aggregate(
+    id_total=Sum("id"),
+    cumul_id_total=Sum("cumul_id")
+)
+
+# For PostgreSQL with Django 4.2, if the above still fails, consider using raw SQL:
+# WITH cte AS (
+#     SELECT id, COALESCE(SUM(id) OVER (ORDER BY date_joined), 0.0) as cumul_id
+#     FROM auth_user
+# )
+# SELECT SUM(id) as id_total, SUM(cumul_id) as cumul_id_total
+# FROM cte;
+print(aggregate)
+print("Script completed successfully, no errors.")
\ No newline at end of file
