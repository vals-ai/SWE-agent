diff --git a/django/db/models/query.py b/django/db/models/query.py
index fb6639793a..98fe6ee595 100644
--- a/django/db/models/query.py
+++ b/django/db/models/query.py
@@ -1909,6 +1909,23 @@ def prefetch_one_level(instances, prefetcher, lookup, level):
 
     all_related_objects = list(rel_qs)
 
+    # Update the state of prefetched objects to reflect loaded fields from custom queryset
+    if lookup.queryset is not None:
+        # Get the fields selected in the custom queryset
+        selected_fields_dict = lookup.queryset.query.get_loaded_field_names()
+        if selected_fields_dict:
+            selected_fields = selected_fields_dict.get(rel_qs.model, set())
+            if selected_fields:
+                for rel_obj in all_related_objects:
+                    # Update the object's state to mark fields as loaded
+                    for field in selected_fields:
+                        if field not in rel_obj._state.fields_cache:
+                            # Set a placeholder to indicate the field is loaded
+                            rel_obj._state.fields_cache[field] = getattr(rel_obj, field, None)
+                    # Initialize prefetched objects cache if not present
+                    if not hasattr(rel_obj, '_prefetched_objects_cache'):
+                        rel_obj._prefetched_objects_cache = {}
+
     rel_obj_cache = {}
     for rel_obj in all_related_objects:
         rel_attr_val = rel_obj_attr(rel_obj)
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..e33ce826ae
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,66 @@
+
+if __name__ == '__main__':
+    import os
+    import django
+    from django.conf import settings
+    if not settings.configured:
+        settings.configure(
+            DATABASES={
+                'default': {
+                    'ENGINE': 'django.db.backends.sqlite3',
+                    'NAME': ':memory:',
+                }
+            },
+            INSTALLED_APPS=[
+                'django.contrib.auth',
+                'django.contrib.contenttypes',
+            ],
+            DEBUG=True
+        )
+    django.setup()
+    # Run migrations to create necessary tables
+    from django.core.management import call_command
+    call_command('migrate', interactive=False)
+    from django.contrib.auth.models import User
+    from django.db import connection
+    # Manually create the table for Profile model after its definition
+    # This will be done after the class definition
+    from django.db import models
+    from django.test import TestCase
+    from django.db.models import Prefetch
+
+    class Profile(models.Model):
+        full_name = models.CharField(max_length=255)
+        user = models.OneToOneField(User, on_delete=models.CASCADE)
+        class Meta:
+            app_label = 'test_app'
+
+    # Create the table for Profile model
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(Profile)
+
+    class DeferredFieldsTest(TestCase):
+        def test_only_related_queryset(self):
+            user = User.objects.create(
+                username="testuser",
+                email="test@example.com",
+            )
+            Profile.objects.create(user=user, full_name="Test Tester")
+            queryset = User.objects.only("email").prefetch_related(
+                Prefetch(
+                    "profile",
+                    queryset=Profile.objects.prefetch_related(
+                        Prefetch("user", queryset=User.objects.only("username"))
+                    ),
+                )
+            )
+            with self.assertNumQueries(3):
+                user = queryset.first()
+            with self.assertNumQueries(0):
+                self.assertEqual(user.profile.user.username, "testuser")
+
+    # Directly run the test logic
+    test = DeferredFieldsTest('test_only_related_queryset')
+    test.setUp()
+    test.test_only_related_queryset()
+    print("Script completed successfully, no errors.")
\ No newline at end of file
