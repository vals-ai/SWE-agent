diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 6629a1fd51..dce9ba9050 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1123,12 +1123,17 @@ class Query(BaseExpression):
             # opts would be Author's (from the author field) and value.model
             # would be Author.objects.all() queryset's .model (Author also).
             # The field is the related field on the lhs side.
-            if (isinstance(value, Query) and not value.has_select_fields and
-                    not check_rel_lookup_compatibility(value.model, opts, field)):
-                raise ValueError(
-                    'Cannot use QuerySet for "%s": Use a QuerySet for "%s".' %
-                    (value.model._meta.object_name, opts.object_name)
-                )
+            if isinstance(value, Query):
+                if not value.has_select_fields:
+                    # For related field lookups like __in, ensure only the primary key is selected to avoid multiple column subquery errors
+                    pk_field = value.model._meta.pk.name
+                    value.clear_select_fields()
+                    value.add_select_col(value.model._meta.get_field(pk_field).get_col(value.get_initial_alias()), pk_field)
+                if not check_rel_lookup_compatibility(value.model, opts, field):
+                    raise ValueError(
+                        'Cannot use QuerySet for "%s": Use a QuerySet for "%s".' %
+                        (value.model._meta.object_name, opts.object_name)
+                    )
             elif hasattr(value, '_meta'):
                 self.check_query_object_type(value, opts, field)
             elif hasattr(value, '__iter__'):
diff --git a/reproduce_q_object_error.py b/reproduce_q_object_error.py
new file mode 100644
index 0000000000..97a04e2d44
--- /dev/null
+++ b/reproduce_q_object_error.py
@@ -0,0 +1,26 @@
+
+from django.db import models
+from django.db.models import Q, Count
+
+# Dummy models for reproduction
+class Agent(models.Model):
+    name = models.CharField(max_length=100)
+
+class PropertyGroup(models.Model):
+    name = models.CharField(max_length=100)
+    agents = models.ManyToManyField(Agent, related_name='property_groups')
+
+# Simulate the queryset and property_groups
+try:
+    # Placeholder for actual data or mocks
+    property_groups = PropertyGroup.objects.all()
+    queryset = Agent.objects.all().annotate(Count('property_groups'))
+    
+    # The problematic filter
+    result = queryset.filter(
+        Q(property_groups__in=property_groups) |
+        Q(property_groups__count=0)
+    ).distinct()
+    print('Script completed successfully, no errors.')
+except Exception as e:
+    print(f'Error occurred: {str(e)}')
\ No newline at end of file
