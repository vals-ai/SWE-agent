diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py
index ae82d26340..3c211d4adf 100644
--- a/django/db/models/deletion.py
+++ b/django/db/models/deletion.py
@@ -309,10 +309,41 @@ class Collector:
                         sender=model, instance=obj, using=self.using
                     )
 
-            # fast deletes
+            # fast deletes - combine queries by model to reduce roundtrips
+            from django.db.models import Q
+            model_querysets = {}
             for qs in self.fast_deletes:
-                count = qs._raw_delete(using=self.using)
-                deleted_counter[qs.model._meta.label] += count
+                model = qs.model
+                if model not in model_querysets:
+                    model_querysets[model] = []
+                model_querysets[model].append(qs)
+
+            for model, qs_list in model_querysets.items():
+                if len(qs_list) == 1:
+                    count = qs_list[0]._raw_delete(using=self.using)
+                else:
+                    # Combine conditions with OR
+                    combined_condition = Q()
+                    for qs in qs_list:
+                        # Use the queryset's where clause to build conditions
+                        if qs.query.where:
+                            # Extract conditions from the where clause
+                            for child in qs.query.where.children:
+                                if isinstance(child, tuple) and len(child) == 2:
+                                    lookup, value = child
+                                    combined_condition |= Q(**{lookup: value})
+                                elif hasattr(child, 'children'):
+                                    # Handle nested conditions if necessary
+                                    nested_q = Q()
+                                    for nested_child in child.children:
+                                        if isinstance(nested_child, tuple) and len(nested_child) == 2:
+                                            nested_lookup, nested_value = nested_child
+                                            nested_q &= Q(**{nested_lookup: nested_value})
+                                    combined_condition |= nested_q
+                    # Apply combined condition to a new queryset for deletion
+                    combined_qs = model._base_manager.using(self.using).filter(combined_condition)
+                    count = combined_qs._raw_delete(using=self.using)
+                deleted_counter[model._meta.label] += count
 
             # update fields
             for model, instances_for_fieldvalues in self.field_updates.items():
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..a76bd79dc5
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,15 @@
+
+from django.db import models
+
+class Person(models.Model):
+    friends = models.ManyToManyField('self')
+
+class User(models.Model):
+    pass
+
+class Entry(models.Model):
+    created_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='created_entries')
+    updated_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='updated_entries')
+
+# This script is for demonstration; actual database setup and deletion would be needed to see queries.
+print('Models defined. Run this in a Django environment to observe DELETE queries on user.delete().')
\ No newline at end of file
