diff --git a/django/forms/models.py b/django/forms/models.py
index 5d115458a1..f993bb9c98 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -100,7 +100,7 @@ def apply_limit_choices_to_to_formfield(formfield):
     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):
         limit_choices_to = formfield.get_limit_choices_to()
         if limit_choices_to is not None:
-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)
+            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to).distinct()
 
 
 def fields_for_model(model, fields=None, exclude=None, widgets=None,
diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py
index 9e900e35f4..4b450c242b 100644
--- a/tests/model_forms/tests.py
+++ b/tests/model_forms/tests.py
@@ -46,6 +46,20 @@ if test_images:
         class Meta:
             model = NoExtensionImageFile
             fields = '__all__'
+# Models for limit_choices_to Q object test (#12454)
+class ReferencedByOther(models.Model):
+    name = models.CharField(max_length=20)
+
+class Other(models.Model):
+    name = models.CharField(max_length=20)
+    referenced_by = models.ManyToManyField(ReferencedByOther, related_name='others')
+
+class Main(models.Model):
+    other = models.ForeignKey(
+        Other,
+        models.CASCADE,
+        limit_choices_to=models.Q(referenced_by__name='foo'),
+    )
 
 
 class ProductForm(forms.ModelForm):
@@ -2829,6 +2843,33 @@ class LimitChoicesToTests(TestCase):
             StumpJokeForm()
             self.assertEqual(today_callable_dict.call_count, 3)
 
+    def test_limit_choices_to_q_object_with_join(self):
+        """
+        limit_choices_to with a Q object involving a join doesn't produce
+        duplicate choices (#12454).
+        """
+        # Create objects that would cause duplicates without distinct()
+        r1 = ReferencedByOther.objects.create(name='foo')
+        r2 = ReferencedByOther.objects.create(name='foo')
+        o1 = Other.objects.create(name='other1')
+        o1.referenced_by.add(r1, r2)
+        o2 = Other.objects.create(name='other2') # Should not be a choice
+
+        class MainForm(forms.ModelForm):
+            class Meta:
+                model = Main
+                fields = ['other']
+
+        form = MainForm()
+        # Before the fix, this would be [(o1.pk, 'other1'), (o1.pk, 'other1')]
+        # After the fix, it should be [(o1.pk, 'other1')]
+        choices = list(form.fields['other'].choices)
+        self.assertEqual(len(choices), 2) # Includes the empty choice '---------'
+        self.assertEqual(choices[1], (o1.pk, str(o1)))
+        # Check that the queryset is distinct
+        self.assertEqual(len(form.fields['other'].queryset), 1)
+        self.assertEqual(form.fields['other'].queryset.get(), o1)
+
 
 class FormFieldCallbackTests(SimpleTestCase):
 
