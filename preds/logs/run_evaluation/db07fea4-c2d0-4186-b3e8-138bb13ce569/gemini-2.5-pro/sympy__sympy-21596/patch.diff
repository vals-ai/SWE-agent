diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..c6f607ae79
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,15 @@
+
+
+from sympy import imageset, Lambda, S, I, Reals, Symbol
+
+n = Symbol('n')
+S1 = imageset(Lambda(n, n + (n - 1)*(n + 1)*I), S.Integers)
+
+print("S1:", S1)
+print("Type S1:", type(S1))
+print("Type Reals:", type(Reals))
+print("2 in S1:", 2 in S1)
+print("2 in S1.intersect(Reals):", 2 in S1.intersect(Reals))
+print("S1.intersect(Reals):", S1.intersect(Reals))
+# Add a success message for clarity
+print("Script completed successfully, no errors.")
\ No newline at end of file
diff --git a/sympy/sets/handlers/intersection.py b/sympy/sets/handlers/intersection.py
index c54dc8f72a..267fbf89ac 100644
--- a/sympy/sets/handlers/intersection.py
+++ b/sympy/sets/handlers/intersection.py
@@ -1,9 +1,10 @@
 from sympy import (S, Dummy, Lambda, symbols, Interval, Intersection, Set,
-                   EmptySet, FiniteSet, Union, ComplexRegion, Mul)
+                   EmptySet, FiniteSet, Union, ComplexRegion, Mul, And, Ne)
 from sympy.multipledispatch import dispatch
 from sympy.sets.conditionset import ConditionSet
 from sympy.sets.fancysets import (Integers, Naturals, Reals, Range,
     ImageSet, Rationals)
+from sympy.core.compatibility import ordered
 from sympy.sets.sets import UniversalSet, imageset, ProductSet
 
 
@@ -14,6 +15,8 @@ def intersection_sets(a, b): # noqa:F811
 @dispatch(ConditionSet, Set)  # type: ignore # noqa:F811
 def intersection_sets(a, b): # noqa:F811
     return ConditionSet(a.sym, a.condition, Intersection(a.base_set, b))
+from sympy.solvers.solveset import solveset
+from sympy.solvers.solvers import denoms
 
 @dispatch(Naturals, Integers)  # type: ignore # noqa:F811
 def intersection_sets(a, b): # noqa:F811
@@ -222,6 +225,7 @@ def intersection_sets(a, b): # noqa:F811
 
 @dispatch(ImageSet, Set)  # type: ignore # noqa:F811
 def intersection_sets(self, other): # noqa:F811
+    from sympy.solvers.solveset import solveset
     from sympy.solvers.diophantine import diophantine
 
     # Only handle the straight-forward univariate case
@@ -303,23 +307,60 @@ def intersection_sets(self, other): # noqa:F811
         elif ifree != {n}:
             return None
         else:
-            # univarite imaginary part in same variable
-            x, xis = zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols])
-            if x and all(i == n for i in x):
-                base_set -= FiniteSet(xis)
-            else:
-                base_set -= ConditionSet(n, Eq(im, 0), S.Integers)
-        # exclude values that make denominators 0
-        for i in denoms(f):
-            if i.has(n):
-                sol = list(zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols]))
-                if sol != []:
-                    x, xis = sol
-                    if x and all(i == n for i in x):
-                        base_set -= FiniteSet(xis)
-                else:
-                    base_set -= ConditionSet(n, Eq(i, 0), S.Integers)
-        return imageset(lam, base_set)
+            # solve for n such that im is 0
+
+            sol = solveset(im, n, domain=S.Complexes) # Solve im=0
+            if sol is None: # Should not happen for univariate
+                return S.EmptySet # Indent 16
+
+            # Intersect solutions with the original base_set
+            real_indices = sol.intersect(self.base_set) # Use self.base_set
+
+            if real_indices is S.EmptySet:
+                return S.EmptySet # Indent 16
+            elif isinstance(real_indices, FiniteSet):
+                # Check for denominators becoming zero
+                valid_indices = [] # Indent 16
+                den = denoms(f) # Use f defined earlier
+                for index in real_indices: # Indent 16
+                    valid = True # Indent 20
+                    for d in ordered(den): # Use ordered for consistent checks
+                        # Check if denominator is zero after substitution
+                        try: # Indent 24
+                            if d.subs(n, index).is_zero: # Indent 28
+                                valid = False # Indent 32
+                                break # Indent 32
+                        except (TypeError, ValueError): # Handle potential evaluation errors
+                            # If substitution fails, conservatively assume it might be zero
+                            # Or decide how to handle this case (e.g., return None)
+                            # For now, let's assume it's not zero if subs fails,
+                            # but a more robust solution might be needed.
+                            pass # Indent 28
+                    if valid: # Indent 20
+                        valid_indices.append(index) # Indent 24
+                if not valid_indices: # Indent 16
+                    return S.EmptySet # Indent 20
+                # Apply the real part function (lam) to the valid indices
+                return FiniteSet(*[lam(i) for i in valid_indices]) # Use lam defined earlier, Indent 16
+            elif isinstance(real_indices, Set): # Could be Integers, Range, etc.
+                # Need to handle potential denominator issues within the new base set
+                den_cond = S.true # Indent 16
+                for d in ordered(denoms(f)): # Use f defined earlier, use ordered
+                    den_cond = And(den_cond, Ne(d, 0)) # Indent 20
+                if den_cond is S.false: # Indent 16
+                    return S.EmptySet # Indent 20
+                elif den_cond is S.true: # Indent 16
+                    # No denominator issues or handled by base_set intersection
+                    return imageset(lam, real_indices) # Use lam defined earlier, Indent 20
+                else: # Indent 16
+                    # Create a ConditionSet to exclude denominator zeros
+                    new_base_set = ConditionSet(n, den_cond, real_indices) # Use n defined earlier, Indent 20
+                    # Simplify if possible
+                    if isinstance(new_base_set, ConditionSet) and new_base_set.condition == True: # Indent 20
+                        new_base_set = new_base_set.base_set # Indent 24
+                    return imageset(lam, new_base_set) # Use lam defined earlier, Indent 20
+            else: # Cannot determine intersection
+                return None # Or return unevaluated intersection?, Indent 16
 
     elif isinstance(other, Interval):
         from sympy.solvers.solveset import (invert_real, invert_complex,
