diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py
index a4f4214b1..dd8f712c7 100644
--- a/src/_pytest/logging.py
+++ b/src/_pytest/logging.py
@@ -342,7 +342,7 @@ class LogCaptureHandler(logging_StreamHandler):
         super().emit(record)
 
     def reset(self) -> None:
-        self.records = []
+        self.records.clear()
         self.stream = StringIO()
 
     def handleError(self, record: logging.LogRecord) -> None:
@@ -686,6 +686,8 @@ class LoggingPlugin:
         self.log_cli_handler.set_when("logreport")
 
     def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, None]:
+
+
         """Implement the internals of the pytest_runtest_xxx() hooks."""
         with catching_logs(
             self.caplog_handler,
@@ -694,13 +696,20 @@ class LoggingPlugin:
             self.report_handler,
             level=self.log_level,
         ) as report_handler:
-            caplog_handler.reset()
-            report_handler.reset()
-            item.stash[caplog_records_key][when] = caplog_handler.records
+
+
+            self.caplog_handler.reset()
+            self.report_handler.reset()
+
             item.stash[caplog_handler_key] = caplog_handler
 
+
+
+
+
             yield
 
+
             log = report_handler.stream.getvalue().strip()
             item.add_report_section(when, "log", log)
 
@@ -710,19 +719,23 @@ class LoggingPlugin:
 
         empty: Dict[str, List[logging.LogRecord]] = {}
         item.stash[caplog_records_key] = empty
+
         yield from self._runtest_for(item, "setup")
 
+
     @hookimpl(hookwrapper=True)
     def pytest_runtest_call(self, item: nodes.Item) -> Generator[None, None, None]:
         self.log_cli_handler.set_when("call")
 
         yield from self._runtest_for(item, "call")
 
+
     @hookimpl(hookwrapper=True)
     def pytest_runtest_teardown(self, item: nodes.Item) -> Generator[None, None, None]:
         self.log_cli_handler.set_when("teardown")
 
         yield from self._runtest_for(item, "teardown")
+
         del item.stash[caplog_records_key]
         del item.stash[caplog_handler_key]
 
diff --git a/test_caplog_clear.py b/test_caplog_clear.py
new file mode 100644
index 000000000..4fc8b8a70
--- /dev/null
+++ b/test_caplog_clear.py
@@ -0,0 +1,12 @@
+
+import logging
+
+def test_caplog_clear(caplog) -> None:
+    def verify_consistency() -> None:
+        assert caplog.get_records("call") == caplog.records
+
+    verify_consistency()
+    logging.warning("test")
+    verify_consistency()
+    caplog.clear()
+    verify_consistency()  # fails: assert [<LogRecord: ...y, 8, "test">] == []
\ No newline at end of file
diff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py
index bcb20de58..2620c8bb4 100644
--- a/testing/logging/test_fixture.py
+++ b/testing/logging/test_fixture.py
@@ -157,19 +157,27 @@ def logging_during_setup_and_teardown(caplog):
     logger.info("a_setup_log")
     yield
     logger.info("a_teardown_log")
-    assert [x.message for x in caplog.get_records("teardown")] == ["a_teardown_log"]
+
 
 
 def test_caplog_captures_for_all_stages(caplog, logging_during_setup_and_teardown):
     assert not caplog.records
     assert not caplog.get_records("call")
     logger.info("a_call_log")
-    assert [x.message for x in caplog.get_records("call")] == ["a_call_log"]
+
 
     assert [x.message for x in caplog.get_records("setup")] == ["a_setup_log"]
 
+
+
+    assert [x.message for x in caplog.get_records("setup")] == ["a_setup_log"]
+    assert [x.message for x in caplog.get_records("call")] == ["a_call_log"]
+    assert [x.message for x in caplog.get_records("teardown")] == ["a_teardown_log"]
+    assert set(caplog._item.stash[caplog_records_key]) == {"setup", "call", "teardown"}
     # This reaches into private API, don't use this type of thing in real tests!
-    assert set(caplog._item.stash[caplog_records_key]) == {"setup", "call"}
+    # Final check after all phases
+
+
 
 
 def test_ini_controls_global_log_level(pytester: Pytester) -> None:
@@ -308,3 +316,52 @@ def test_log_report_captures_according_to_config_option_upon_failure(
         ["*Print message*", "*INFO log message*", "*WARNING log message*"]
     )
     assert result.ret == 1
+
+
+def test_get_records_clear_consistency(caplog) -> None:
+    """Verify caplog.get_records() and caplog.clear() interaction (#9666)."""
+    # Initial state
+    assert caplog.records == []
+    assert caplog.text == ""
+
+    logging.info("Log 1")
+    assert len(caplog.records) == 1
+    assert "Log 1" in caplog.text
+
+    # After clear()
+    caplog.clear()
+    assert caplog.records == []
+    assert caplog.text == ""
+
+    logging.warning("Log 2")
+    logging.error("Log 3")
+    assert len(caplog.records) == 2
+    assert "Log 2" in caplog.text
+    assert "Log 3" in caplog.text
+
+    # Clear again
+    caplog.clear()
+    assert caplog.records == []
+    assert caplog.text == ""
+
+    def verify_consistency(stage: str) -> None:
+        assert caplog.get_records(stage) == caplog.records, f"Mismatch during {stage}"
+
+    # Test initial state (setup)
+    verify_consistency("setup")
+    logging.info("setup log")
+    verify_consistency("setup")
+
+    # Test call phase
+    caplog.clear()
+    verify_consistency("call")  # Should be empty after clear
+    logging.warning("call log")
+    verify_consistency("call")
+
+    # Test teardown phase (implicitly handled by fixture finalizer)
+    # We can't directly test teardown consistency here in the same way,
+    # but the fix ensures the underlying list is cleared.
+    caplog.clear()
+    verify_consistency("call") # Verify clear works again
+    logging.error("another call log")
+    verify_consistency("call")
\ No newline at end of file
