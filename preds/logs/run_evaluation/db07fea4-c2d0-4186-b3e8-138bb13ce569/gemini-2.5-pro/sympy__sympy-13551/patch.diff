diff --git a/reproduce_bug.py b/reproduce_bug.py
new file mode 100644
index 0000000000..cdfdf2c2bf
--- /dev/null
+++ b/reproduce_bug.py
@@ -0,0 +1,13 @@
+
+from sympy import *
+from sympy.abc import n,k
+p = Product(n + 1 / 2**k, [k, 0, n-1]).doit()
+print(f"Simplified expression: {simplify(p)}")
+result_n2 = p.subs(n,2).doit()
+print(f"Result for n=2: {result_n2}")
+print("Expected result for n=2: 15/2")
+if result_n2 == Rational(15, 2):
+    print("Result matches expected value.")
+else:
+    print("Result does NOT match expected value.")
+print("Script completed.")
\ No newline at end of file
diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py
index 66aafde2d6..c9e1e9296e 100644
--- a/sympy/concrete/products.py
+++ b/sympy/concrete/products.py
@@ -275,6 +275,9 @@ def _eval_product(self, term, limits):
             return poly.LC()**(n - a + 1) * A * B
 
         elif term.is_Add:
+            # If the limits are symbolic, Add handler is likely incorrect.
+            if not dif.is_Integer:
+                return None
             p, q = term.as_numer_denom()
             q = self._eval_product(q, (k, a, n))
             if q.is_Number:
diff --git a/sympy/concrete/tests/test_products.py b/sympy/concrete/tests/test_products.py
index 311d5153e2..3bc156d1a9 100644
--- a/sympy/concrete/tests/test_products.py
+++ b/sympy/concrete/tests/test_products.py
@@ -358,3 +358,37 @@ def test_issue_9983():
 def test_rewrite_Sum():
     assert Product(1 - S.Half**2/k**2, (k, 1, oo)).rewrite(Sum) == \
         exp(Sum(log(1 - 1/(4*k**2)), (k, 1, oo)))
+
+
+def test_issue_16890():
+    # Test case for issue #16890
+    # https://github.com/sympy/sympy/issues/16890
+    from sympy import symbols, Product, Rational, S, simplify, Add, Pow, Mul
+    n, k = symbols('n k', integer=True)
+    # Use S(1)/2 instead of 1/2 to avoid potential float division issues
+    term = n + S(1)/Pow(2, k)
+    p_sym = Product(term, (k, 0, n - 1))
+
+    # Symbolic product should remain unevaluated by doit if n is symbolic
+    p_doit_sym = p_sym.doit()
+    assert isinstance(p_doit_sym, Product)
+    # Check it didn't evaluate to the previously incorrect form
+    # Check function and limits are the same
+    assert p_doit_sym.function == p_sym.function
+    assert p_doit_sym.limits == p_sym.limits
+
+    # Product with concrete integer limit should evaluate correctly via doit
+    p_n2 = p_sym.subs(n, 2)
+    assert p_n2.doit() == Rational(15, 2)
+
+    p_n3 = p_sym.subs(n, 3)
+    # (3 + 1/1) * (3 + 1/2) * (3 + 1/4) = 4 * (7/2) * (13/4) = 7 * 13 / 2 = 91/2
+    assert p_n3.doit() == Rational(91, 2)
+
+    # Test with a non-integer symbol for n (should not evaluate)
+    x = symbols('x')
+    # Redefine k just in case, though it should be available
+    k_local = symbols('k', integer=True)
+    term_x = x + S(1)/Pow(2, k_local)
+    p_x = Product(term_x, (k_local, 0, x - 1))
+    assert isinstance(p_x.doit(), Product)
\ No newline at end of file
