diff --git a/django/db/backends/mysql/operations.py b/django/db/backends/mysql/operations.py
index 50f85e0621..609d4d8516 100644
--- a/django/db/backends/mysql/operations.py
+++ b/django/db/backends/mysql/operations.py
@@ -70,7 +70,10 @@ class DatabaseOperations(BaseDatabaseOperations):
 
     def _convert_field_to_tz(self, field_name, tzname):
         if settings.USE_TZ:
-            field_name = "CONVERT_TZ(%s, 'UTC', '%s')" % (field_name, tzname)
+            db_tzname = self.connection.timezone_name or 'UTC'  # Default to UTC if DB TZ not set
+            if db_tzname != tzname:
+                field_name = "CONVERT_TZ(%s, '%s', '%s')" % (field_name, db_tzname, tzname)
+            # No conversion needed if timezones match
         return field_name
 
     def datetime_cast_date_sql(self, field_name, tzname):
diff --git a/django/db/backends/oracle/operations.py b/django/db/backends/oracle/operations.py
index c1afb2ed5e..df06da802a 100644
--- a/django/db/backends/oracle/operations.py
+++ b/django/db/backends/oracle/operations.py
@@ -101,7 +101,18 @@ END;
             raise ValueError("Invalid time zone name: %s" % tzname)
         # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE
         # and cast it back to TIMESTAMP to strip the TIME ZONE details.
-        return "CAST((FROM_TZ(%s, '0:00') AT TIME ZONE '%s') AS TIMESTAMP)" % (field_name, tzname)
+        db_tzname = self.connection.timezone_name or 'UTC'
+        # Validate db_tzname as well
+        if not self._tzname_re.match(db_tzname):
+            # This should ideally not happen if settings are validated, but be safe.
+            raise ValueError("Invalid database time zone name: %s" % db_tzname)
+        if db_tzname == tzname:
+            # No conversion needed if DB timezone is the same as target timezone
+            return field_name
+        else:
+            # Convert from db_tzname to tzname
+            sql = "CAST((FROM_TZ(CAST(%s AS TIMESTAMP), '%s') AT TIME ZONE '%s') AS TIMESTAMP)"
+            return sql % (field_name, db_tzname, tzname)
 
     def datetime_cast_date_sql(self, field_name, tzname):
         field_name = self._convert_field_to_tz(field_name, tzname)
diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py
index 6a19236c48..8a58e20aaa 100644
--- a/django/db/backends/sqlite3/base.py
+++ b/django/db/backends/sqlite3/base.py
@@ -13,6 +13,7 @@ import warnings
 from itertools import chain
 from sqlite3 import dbapi2 as Database
 
+from django.conf import settings
 import pytz
 
 from django.core.exceptions import ImproperlyConfigured
@@ -192,13 +193,32 @@ class DatabaseWrapper(BaseDatabaseWrapper):
         return kwargs
 
     def get_new_connection(self, conn_params):
+
+        db_tzname = self.timezone_name
+
+        # Wrap functions needing db_tzname
+        def _extract_wrapper(lookup_type, dt, tzname=None):
+            # Pass db_tzname to the original function
+            return _sqlite_datetime_extract(lookup_type, dt, tzname, db_tzname)
+
+        def _trunc_wrapper(lookup_type, dt, tzname):
+            # Pass db_tzname to the original function
+            return _sqlite_datetime_trunc(lookup_type, dt, tzname, db_tzname)
+
+        def _cast_date_wrapper(dt, tzname):
+            # Pass db_tzname to the original function
+            return _sqlite_datetime_cast_date(dt, tzname, db_tzname)
+
+        def _cast_time_wrapper(dt, tzname):
+            # Pass db_tzname to the original function
+            return _sqlite_datetime_cast_time(dt, tzname, db_tzname)
         conn = Database.connect(**conn_params)
         conn.create_function("django_date_extract", 2, _sqlite_datetime_extract)
         conn.create_function("django_date_trunc", 2, _sqlite_date_trunc)
-        conn.create_function("django_datetime_cast_date", 2, _sqlite_datetime_cast_date)
-        conn.create_function("django_datetime_cast_time", 2, _sqlite_datetime_cast_time)
-        conn.create_function("django_datetime_extract", 3, _sqlite_datetime_extract)
-        conn.create_function("django_datetime_trunc", 3, _sqlite_datetime_trunc)
+        conn.create_function("django_datetime_cast_date", 2, _cast_date_wrapper)
+        conn.create_function("django_datetime_cast_time", 2, _cast_time_wrapper)
+        conn.create_function("django_datetime_extract", 3, _extract_wrapper)
+        conn.create_function("django_datetime_trunc", 3, _trunc_wrapper)
         conn.create_function("django_time_extract", 2, _sqlite_time_extract)
         conn.create_function("django_time_trunc", 2, _sqlite_time_trunc)
         conn.create_function("django_time_diff", 2, _sqlite_time_diff)
@@ -398,15 +418,46 @@ class SQLiteCursorWrapper(Database.Cursor):
         return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')
 
 
-def _sqlite_datetime_parse(dt, tzname=None):
+def _sqlite_datetime_parse(dt, tzname=None, db_tzname=None):
     if dt is None:
         return None
     try:
         dt = backend_utils.typecast_timestamp(dt)
     except (TypeError, ValueError):
         return None
-    if tzname is not None:
-        dt = timezone.localtime(dt, pytz.timezone(tzname))
+    if settings.USE_TZ:
+        # If db has a specific timezone, interpret the naive datetime
+        # from typecast_timestamp as being in that timezone.
+        if db_tzname and dt.tzinfo == timezone.utc:
+            try:
+                db_tz = pytz.timezone(db_tzname)
+                # Make naive, then localize to db timezone
+                dt = timezone.make_aware(dt.replace(tzinfo=None), db_tz)
+            except pytz.UnknownTimeZoneError:
+                warnings.warn(
+                    f"Got an unknown time zone {db_tzname} from the database. "
+                    f"Are you sure the database TIME_ZONE setting is correct?",
+                    RuntimeWarning
+                )
+        # Now, dt is either:
+        # - naive (if USE_TZ=False)
+        # - UTC (if USE_TZ=True and db_tzname is None or 'UTC')
+        # - db_tzname aware (if USE_TZ=True and db_tzname is set and valid)
+
+        # Convert to the target tzname (usually settings.TIME_ZONE) if needed
+        if tzname is not None and dt.tzinfo is not None:
+            try:
+                target_tz = pytz.timezone(tzname)
+                dt = timezone.localtime(dt, target_tz)
+            except pytz.UnknownTimeZoneError:
+                warnings.warn(
+                    f"Got an unknown time zone {tzname} for parameter tzname. "
+                    f"Are you sure the target TIME_ZONE setting is correct?",
+                    RuntimeWarning
+                )
+    # If USE_TZ is False, dt is naive. If tzname was passed, it's ignored.
+    # If USE_TZ is True, dt is now aware in the target tzname (or db_tzname/UTC
+    # if target tzname was None or invalid).
     return dt
 
 
@@ -443,22 +494,22 @@ def _sqlite_time_trunc(lookup_type, dt):
         return "%02i:%02i:%02i" % (dt.hour, dt.minute, dt.second)
 
 
-def _sqlite_datetime_cast_date(dt, tzname):
-    dt = _sqlite_datetime_parse(dt, tzname)
+def _sqlite_datetime_cast_date(dt, tzname, db_tzname=None):
+    dt = _sqlite_datetime_parse(dt, tzname, db_tzname)
     if dt is None:
         return None
     return dt.date().isoformat()
 
 
-def _sqlite_datetime_cast_time(dt, tzname):
-    dt = _sqlite_datetime_parse(dt, tzname)
+def _sqlite_datetime_cast_time(dt, tzname, db_tzname=None):
+    dt = _sqlite_datetime_parse(dt, tzname, db_tzname)
     if dt is None:
         return None
     return dt.time().isoformat()
 
 
-def _sqlite_datetime_extract(lookup_type, dt, tzname=None):
-    dt = _sqlite_datetime_parse(dt, tzname)
+def _sqlite_datetime_extract(lookup_type, dt, tzname=None, db_tzname=None):
+    dt = _sqlite_datetime_parse(dt, tzname, db_tzname)
     if dt is None:
         return None
     if lookup_type == 'week_day':
@@ -473,8 +524,8 @@ def _sqlite_datetime_extract(lookup_type, dt, tzname=None):
         return getattr(dt, lookup_type)
 
 
-def _sqlite_datetime_trunc(lookup_type, dt, tzname):
-    dt = _sqlite_datetime_parse(dt, tzname)
+def _sqlite_datetime_trunc(lookup_type, dt, tzname, db_tzname=None):
+    dt = _sqlite_datetime_parse(dt, tzname, db_tzname)
     if dt is None:
         return None
     if lookup_type == 'year':
