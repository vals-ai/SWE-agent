diff --git a/docs/source/conf.py b/docs/source/conf.py
new file mode 100644
index 000000000..89da17c1b
--- /dev/null
+++ b/docs/source/conf.py
@@ -0,0 +1,52 @@
+# Configuration file for the Sphinx documentation builder.
+#
+# This file only contains a selection of the most common options. For a full
+# list see the documentation:
+# https://www.sphinx-doc.org/en/master/usage/configuration.html
+
+# -- Path setup --------------------------------------------------------------
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+#
+# import os
+# import sys
+# sys.path.insert(0, os.path.abspath('.'))
+
+
+# -- Project information -----------------------------------------------------
+
+project = 'test'
+copyright = '2025, test'
+author = 'test'
+
+
+# -- General configuration ---------------------------------------------------
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
+# ones.
+extensions = [
+]
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+# This pattern also affects html_static_path and html_extra_path.
+exclude_patterns = []
+
+
+# -- Options for HTML output -------------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+#
+html_theme = 'alabaster'
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ['_static']
\ No newline at end of file
diff --git a/docs/source/index.rst b/docs/source/index.rst
new file mode 100644
index 000000000..9f2daa978
--- /dev/null
+++ b/docs/source/index.rst
@@ -0,0 +1,21 @@
+
+:kbd:`-`
+
+:kbd:`+`
+
+
+
+:kbd:`a-b`
+
+:kbd:`--`
+
+:kbd:`-a`
+
+:kbd:`a-`
+
+:kbd:`Ctrl-Shift-+`
+
+
+
+:kbd:`Shift-+`
+:kbd:`Ctrl--`
diff --git a/sphinx/application.py b/sphinx/application.py
index 5bdccdbb1..a7fe0a8f3 100644
--- a/sphinx/application.py
+++ b/sphinx/application.py
@@ -24,6 +24,7 @@ from docutils import nodes
 from docutils.nodes import Element, TextElement
 from docutils.parsers import Parser
 from docutils.parsers.rst import Directive, roles
+from sphinx.roles import patched_kbd_role_v2
 from docutils.transforms import Transform
 from pygments.lexer import Lexer
 
@@ -266,6 +267,8 @@ class Sphinx:
 
         # now that we know all config values, collect them from conf.py
         self.config.init_values()
+        # Patch the kbd role to handle separators correctly
+        roles.register_canonical_role('kbd', patched_kbd_role_v2)
         self.events.emit('config-inited', self.config)
 
         # create the project
diff --git a/sphinx/roles.py b/sphinx/roles.py
index 2d3042f8f..6db99ba19 100644
--- a/sphinx/roles.py
+++ b/sphinx/roles.py
@@ -22,6 +22,265 @@ from sphinx.locale import _
 from sphinx.util import ws_re
 from sphinx.util.docutils import ReferenceRole, SphinxRole
 from sphinx.util.nodes import process_index_entry, set_role_source_info, split_explicit_title
+
+
+# -- kbd role patch ----------------------------------------------------------
+
+# The original docutils kbd role function uses a simple regex to split keys,
+# which causes problems when separator characters like '-' or '+' are used
+# as actual keys. This patched version iterates manually to handle these cases.
+# See https://github.com/sphinx-doc/sphinx/issues/8711
+
+kbd_separator_chars = '-+^'
+
+def patched_kbd_role(name: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
+                     options: Dict = {}, content: List[str] = []
+                     ) -> Tuple[List[Node], List[system_message]]:
+    # KBD_PATCH_START
+    # Note: The original docutils role returned a single literal node like:
+    # <literal class="kbd"><span>Ctrl</span>-<span>Alt</span>-<span>Del</span></literal>
+    # This implementation returns nested literal nodes for better HTML semantics:
+    # <literal class="kbd"><literal class="kbd">Ctrl</literal>-<literal class="kbd">Alt</literal>-<literal class="kbd">Del</literal></literal>
+    # This matches the HTML5 spec recommendation for <kbd>.
+    outer_node = nodes.literal(rawtext=rawtext, classes=['kbd'])
+    parts = []
+    current_part = ''
+    in_explicit_key = False  # Flag to track if we are inside `{}`
+
+    i = 0
+    while i < len(text):
+        char = text[i]
+
+        if char == '{':
+            # Start of an explicit key sequence, treat everything inside as one key
+            if current_part:
+                parts.append(('key', current_part))
+            current_part = ''
+            in_explicit_key = True
+            i += 1
+            continue
+        elif char == '}':
+            # End of an explicit key sequence
+            if in_explicit_key:
+                if current_part:
+                    parts.append(('key', current_part))
+                current_part = ''
+                in_explicit_key = False
+                i += 1
+                continue
+            else:
+                # Stray '}', treat as normal character
+                current_part += char
+                i += 1
+                continue
+
+        if in_explicit_key:
+            current_part += char
+        elif char in kbd_separator_chars:
+            # Potential separator
+            prev_char = text[i-1] if i > 0 else None
+            next_char = text[i+1] if i < len(text) - 1 else None
+
+            is_separator = False # Default to treating as part of key
+            if prev_char and not prev_char.isspace() and prev_char not in kbd_separator_chars:
+                # Has a potential key part before it
+                if next_char and not next_char.isspace() and next_char not in kbd_separator_chars:
+                    # Has a potential key part after it -> It's a separator
+                    is_separator = True
+                elif next_char and next_char.isspace():
+                    # Separator followed by space -> Treat as separator (e.g., Shift -)
+                    is_separator = True
+                # Handle case like `a-` (end of string) - should be part of key 'a-'
+                elif next_char is None:
+                    is_separator = False
+            elif prev_char and prev_char.isspace():
+                # Space followed by separator -> Treat as separator (e.g., - Shift)
+                if next_char and not next_char.isspace() and next_char not in kbd_separator_chars:
+                    is_separator = True
+            # Handle case like `-a` (start of string) - should be part of key '-a'
+            elif prev_char is None and next_char and not next_char.isspace() and next_char not in kbd_separator_chars:
+                is_separator = False
+
+            # Handle start/end cases explicitly
+            # Note: This logic might need refinement for edge cases like `---` or `a-b-`
+            if len(text) == 1 and char in kbd_separator_chars:
+                is_separator = False # Single separator char is a key
+            elif prev_char is None and next_char is None: # Only char
+                is_separator = False
+
+            if is_separator:
+                # It's a separator
+                if current_part:
+                    parts.append(('key', current_part))
+                parts.append(('sep', char)) # Mark as separator
+                current_part = ''
+            else:
+                # It's part of a key
+                current_part += char
+        else:
+            # Normal character
+            current_part += char
+        i += 1
+
+    if current_part:
+        parts.append(('key', current_part))
+
+    # Now build the nodes
+
+# -- Patched kbd role v2 (using re.split) ------------------------------------
+
+kbd_separator_chars_v2 = '-+^'
+
+def patched_kbd_role_v2(name: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
+                        options: Dict = {}, content: List[str] = []
+                        ) -> Tuple[List[Node], List[system_message]]:
+    import re
+    # Split the text by separator characters, keeping the separators
+    # Use a regex that captures the separators: '([-+^])'
+    parts = re.split(f'([{kbd_separator_chars_v2}])', text)
+    # Filter out empty strings that can result from adjacent separators or start/end
+    parts = [p for p in parts if p]
+
+    processed_parts = []
+    idx = 0
+    while idx < len(parts):
+        part = parts[idx]
+        # Treat single char parts matching separators as potential separators
+        is_potential_separator = len(part) == 1 and part in kbd_separator_chars_v2
+
+        if is_potential_separator:
+            # A part is a *true* separator if it's preceded and followed by non-empty parts
+            # that are *not* themselves separators.
+            has_key_before = idx > 0 and not (len(parts[idx-1]) == 1 and parts[idx-1] in kbd_separator_chars_v2)
+            has_key_after = idx < len(parts) - 1 and not (len(parts[idx+1]) == 1 and parts[idx+1] in kbd_separator_chars_v2)
+
+            if has_key_before and has_key_after:
+                # It's a true separator
+                processed_parts.append(('sep', part))
+            else:
+                # Treat as key, merge with neighbors if they are keys/converted separators
+                new_key_value = part
+                # Merge with previous if it was a key
+                if processed_parts and processed_parts[-1][0] == 'key':
+                    prev_val = processed_parts.pop()[1]
+                    new_key_value = prev_val + new_key_value
+
+                # Check if next part is a separator that will also be converted
+                next_part_merged = False
+                if idx < len(parts) - 1:
+                    next_part = parts[idx+1]
+                    next_is_potential_separator = len(next_part) == 1 and next_part in kbd_separator_chars_v2
+                    if next_is_potential_separator:
+                        # Check if the *next* separator should be treated as a *true* separator
+                        next_has_key_before = True # Because current part is being converted to key
+                        next_has_key_after = idx + 1 < len(parts) - 1 and not (len(parts[idx+2]) == 1 and parts[idx+2] in kbd_separator_chars_v2)
+                        if not (next_has_key_before and next_has_key_after):
+                            # Next separator will also be converted to key, merge it now
+                            new_key_value += next_part
+                            next_part_merged = True
+
+                processed_parts.append(('key', new_key_value))
+                if next_part_merged:
+                    idx += 1 # Skip next part as it was merged
+        else: # It's definitely a key part
+            # Merge with previous part if it was also a key (due to conversion)
+            if processed_parts and processed_parts[-1][0] == 'key':
+                prev_val = processed_parts.pop()[1]
+                processed_parts.append(('key', prev_val + part))
+            else:
+                # Otherwise, just add it
+                processed_parts.append(('key', part))
+
+        idx += 1
+
+
+    # Build nodes from processed_parts
+    outer_node = nodes.literal(rawtext=rawtext, classes=['kbd'])
+    for type, value in processed_parts:
+        if type == 'key':
+            # Wrap each key in its own kbd node
+            key_node = nodes.literal(value, value, classes=['kbd'])
+            outer_node += key_node
+        elif type == 'sep':
+            # Add separator as simple text
+            outer_node += nodes.Text(value)
+
+    set_role_source_info(inliner, lineno, outer_node)
+    return [outer_node], []
+
+# -----------------------------------------------------------------------------
+
+# -- Patched kbd role v3 (manual iteration) ----------------------------------
+
+# Use the same separator chars as v2 for consistency
+# Assuming kbd_separator_chars_v2 is defined above and accessible
+kbd_separator_chars_v3 = kbd_separator_chars_v2
+
+def patched_kbd_role_v3(name: str, rawtext: str, text: str, lineno: int, inliner: "Inliner",
+                        options: "Dict" = {}, content: "List[str]" = []
+                        ) -> "Tuple[List[Node], List[system_message]]":
+    # Imports needed within this function's scope
+    from docutils import nodes
+    from docutils.parsers.rst.states import Inliner
+    from docutils.nodes import Node, system_message
+    from typing import Dict, List, Tuple
+    from sphinx.util.nodes import set_role_source_info
+
+    outer_node = nodes.literal(rawtext=rawtext, classes=['kbd'])
+    current_key = ''
+    i = 0
+    n = len(text)
+
+    while i < n:
+        char = text[i]
+
+        if char in kbd_separator_chars_v3:
+            # Check if it's a true separator
+            # Treat it as a separator if current_key is non-empty AND
+            # the next char exists and is not a separator/space.
+            is_separator = bool(current_key) and (i + 1 < n) and (text[i+1] not in kbd_separator_chars_v3) and (not text[i+1].isspace())
+
+            if is_separator:
+                # Add the preceding key
+                key_node = nodes.literal(current_key, current_key, classes=['kbd'])
+                outer_node += key_node
+                current_key = ''
+                # Add the separator itself as text
+                outer_node += nodes.Text(char)
+            else:
+                # Part of the current key
+                current_key += char
+        else:
+            # Not a separator, part of the current key
+            current_key += char
+        i += 1
+
+    # Add the last key part if any
+    if current_key:
+        key_node = nodes.literal(current_key, current_key, classes=['kbd'])
+        outer_node += key_node
+
+    # Handle cases where the input resulted in no <kbd> elements or only text,
+    # meaning the input was likely just separators or a single separator.
+    # In these cases, wrap the whole original text in a single <kbd>.
+    if not any(isinstance(child, nodes.literal) for child in outer_node.children) and text:
+        # Corrected indentation (8 spaces)
+        outer_node.children = [] # Clear any text nodes added
+        key_node = nodes.literal(text, text, classes=['kbd'])
+        outer_node += key_node
+    elif len(outer_node.children) == 1 and isinstance(outer_node.children[0], nodes.Text) and text == outer_node.children[0].astext():
+        # Corrected indentation (8 spaces)
+        outer_node.children = [] # Clear the text node
+        key_node = nodes.literal(text, text, classes=['kbd'])
+        outer_node += key_node
+
+    set_role_source_info(inliner, lineno, outer_node)
+    return [outer_node], []
+
+# -----------------------------------------------------------------------------
+
+
+# -----------------------------------------------------------------------------
 from sphinx.util.typing import RoleFunction
 
 if False:
@@ -623,6 +882,7 @@ def setup(app: "Sphinx") -> Dict[str, Any]:
     for rolename, func in specific_docroles.items():
         roles.register_local_role(rolename, func)
 
+
     return {
         'version': 'builtin',
         'parallel_read_safe': True,
