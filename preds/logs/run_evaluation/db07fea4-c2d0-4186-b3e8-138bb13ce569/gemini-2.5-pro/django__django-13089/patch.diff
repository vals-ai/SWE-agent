diff --git a/django/core/cache/backends/db.py b/django/core/cache/backends/db.py
index 33c79c5a14..dc0934ed7a 100644
--- a/django/core/cache/backends/db.py
+++ b/django/core/cache/backends/db.py
@@ -267,9 +267,11 @@ class DatabaseCache(BaseDatabaseCache):
                 cursor.execute(
                     connection.ops.cache_key_culling_sql() % table,
                     [cull_num])
-                cursor.execute("DELETE FROM %s "
-                               "WHERE cache_key < %%s" % table,
-                               [cursor.fetchone()[0]])
+                last_key_row = cursor.fetchone()
+                if last_key_row is not None:
+                    cursor.execute("DELETE FROM %s "
+                                   "WHERE cache_key < %%s" % table,
+                                   [last_key_row[0]])
 
     def clear(self):
         db = router.db_for_write(self.cache_model_class)
diff --git a/tests/cache/tests.py b/tests/cache/tests.py
index d404475e16..e3f91b79fe 100644
--- a/tests/cache/tests.py
+++ b/tests/cache/tests.py
@@ -249,6 +249,11 @@ _caches_setting_base = {
     'custom_key': {'KEY_FUNCTION': custom_key_func},
     'custom_key2': {'KEY_FUNCTION': 'cache.tests.custom_key_func'},
     'cull': {'OPTIONS': {'MAX_ENTRIES': 30}},
+    'db_cull_test': {
+        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
+        'LOCATION': 'test_cull_table',
+        'OPTIONS': {'MAX_ENTRIES': 5, 'CULL_FREQUENCY': 1},
+    },
     'zero_cull': {'OPTIONS': {'CULL_FREQUENCY': 0, 'MAX_ENTRIES': 30}},
 }
 
@@ -1070,6 +1075,40 @@ class DBCacheTests(BaseCacheTests, TransactionTestCase):
             stdout=out,
         )
         self.assertEqual(out.getvalue(), "Cache table 'test cache table' created.\n")
+    def test_cull_empty_result(self):
+        """
+        Test that culling doesn't fail when the culling query returns no rows.
+        """
+        # Use a specific cache configuration for this test
+        cache_name = 'db_cull_test'
+        try:
+            test_cache = caches[cache_name]
+        except InvalidCacheBackendError:
+            self.skipTest("Database cache backend not configured ('%s')." % cache_name)
+
+        # Ensure the table exists for this specific cache
+        management.call_command('createcachetable', test_cache._table, verbosity=0)
+
+        max_entries = test_cache._max_entries  # Should be 5
+        # Add exactly max_entries items
+        for i in range(max_entries):
+            test_cache.set(f'key-{i}', f'value-{i}', timeout=None)
+
+        # Adding one more item should trigger culling
+        # CULL_FREQUENCY is 1, so cull_num = (max_entries + 1) // 1 = 6
+        # The culling query will look for the 6th oldest item, but there are only 6 items.
+        # Depending on the DB backend, this might return 0 rows.
+        try:
+            test_cache.set('key-last', 'value-last', timeout=None)
+        except TypeError:
+            self.fail("TypeError raised during cache culling.")
+
+        # The main purpose is to check that no TypeError occurred.
+        # The actual number of items remaining might be max_entries + 1
+        # if the culling query returned no rows, which is acceptable.
+        pass # Assertion is implicitly handled by not raising TypeError
+
+        # Table cleanup is handled by the test runner / TransactionTestCase
 
 
 @override_settings(USE_TZ=True)
