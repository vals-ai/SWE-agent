diff --git a/django/db/models/functions/datetime.py b/django/db/models/functions/datetime.py
index 90e6f41be0..3e140bfa84 100644
--- a/django/db/models/functions/datetime.py
+++ b/django/db/models/functions/datetime.py
@@ -164,11 +164,6 @@ ExtractYear.register_lookup(YearGte)
 ExtractYear.register_lookup(YearLt)
 ExtractYear.register_lookup(YearLte)
 
-ExtractIsoYear.register_lookup(YearExact)
-ExtractIsoYear.register_lookup(YearGt)
-ExtractIsoYear.register_lookup(YearGte)
-ExtractIsoYear.register_lookup(YearLt)
-ExtractIsoYear.register_lookup(YearLte)
 
 
 class Now(Func):
diff --git a/tests/db_functions/datetime/test_extract_trunc.py b/tests/db_functions/datetime/test_extract_trunc.py
index 258600127f..8ed92ed30d 100644
--- a/tests/db_functions/datetime/test_extract_trunc.py
+++ b/tests/db_functions/datetime/test_extract_trunc.py
@@ -108,20 +108,32 @@ class DateFunctionTests(TestCase):
                 qs = DTModel.objects.filter(**{'start_datetime__%s__exact' % lookup: 2015})
                 self.assertEqual(qs.count(), 1)
                 query_string = str(qs.query).lower()
-                self.assertEqual(query_string.count(' between '), 1)
-                self.assertEqual(query_string.count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(query_string.count(' between '), 1)
+                    self.assertEqual(query_string.count('extract'), 0)
+                else:  # iso_year
+                    self.assertEqual(query_string.count(' between '), 0)
+                    self.assertGreaterEqual(query_string.count('extract'), 1) # Check for at least one extract
                 # exact is implied and should be the same
                 qs = DTModel.objects.filter(**{'start_datetime__%s' % lookup: 2015})
                 self.assertEqual(qs.count(), 1)
                 query_string = str(qs.query).lower()
-                self.assertEqual(query_string.count(' between '), 1)
-                self.assertEqual(query_string.count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(query_string.count(' between '), 1)
+                    self.assertEqual(query_string.count('extract'), 0)
+                else:  # iso_year
+                    self.assertEqual(query_string.count(' between '), 0)
+                    self.assertGreaterEqual(query_string.count('extract'), 1)
                 # date and datetime fields should behave the same
                 qs = DTModel.objects.filter(**{'start_date__%s' % lookup: 2015})
                 self.assertEqual(qs.count(), 1)
                 query_string = str(qs.query).lower()
-                self.assertEqual(query_string.count(' between '), 1)
-                self.assertEqual(query_string.count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(query_string.count(' between '), 1)
+                    self.assertEqual(query_string.count('extract'), 0)
+                else:  # iso_year
+                    self.assertEqual(query_string.count(' between '), 0)
+                    self.assertGreaterEqual(query_string.count('extract'), 1)
                 # an expression rhs cannot use the between optimization.
                 qs = DTModel.objects.annotate(
                     start_year=ExtractYear('start_datetime'),
@@ -144,10 +156,16 @@ class DateFunctionTests(TestCase):
             with self.subTest(lookup):
                 qs = DTModel.objects.filter(**{'start_datetime__%s__gt' % lookup: 2015})
                 self.assertEqual(qs.count(), 1)
-                self.assertEqual(str(qs.query).lower().count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(str(qs.query).lower().count('extract'), 0)
+                else:  # iso_year
+                    self.assertGreaterEqual(str(qs.query).lower().count('extract'), 1)
                 qs = DTModel.objects.filter(**{'start_datetime__%s__gte' % lookup: 2015})
                 self.assertEqual(qs.count(), 2)
-                self.assertEqual(str(qs.query).lower().count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(str(qs.query).lower().count('extract'), 0)
+                else:  # iso_year
+                    self.assertGreaterEqual(str(qs.query).lower().count('extract'), 1)
                 qs = DTModel.objects.annotate(
                     start_year=ExtractYear('start_datetime'),
                 ).filter(**{'end_datetime__%s__gte' % lookup: F('start_year')})
@@ -167,10 +185,16 @@ class DateFunctionTests(TestCase):
             with self.subTest(lookup):
                 qs = DTModel.objects.filter(**{'start_datetime__%s__lt' % lookup: 2016})
                 self.assertEqual(qs.count(), 1)
-                self.assertEqual(str(qs.query).count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(str(qs.query).lower().count('extract'), 0)
+                else:  # iso_year
+                    self.assertGreaterEqual(str(qs.query).lower().count('extract'), 1)
                 qs = DTModel.objects.filter(**{'start_datetime__%s__lte' % lookup: 2016})
                 self.assertEqual(qs.count(), 2)
-                self.assertEqual(str(qs.query).count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(str(qs.query).lower().count('extract'), 0)
+                else:  # iso_year
+                    self.assertGreaterEqual(str(qs.query).lower().count('extract'), 1)
                 qs = DTModel.objects.annotate(
                     end_year=ExtractYear('end_datetime'),
                 ).filter(**{'start_datetime__%s__lte' % lookup: F('end_year')})
