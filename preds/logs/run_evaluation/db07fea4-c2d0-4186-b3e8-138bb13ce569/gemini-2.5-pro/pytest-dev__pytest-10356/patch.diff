diff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py
index 800a25c92..57a37e32d 100644
--- a/src/_pytest/mark/structures.py
+++ b/src/_pytest/mark/structures.py
@@ -355,12 +355,38 @@ class MarkDecorator:
         return self.with_args(*args, **kwargs)
 
 
+import inspect
+
 def get_unpacked_marks(obj: object) -> Iterable[Mark]:
-    """Obtain the unpacked marks that are stored on an object."""
-    mark_list = getattr(obj, "pytestmark", [])
-    if not isinstance(mark_list, list):
-        mark_list = [mark_list]
-    return normalize_mark_list(mark_list)
+    """Obtain the unpacked marks that are stored on an object.
+
+    Handles functions, modules, and classes, collecting marks from
+    the object itself and, for classes, from its MRO.
+    """
+    # Use a list to collect marks, allowing duplicates initially if needed,
+    # though normalize_mark_list might handle structure.
+    # We reverse the MRO to apply marks from base to derived class order,
+    # which seems more intuitive for inheritance.
+    collected_marks: List[Union[Mark, MarkDecorator]] = []
+    if inspect.isclass(obj):
+        # Iterate MRO in reverse to collect base class marks first
+        for cls in reversed(obj.__mro__):
+            # Get marks directly defined on the class, not inherited ones via getattr
+            marks_on_cls = vars(cls).get("pytestmark", [])
+            if marks_on_cls:
+                # Ensure it's a list, as pytestmark can be a single mark or a list
+                if not isinstance(marks_on_cls, list):
+                    marks_on_cls = [marks_on_cls]
+                collected_marks.extend(marks_on_cls)
+    else:
+        # For non-class objects (functions, modules), use the original getattr approach
+        marks_on_obj = getattr(obj, "pytestmark", [])
+        if not isinstance(marks_on_obj, list):
+            marks_on_obj = [marks_on_obj]
+        collected_marks.extend(marks_on_obj)
+
+    # Normalize the collected marks (e.g., extract Mark from MarkDecorator)
+    return normalize_mark_list(collected_marks)
 
 
 def normalize_mark_list(
diff --git a/testing/test_mark.py b/testing/test_mark.py
index 65f2581bd..a9c2b83ff 100644
--- a/testing/test_mark.py
+++ b/testing/test_mark.py
@@ -1108,4 +1108,99 @@ def test_marker_expr_eval_failure_handling(pytester: Pytester, expr) -> None:
     expected = f"ERROR: Wrong expression passed to '-m': {expr}: *"
     result = pytester.runpytest(foo, "-m", expr)
     result.stderr.fnmatch_lines([expected])
+
+
+def test_mark_inheritance_multiple_classes(pytester: Pytester) -> None:
+    """
+    Test that markers are correctly inherited from multiple base classes (#issue_number).
+    Previously, only markers from the first base class in the MRO were collected.
+    """
+    pytester.makepyfile(
+        """
+        import pytest
+
+        class Base:
+            pass
+
+        @pytest.mark.foo(1)
+        class Foo(Base):
+            pass
+
+        @pytest.mark.bar("hello")
+        class Bar(Base):
+            pass
+
+        # Inherits Foo then Bar
+        class TestDirectInheritance(Foo, Bar):
+            def test_markers(self, request):
+                markers = {m.name: m for m in request.node.iter_markers()}
+                assert "foo" in markers
+                assert "bar" in markers
+                assert markers["foo"].args == (1,)
+                assert markers["bar"].args == ("hello",)
+
+        # Inherits Bar then Foo
+        class TestReverseInheritance(Bar, Foo):
+            def test_markers(self, request):
+                markers = {m.name: m for m in request.node.iter_markers()}
+                assert "foo" in markers
+                assert "bar" in markers
+                assert markers["foo"].args == (1,)
+                assert markers["bar"].args == ("hello",)
+
+        # Diamond inheritance
+        @pytest.mark.baz(key="value")
+        class Mixin:
+            pass
+
+        class TestDiamond(Foo, Mixin, Bar):
+             def test_markers(self, request):
+                markers = {m.name: m for m in request.node.iter_markers()}
+                assert "foo" in markers
+                assert "bar" in markers
+                assert "baz" in markers
+                assert markers["foo"].args == (1,)
+                assert markers["bar"].args == ("hello",)
+                assert markers["baz"].kwargs == {"key": "value"}
+
+        # Class directly defining pytestmark list
+        class TestDirectAndInherited(Foo):
+            pytestmark = [pytest.mark.direct("direct_arg")]
+
+            def test_markers(self, request):
+                markers = {m.name: m for m in request.node.iter_markers()}
+                assert "foo" in markers
+                assert "direct" in markers
+                assert markers["foo"].args == (1,)
+                assert markers["direct"].args == ("direct_arg",)
+
+        # Class directly defining single pytestmark
+        class TestDirectSingleAndInherited(Bar):
+            pytestmark = pytest.mark.direct_single(42)
+
+            def test_markers(self, request):
+                markers = {m.name: m for m in request.node.iter_markers()}
+                assert "bar" in markers
+                assert "direct_single" in markers
+                assert markers["bar"].args == ("hello",)
+                assert markers["direct_single"].args == (42,)
+
+        # Ensure function marks are not affected
+        @pytest.mark.func_mark
+        class TestWithFuncMark(Foo, Bar):
+            @pytest.mark.method_mark
+            def test_markers(self, request):
+                markers = {m.name for m in request.node.iter_markers()}
+                # Should include class marks (foo, bar) and method mark
+                assert markers == {"foo", "bar", "method_mark", "func_mark"}
+                # func_mark is on the class, not the method item
+                class_markers = {m.name for m in request.node.parent.iter_markers()}
+                assert "func_mark" in class_markers
+
+    """
+    )
+    result = pytester.runpytest("-v")
+    # Check that all tests passed
+    result.assert_outcomes(passed=6)
+    assert result.ret == 0 # Ensure pytest exits successfully
     assert result.ret == ExitCode.USAGE_ERROR
