diff --git a/sklearn/impute/_iterative.py b/sklearn/impute/_iterative.py
index 1d918bc0c..bbd3c40cd 100644
--- a/sklearn/impute/_iterative.py
+++ b/sklearn/impute/_iterative.py
@@ -281,6 +281,7 @@ class IterativeImputer(_BaseImputer):
         "initial_strategy": [
             StrOptions({"mean", "median", "most_frequent", "constant"})
         ],
+        "fill_value": [None, Real, str, Interval(Real, None, None, closed="both")],
         "imputation_order": [
             StrOptions({"ascending", "descending", "roman", "arabic", "random"})
         ],
@@ -301,6 +302,7 @@ class IterativeImputer(_BaseImputer):
         tol=1e-3,
         n_nearest_features=None,
         initial_strategy="mean",
+        fill_value=None,
         imputation_order="ascending",
         skip_complete=False,
         min_value=-np.inf,
@@ -328,6 +330,7 @@ class IterativeImputer(_BaseImputer):
         self.max_value = max_value
         self.verbose = verbose
         self.random_state = random_state
+        self.fill_value = fill_value
 
     def _impute_one_feature(
         self,
@@ -610,11 +613,14 @@ class IterativeImputer(_BaseImputer):
         X_missing_mask = _get_mask(X, self.missing_values)
         mask_missing_values = X_missing_mask.copy()
         if self.initial_imputer_ is None:
-            self.initial_imputer_ = SimpleImputer(
-                missing_values=self.missing_values,
-                strategy=self.initial_strategy,
-                keep_empty_features=self.keep_empty_features,
-            )
+            simple_imputer_kwargs = {
+                "missing_values": self.missing_values,
+                "strategy": self.initial_strategy,
+                "keep_empty_features": self.keep_empty_features,
+            }
+            if self.initial_strategy == "constant":
+                simple_imputer_kwargs["fill_value"] = self.fill_value
+            self.initial_imputer_ = SimpleImputer(**simple_imputer_kwargs)
             X_filled = self.initial_imputer_.fit_transform(X)
         else:
             X_filled = self.initial_imputer_.transform(X)
@@ -685,6 +691,10 @@ class IterativeImputer(_BaseImputer):
         Xt : array-like, shape (n_samples, n_features)
             The imputed input data.
         """
+        if self.initial_strategy != "constant" and self.fill_value is not None:
+            raise ValueError(
+                "fill_value cannot be used when initial_strategy is not 'constant'."
+            )
         self._validate_params()
         self.random_state_ = getattr(
             self, "random_state_", check_random_state(self.random_state)
diff --git a/sklearn/impute/tests/test_impute.py b/sklearn/impute/tests/test_impute.py
index 86553effa..f3094052b 100644
--- a/sklearn/impute/tests/test_impute.py
+++ b/sklearn/impute/tests/test_impute.py
@@ -1691,3 +1691,58 @@ def test_simple_imputer_keep_empty_features(strategy, array_type, keep_empty_fea
             assert_array_equal(constant_feature, 0)
         else:
             assert X_imputed.shape == (X.shape[0], X.shape[1] - 1)
+
+
+def test_iterative_imputer_fill_value():
+    """Test IterativeImputer with initial_strategy='constant' and fill_value."""
+    X_missing = np.array([[1, 2, np.nan], [3, 4, 5], [np.nan, 6, 7], [8, 9, 0]])
+    fill_val = -1
+
+    # Test with a numeric fill_value
+    imputer = IterativeImputer(
+        initial_strategy="constant",
+        fill_value=fill_val,
+        max_iter=1,  # Use 1 iter to check initial imputation
+        random_state=0
+    )
+    X_imputed = imputer.fit_transform(X_missing)
+
+    # Check that the initial imputation used the fill_value
+    # The first iteration will refine this, so we check the initial_imputer_
+    assert imputer.initial_imputer_.fill_value == fill_val
+    # Check that the initial imputed values were indeed the fill_value
+    # Need to reconstruct the initial state before the first iteration's prediction
+    X_filled_initial = imputer.initial_imputer_.fit_transform(X_missing)
+    assert X_filled_initial[0, 2] == fill_val
+    assert X_filled_initial[2, 0] == fill_val
+
+    # Test with np.nan fill_value
+    imputer_nan = IterativeImputer(
+        initial_strategy="constant",
+        fill_value=np.nan,
+        max_iter=1,
+        random_state=0
+    )
+    # Should not raise error, especially with tree-based estimators
+    imputer_nan.fit_transform(X_missing)
+    assert np.isnan(imputer_nan.initial_imputer_.fill_value)
+    X_filled_initial_nan = imputer_nan.initial_imputer_.fit_transform(X_missing)
+    assert np.isnan(X_filled_initial_nan[0, 2])
+    assert np.isnan(X_filled_initial_nan[2, 0])
+
+    # Test validation: fill_value with non-constant strategy
+    with pytest.raises(ValueError, match="fill_value cannot be used"):
+        IterativeImputer(initial_strategy="mean", fill_value=0).fit(X_missing)
+
+    with pytest.raises(ValueError, match="fill_value cannot be used"):
+        IterativeImputer(initial_strategy="median", fill_value=0).fit(X_missing)
+
+    with pytest.raises(ValueError, match="fill_value cannot be used"):
+        IterativeImputer(initial_strategy="most_frequent", fill_value=0).fit(X_missing)
+
+    # Test validation: default fill_value=None works with other strategies
+    IterativeImputer(initial_strategy="mean").fit(X_missing)  # Should not raise
+    IterativeImputer(initial_strategy="median").fit(X_missing)  # Should not raise
+    IterativeImputer(initial_strategy="most_frequent").fit(X_missing) # Should not raise
+
+    print("Script completed successfully, no errors.")
\ No newline at end of file
