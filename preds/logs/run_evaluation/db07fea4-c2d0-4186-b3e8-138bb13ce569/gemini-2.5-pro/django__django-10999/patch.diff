diff --git a/django/utils/dateparse.py b/django/utils/dateparse.py
index 8d08b7d1d3..7406c8f55f 100644
--- a/django/utils/dateparse.py
+++ b/django/utils/dateparse.py
@@ -6,6 +6,7 @@
 # - The date/datetime/time constructors produce friendlier error messages.
 
 import datetime
+from decimal import Decimal
 import re
 
 from django.utils.timezone import get_fixed_timezone, utc
@@ -29,7 +30,7 @@ datetime_re = re.compile(
 standard_duration_re = re.compile(
     r'^'
     r'(?:(?P<days>-?\d+) (days?, )?)?'
-    r'((?:(?P<hours>-?\d+):)(?=\d+:\d+))?'
+    r'((?:(?P<hours>-?\d+):)(?=-?\d+:-?\d+))?'
     r'(?:(?P<minutes>-?\d+):)?'
     r'(?P<seconds>-?\d+)'
     r'(?:\.(?P<microseconds>\d{1,6})\d{0,6})?'
@@ -143,4 +144,27 @@ def parse_duration(value):
         if kw.get('seconds') and kw.get('microseconds') and kw['seconds'].startswith('-'):
             kw['microseconds'] = '-' + kw['microseconds']
         kw = {k: float(v) for k, v in kw.items() if v is not None}
+        is_standard_format = 'sign' not in match.re.groupindex
+        if is_standard_format:
+            # Check if any captured component was negative in the original string.
+            any_negative = False
+            original_groups = match.groupdict()
+            # Check days separately if it exists in the standard format match
+            original_days = original_groups.get('days')
+            if original_days and original_days.startswith('-'):
+                any_negative = True
+            else:
+                # Check other components only if days wasn't negative
+                for key in ['hours', 'minutes', 'seconds', 'microseconds']:
+                    original_value = original_groups.get(key)
+                    if original_value and original_value.startswith('-'):
+                        any_negative = True
+                        break
+            if any_negative:
+                # If any component was negative, ensure all *float* components are negative or zero.
+                # Note: days component is handled separately by adding timedelta(days)
+                for key in ['hours', 'minutes', 'seconds', 'microseconds']:
+                    if key in kw:
+                        kw[key] = -abs(kw[key])
+
         return days + sign * datetime.timedelta(**kw)
