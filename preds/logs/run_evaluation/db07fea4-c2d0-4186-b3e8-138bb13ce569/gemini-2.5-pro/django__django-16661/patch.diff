diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py
index 5240b07cd6..4d732c0568 100644
--- a/django/contrib/admin/options.py
+++ b/django/contrib/admin/options.py
@@ -452,29 +452,27 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
             ).items():
                 return True
 
-        relation_parts = []
-        prev_field = None
-        for part in lookup.split(LOOKUP_SEP):
+        parts = lookup.split(LOOKUP_SEP)
+        relation_parts = [] # Parts representing relations followed
+        # Use a temp variable for model traversal. Preserve self.model.
+        current_model = self.model
+        for part in parts:
             try:
-                field = model._meta.get_field(part)
+                field = current_model._meta.get_field(part)
             except FieldDoesNotExist:
-                # Lookups on nonexistent fields are ok, since they're ignored
-                # later.
+                # Non-existent field/transform, stop relation traversal
                 break
-            # It is allowed to filter on values that would be found from local
-            # model anyways. For example, if you filter on employee__department__id,
-            # then the id value would be found already from employee__department_id.
-            if not prev_field or (
-                prev_field.is_relation
-                and field not in prev_field.path_infos[-1].target_fields
-            ):
+
+            # Check if it's a relation we can follow.
+            # Needs to be a relation and have path_infos to follow.
+            if getattr(field, 'is_relation', False) and hasattr(field, 'path_infos'):
                 relation_parts.append(part)
-            if not getattr(field, "path_infos", None):
-                # This is not a relational field, so further parts
-                # must be transforms.
+                # Follow the relation to the next model
+                current_model = field.remote_field.model
+            else:
+                # Not a relation we can follow (non-relation, transform, or end of chain)
+                # Stop relation traversal
                 break
-            prev_field = field
-            model = field.path_infos[-1].to_opts.model
 
         if len(relation_parts) <= 1:
             # Either a local field filter, or no fields at all.
@@ -490,11 +488,18 @@ class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
             else:
                 valid_lookups.add(filter_item)
 
-        # Is it a valid relational lookup?
-        return not {
-            LOOKUP_SEP.join(relation_parts),
-            LOOKUP_SEP.join(relation_parts + [part]),
-        }.isdisjoint(valid_lookups)
+        # Check if the traversed relation path, or the full original lookup string,
+        # is present in the valid lookups.
+        relation_path = LOOKUP_SEP.join(relation_parts)
+        check_set = set()
+        if relation_path:
+            check_set.add(relation_path)
+
+        # Use the original lookup string as the "full path" to check
+        if lookup != relation_path:
+            check_set.add(lookup)
+
+        return not check_set.isdisjoint(valid_lookups)
 
     def to_field_allowed(self, request, to_field):
         """
diff --git a/tests/modeladmin/tests.py b/tests/modeladmin/tests.py
index c6b4a565c8..08afdce125 100644
--- a/tests/modeladmin/tests.py
+++ b/tests/modeladmin/tests.py
@@ -807,6 +807,23 @@ class ModelAdminTests(TestCase):
         )
 
 
+    @isolate_apps('modeladmin')
+    def test_lookup_allowed_foreign_primary(self):
+        class Country(models.Model):
+            name = models.CharField(max_length=256)
+        class Place(models.Model):
+            country = models.ForeignKey(Country, models.CASCADE)
+        class Restaurant(models.Model):
+            place = models.OneToOneField(Place, models.CASCADE, primary_key=True)
+        class Waiter(models.Model):
+            restaurant = models.ForeignKey(Restaurant, models.CASCADE)
+        class WaiterAdmin(ModelAdmin):
+            list_filter = [
+                'restaurant__place__country',
+            ]
+        ma = WaiterAdmin(Waiter, self.site)
+        self.assertIs(ma.lookup_allowed('restaurant__place__country', 'test_value'), True)
+
 class ModelAdminPermissionTests(SimpleTestCase):
     class MockUser:
         def has_module_perms(self, app_label):
