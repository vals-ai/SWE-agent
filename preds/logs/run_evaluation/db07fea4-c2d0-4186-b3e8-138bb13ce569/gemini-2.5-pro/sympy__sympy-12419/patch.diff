diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..0017b75fef
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,25 @@
+
+from sympy import *
+from sympy import Q as Query
+
+n = Symbol('n', integer=True, positive=True)
+i, j = symbols('i j', integer=True)
+M = MatrixSymbol('M', n, n)
+
+e = None
+with assuming(Query.orthogonal(M)):
+    e = refine(M.T * M).doit()
+
+# Correct: M.T * M is an identity matrix.
+print(e, e[0, 0], e[0, 1], e[1, 0], e[1, 1])
+
+# Correct: The output is True True
+print(ask(Query.diagonal(e)), ask(Query.integer_elements(e)))
+
+# Correct: The sum of the diagonal elements is n
+print(Sum(e[i, i], (i, 0, n-1)).doit())
+
+# So far so good
+# Total sum of the elements is expected to be 'n' but the answer is 0!
+print(Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit())
+print("Script completed successfully, no errors.")
\ No newline at end of file
diff --git a/sympy/concrete/summations.py b/sympy/concrete/summations.py
index 372487664c..f4784228ff 100644
--- a/sympy/concrete/summations.py
+++ b/sympy/concrete/summations.py
@@ -174,8 +174,6 @@ def doit(self, **hints):
         else:
             f = self.function
 
-        if self.function.is_Matrix:
-            return self.expand().doit()
 
         for n, limit in enumerate(self.limits):
             i, a, b = limit
diff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py
index b4d759836e..651dc15c6c 100644
--- a/sympy/matrices/expressions/matexpr.py
+++ b/sympy/matrices/expressions/matexpr.py
@@ -8,6 +8,7 @@
 from sympy.core.sympify import SympifyError, sympify
 from sympy.functions import conjugate, adjoint
 from sympy.matrices import ShapeError
+from sympy.functions.special.tensor_functions import KroneckerDelta
 from sympy.simplify import simplify
 
 
@@ -476,10 +477,20 @@ def conjugate(self):
         return self
 
     def _entry(self, i, j):
-        if i == j:
+        # Sympify i and j just in case
+        i, j = sympify(i), sympify(j)
+        # If i and j are definitively equal (e.g., same symbol, same integer)
+        eq = (i == j)
+        if eq is S.true:
             return S.One
-        else:
+        # If i and j are definitively not equal (e.g., different integers)
+        # Check if the comparison evaluated to False
+        elif eq is S.false:
             return S.Zero
+        # Otherwise (symbolic comparison is False or None), return KroneckerDelta
+        else:
+            # KroneckerDelta already imported at the top
+            return KroneckerDelta(i, j)
 
     def _eval_determinant(self):
         return S.One
