diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..d91ddb91ef
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,11 @@
+
+from sympy.utilities.lambdify import implemented_function
+from sympy import Function
+
+f = implemented_function('f', lambda x: x ** 2)
+g = implemented_function('g', lambda x: 2 * x)
+
+print(f(  2 ).evalf())
+print(  g(2) .evalf())
+print(f(g(2)).evalf())
+print("Script completed successfully, no errors.")
\ No newline at end of file
diff --git a/sympy/core/function.py b/sympy/core/function.py
index 1b8005e1d2..e05fd8b642 100644
--- a/sympy/core/function.py
+++ b/sympy/core/function.py
@@ -506,10 +506,45 @@ def _eval_evalf(self, prec):
                 fname = MPMATH_TRANSLATIONS[fname]
             func = getattr(mpmath, fname)
         except (AttributeError, KeyError):
+            # Fall back to _imp_ if possible
+            if not hasattr(self, '_imp_'):
+                return None # No implementation available
+
+            # Check if all args are numeric before calling _imp_
+            if not all(a.is_number for a in self.args):
+                # Don't evaluate if args are symbolic
+                return self # Return the function unevaluated
+
             try:
-                return Float(self._imp_(*self.args), prec)
-            except (AttributeError, TypeError, ValueError):
-                return
+                # Evaluate the function using _imp_ with numeric args
+                # We need to evalf the args first to the desired precision
+                evalf_args = [a.evalf(prec) for a in self.args]
+                # Check if evalf succeeded for all args before passing to _imp_
+                if not all(a.is_number for a in evalf_args):
+                    return self # Return original if any arg evalf failed
+
+                imp_res = self._imp_(*evalf_args)
+
+                if hasattr(imp_res, 'evalf'):
+                    # If the result is a SymPy expression, evalf it recursively
+                    evalf_res = imp_res.evalf(prec)
+                    # Return the result only if it's numeric
+                    if evalf_res.is_number:
+                        return evalf_res
+                    else:
+                        # Symbolic result from recursive evalf, return original function
+                        return self
+                else:
+                    # If _imp_ returns a python number or other non-evalf object,
+                    # try wrapping it in Float.
+                    try:
+                        return Float(imp_res, prec)
+                    except TypeError:
+                        # If it's not convertible (e.g., symbolic), return original function
+                        return self
+            except (TypeError, ValueError):
+                # Error during _imp_ call or Float conversion (e.g., wrong arg types)
+                return self # Return the function unevaluated
 
         # Convert all args to mpf or mpc
         # Convert the arguments to *higher* precision than requested for the
diff --git a/sympy/core/tests/test_evalf.py b/sympy/core/tests/test_evalf.py
index 1d63f9ea93..eab6c3857a 100644
--- a/sympy/core/tests/test_evalf.py
+++ b/sympy/core/tests/test_evalf.py
@@ -1,5 +1,5 @@
 from sympy import (Abs, Add, atan, ceiling, cos, E, Eq, exp,
-    factorial, fibonacci, floor, Function, GoldenRatio, I, Integral,
+    factorial, fibonacci, floor, Float, Function, GoldenRatio, I, Integral,
     integrate, log, Mul, N, oo, pi, Pow, product, Product,
     Rational, S, Sum, sin, sqrt, sstr, sympify, Symbol, Max, nfloat)
 from sympy.core.evalf import (complex_accuracy, PrecisionExhausted,
@@ -506,4 +506,19 @@ def test_issue_10395():
     assert nfloat(eq) == eq
     eq = x*Max(y, -1.1)
     assert nfloat(eq) == eq
+
+
+def test_evalf_implemented_function_recursion():
+    # Test for issue #12037
+    from sympy.utilities.lambdify import implemented_function
+    f = implemented_function('f', lambda x: x ** 2)
+    g = implemented_function('g', lambda x: 2 * x)
+    # Test direct evaluation
+    assert f(2).evalf() == Float(4.0)
+    assert g(2).evalf() == Float(4.0)
+    # Test nested evaluation
+    assert f(g(2)).evalf() == Float(16.0)
+    # Test with symbolic argument (should remain unevaluated)
+    x = Symbol('x')
+    assert f(g(x)).evalf() == f(g(x))
     assert Max(y, 4).n() == Max(4.0, y)
