diff --git a/lib/matplotlib/contour.py b/lib/matplotlib/contour.py
index 3f84250b64..1965f791d8 100644
--- a/lib/matplotlib/contour.py
+++ b/lib/matplotlib/contour.py
@@ -1329,6 +1329,17 @@ class ContourSet(ContourLabeler, mcoll.Collection):
                 raise ValueError("Unrecognized type for linestyles kwarg")
         return tlinestyles
 
+    def set_paths(self, paths):
+        """
+        Set the paths for this ContourSet.
+
+        Parameters
+        ----------
+        paths : list of `.Path`
+            The paths to use for this ContourSet.
+        """
+        self._paths = paths
+
     def _find_nearest_contour(self, xy, indices=None):
         """
         Find the point in the unfilled contour plot that is closest (in screen
diff --git a/lib/matplotlib/tests/test_contour.py b/lib/matplotlib/tests/test_contour.py
index b6ddb2830a..4086069193 100644
--- a/lib/matplotlib/tests/test_contour.py
+++ b/lib/matplotlib/tests/test_contour.py
@@ -816,10 +816,54 @@ def test_deprecated_apis():
     with pytest.warns(mpl.MatplotlibDeprecationWarning, match="collections"):
         colls = cs.collections
     with pytest.warns(PendingDeprecationWarning, match="allsegs"):
-        assert cs.allsegs == [p.vertices for c in colls for p in c.get_paths()]
+        # Accessing allsegs also accesses collections, which warns too.
+        # Nest the checks.
+        with pytest.warns(mpl.MatplotlibDeprecationWarning, match="collections"):
+            assert cs.allsegs == [p.vertices for c in colls for p in c.get_paths()]
     with pytest.warns(PendingDeprecationWarning, match="allkinds"):
-        assert cs.allkinds == [p.codes for c in colls for p in c.get_paths()]
+        # Accessing allkinds also accesses collections, which warns too.
+        # Nest the checks.
+        with pytest.warns(mpl.MatplotlibDeprecationWarning, match="collections"):
+            assert cs.allkinds == [p.codes for c in colls for p in c.get_paths()]
     with pytest.warns(mpl.MatplotlibDeprecationWarning, match="tcolors"):
         assert_array_equal(cs.tcolors, [c.get_edgecolor() for c in colls])
     with pytest.warns(mpl.MatplotlibDeprecationWarning, match="tlinewidths"):
         assert cs.tlinewidths == [c.get_linewidth() for c in colls]
+
+
+def test_set_paths():
+    fig, ax = plt.subplots()
+    cs = ax.contour([[0, 1], [2, 3]])
+    original_paths = cs.get_paths()
+    assert len(original_paths) > 0  # Ensure we have some paths initially
+
+    # Create some dummy paths (e.g., simple squares)
+    new_paths = [
+        mpl.path.Path([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]),
+        mpl.path.Path([[2, 2], [3, 2], [3, 3], [2, 3], [2, 2]])
+    ]
+
+    # Use the new set_paths method
+    cs.set_paths(new_paths)
+
+    # Verify the paths have been updated
+    retrieved_paths = cs.get_paths()
+    assert retrieved_paths is new_paths  # Check object identity
+    assert len(retrieved_paths) == 2
+    assert_array_equal(retrieved_paths[0].vertices, new_paths[0].vertices)
+    assert_array_equal(retrieved_paths[1].vertices, new_paths[1].vertices)
+
+    # Test setting empty paths
+    cs.set_paths([])
+    assert cs.get_paths() == []
+
+    # Test setting paths with different structures
+    path1 = mpl.path.Path([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]) # 5 vertices
+    path2 = mpl.path.Path([[2, 2], [3, 2], [3, 3], [2, 2]]) # 4 vertices
+    mixed_paths = [path1, path2]
+    cs.set_paths(mixed_paths)
+    retrieved_mixed = cs.get_paths()
+    assert retrieved_mixed is mixed_paths
+    assert len(retrieved_mixed) == 2
+    assert_array_equal(retrieved_mixed[0].vertices, path1.vertices)
+    assert_array_equal(retrieved_mixed[1].vertices, path2.vertices)
