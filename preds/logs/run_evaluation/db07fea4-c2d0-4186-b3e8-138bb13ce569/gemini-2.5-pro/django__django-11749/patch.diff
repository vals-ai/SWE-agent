diff --git a/django/core/management/__init__.py b/django/core/management/__init__.py
index 5f2e64761e..07b640a66d 100644
--- a/django/core/management/__init__.py
+++ b/django/core/management/__init__.py
@@ -1,3 +1,4 @@
+import argparse
 import functools
 import os
 import pkgutil
@@ -133,8 +134,12 @@ def call_command(command_name, *args, **options):
     # Any required arguments which are passed in via **options must be passed
     # to parse_args().
     parse_args += [
-        '{}={}'.format(min(opt.option_strings), arg_options[opt.dest])
-        for opt in parser_actions if opt.required and opt.dest in options
+        (min(opt.option_strings) if isinstance(opt, (argparse._StoreTrueAction, argparse._StoreFalseAction))
+         else '{}={}'.format(min(opt.option_strings), arg_options[opt.dest]))
+        for opt in parser_actions if (opt.required or any(
+            group.required and opt in group._group_actions
+            for group in parser._mutually_exclusive_groups
+        )) and opt.dest in arg_options
     ]
     defaults = parser.parse_args(args=parse_args)
     defaults = dict(defaults._get_kwargs(), **arg_options)
diff --git a/tests/user_commands/management/commands/mutual_exclusive_cmd.py b/tests/user_commands/management/commands/mutual_exclusive_cmd.py
new file mode 100644
index 0000000000..b774230c64
--- /dev/null
+++ b/tests/user_commands/management/commands/mutual_exclusive_cmd.py
@@ -0,0 +1,22 @@
+
+from io import StringIO
+
+from django.core.management.base import BaseCommand
+
+
+class Command(BaseCommand):
+    help = "Test command with a required mutually exclusive group."
+
+    def add_arguments(self, parser):
+        group = parser.add_mutually_exclusive_group(required=True)
+        group.add_argument("--option_a", action="store_true", help="Option A.")
+        group.add_argument("--option_b", help="Option B.")
+
+    def handle(self, *args, **options):
+        if options["option_a"]:
+            self.stdout.write("Option A selected")
+        elif options["option_b"]:
+            self.stdout.write(f"Option B selected: {options['option_b']}")
+        else:
+            # This should not happen if the group is required and parsing works
+            self.stderr.write("Error: No option selected in required group.")
\ No newline at end of file
diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py
index a53c781ac6..1421768d40 100644
--- a/tests/user_commands/tests.py
+++ b/tests/user_commands/tests.py
@@ -209,6 +209,20 @@ class CommandTests(SimpleTestCase):
         self.assertIn('need_me', out.getvalue())
         self.assertIn('needme2', out.getvalue())
 
+    def test_call_command_mutually_exclusive_required_group_kwargs(self):
+        """
+        call_command works with kwargs for an option in a required mutually
+        exclusive group (#33209).
+        """
+        out = StringIO()
+        # Test with the boolean option
+        management.call_command('mutual_exclusive_cmd', option_a=True, stdout=out)
+        self.assertIn("Option A selected", out.getvalue())
+        # Test with the value option
+        out = StringIO()
+        management.call_command('mutual_exclusive_cmd', option_b='xyz', stdout=out)
+        self.assertIn("Option B selected: xyz", out.getvalue())
+
     def test_command_add_arguments_after_common_arguments(self):
         out = StringIO()
         management.call_command('common_args', stdout=out)
