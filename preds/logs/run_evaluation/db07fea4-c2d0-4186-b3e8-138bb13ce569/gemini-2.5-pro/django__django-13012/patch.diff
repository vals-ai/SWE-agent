diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
index c1a76584f0..14d6a1e525 100644
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -866,6 +866,9 @@ class ExpressionWrapper(Expression):
     def as_sql(self, compiler, connection):
         return self.expression.as_sql(compiler, connection)
 
+    def get_group_by_cols(self, alias=None):
+        return self.expression.get_group_by_cols(alias=alias)
+
     def __repr__(self):
         return "{}({})".format(self.__class__.__name__, self.expression)
 
diff --git a/tests/migrations/__init__.py b/tests/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/deprecated_field_migrations/0001_initial.py b/tests/migrations/deprecated_field_migrations/0001_initial.py
deleted file mode 100644
index 8665d5b2ff..0000000000
--- a/tests/migrations/deprecated_field_migrations/0001_initial.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='IPAddressField',
-            fields=[
-                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
-                ('ip', models.IPAddressField(null=True, blank=True)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/deprecated_field_migrations/0002_remove_ipaddressfield_ip.py b/tests/migrations/deprecated_field_migrations/0002_remove_ipaddressfield_ip.py
deleted file mode 100644
index 1b27bf536d..0000000000
--- a/tests/migrations/deprecated_field_migrations/0002_remove_ipaddressfield_ip.py
+++ /dev/null
@@ -1,15 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('migrations', '0001_initial'),
-    ]
-
-    operations = [
-        migrations.RemoveField(
-            model_name='ipaddressfield',
-            name='ip',
-        ),
-    ]
diff --git a/tests/migrations/deprecated_field_migrations/__init__.py b/tests/migrations/deprecated_field_migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/faulty_migrations/__init__.py b/tests/migrations/faulty_migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/faulty_migrations/file.py b/tests/migrations/faulty_migrations/file.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/faulty_migrations/namespace/foo/__init__.py b/tests/migrations/faulty_migrations/namespace/foo/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/__init__.py b/tests/migrations/migrations_test_apps/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/alter_fk/__init__.py b/tests/migrations/migrations_test_apps/alter_fk/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/alter_fk/author_app/__init__.py b/tests/migrations/migrations_test_apps/alter_fk/author_app/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/alter_fk/author_app/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/alter_fk/author_app/migrations/0001_initial.py
deleted file mode 100644
index 48664b2a04..0000000000
--- a/tests/migrations/migrations_test_apps/alter_fk/author_app/migrations/0001_initial.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='Author',
-            fields=[
-                ('id', models.AutoField(serialize=False, auto_created=True, primary_key=True)),
-                ('name', models.CharField(max_length=50)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/alter_fk/author_app/migrations/0002_alter_id.py b/tests/migrations/migrations_test_apps/alter_fk/author_app/migrations/0002_alter_id.py
deleted file mode 100644
index 18bc91ad72..0000000000
--- a/tests/migrations/migrations_test_apps/alter_fk/author_app/migrations/0002_alter_id.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('author_app', '0001_initial'),
-        ('book_app', '0001_initial'),  # Forces the book table to alter the FK
-    ]
-
-    operations = [
-        migrations.AlterField(
-            model_name='author',
-            name='id',
-            field=models.CharField(max_length=10, primary_key=True),
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/alter_fk/author_app/migrations/__init__.py b/tests/migrations/migrations_test_apps/alter_fk/author_app/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/alter_fk/book_app/__init__.py b/tests/migrations/migrations_test_apps/alter_fk/book_app/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/alter_fk/book_app/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/alter_fk/book_app/migrations/0001_initial.py
deleted file mode 100644
index 46543caeee..0000000000
--- a/tests/migrations/migrations_test_apps/alter_fk/book_app/migrations/0001_initial.py
+++ /dev/null
@@ -1,19 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('author_app', '0001_initial'),
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='Book',
-            fields=[
-                ('id', models.AutoField(serialize=False, auto_created=True, primary_key=True)),
-                ('title', models.CharField(max_length=50)),
-                ('author', models.ForeignKey('author_app.Author', models.CASCADE)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/alter_fk/book_app/migrations/__init__.py b/tests/migrations/migrations_test_apps/alter_fk/book_app/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/__init__.py b/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0001_initial.py
deleted file mode 100644
index ddf070a8cd..0000000000
--- a/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0001_initial.py
+++ /dev/null
@@ -1,24 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        )
-    ]
diff --git a/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0002_conflicting_second.py b/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0002_conflicting_second.py
deleted file mode 100644
index 16fd7dbfee..0000000000
--- a/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0002_conflicting_second.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ("conflicting_app_with_dependencies", "0001_initial"),
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            "Something",
-            [
-                ("id", models.AutoField(primary_key=True)),
-            ],
-        )
-    ]
diff --git a/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0002_second.py b/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0002_second.py
deleted file mode 100644
index d612af5726..0000000000
--- a/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/0002_second.py
+++ /dev/null
@@ -1,21 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ("conflicting_app_with_dependencies", "0001_initial"),
-        ("migrated_app", "0001_initial"),
-    ]
-
-    operations = [
-        migrations.DeleteModel("Tribble"),
-        migrations.RemoveField("Author", "silly_field"),
-        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-            ],
-        )
-    ]
diff --git a/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/__init__.py b/tests/migrations/migrations_test_apps/conflicting_app_with_dependencies/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/lookuperror_a/__init__.py b/tests/migrations/migrations_test_apps/lookuperror_a/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0001_initial.py
deleted file mode 100644
index 6351b0d212..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0001_initial.py
+++ /dev/null
@@ -1,16 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='A1',
-            fields=[
-                ('id', models.AutoField(serialize=False, verbose_name='ID', auto_created=True, primary_key=True)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0002_a2.py b/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0002_a2.py
deleted file mode 100644
index ab943b9c77..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0002_a2.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('lookuperror_a', '0001_initial'),
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='A2',
-            fields=[
-                ('id', models.AutoField(verbose_name='ID', primary_key=True, serialize=False, auto_created=True)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0003_a3.py b/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0003_a3.py
deleted file mode 100644
index 42b5853d3c..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0003_a3.py
+++ /dev/null
@@ -1,21 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('lookuperror_c', '0002_c2'),
-        ('lookuperror_b', '0002_b2'),
-        ('lookuperror_a', '0002_a2'),
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='A3',
-            fields=[
-                ('id', models.AutoField(serialize=False, auto_created=True, primary_key=True, verbose_name='ID')),
-                ('b2', models.ForeignKey('lookuperror_b.B2', models.CASCADE)),
-                ('c2', models.ForeignKey('lookuperror_c.C2', models.CASCADE)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0004_a4.py b/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0004_a4.py
deleted file mode 100644
index b7a0bcb8a7..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_a/migrations/0004_a4.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('lookuperror_a', '0003_a3'),
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='A4',
-            fields=[
-                ('id', models.AutoField(auto_created=True, serialize=False, verbose_name='ID', primary_key=True)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/lookuperror_a/migrations/__init__.py b/tests/migrations/migrations_test_apps/lookuperror_a/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/lookuperror_a/models.py b/tests/migrations/migrations_test_apps/lookuperror_a/models.py
deleted file mode 100644
index 9428f952eb..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_a/models.py
+++ /dev/null
@@ -1,18 +0,0 @@
-from django.db import models
-
-
-class A1(models.Model):
-    pass
-
-
-class A2(models.Model):
-    pass
-
-
-class A3(models.Model):
-    b2 = models.ForeignKey('lookuperror_b.B2', models.CASCADE)
-    c2 = models.ForeignKey('lookuperror_c.C2', models.CASCADE)
-
-
-class A4(models.Model):
-    pass
diff --git a/tests/migrations/migrations_test_apps/lookuperror_b/__init__.py b/tests/migrations/migrations_test_apps/lookuperror_b/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0001_initial.py
deleted file mode 100644
index def52ae789..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0001_initial.py
+++ /dev/null
@@ -1,16 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='B1',
-            fields=[
-                ('id', models.AutoField(serialize=False, auto_created=True, primary_key=True, verbose_name='ID')),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0002_b2.py b/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0002_b2.py
deleted file mode 100644
index a2ac5e1ba7..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0002_b2.py
+++ /dev/null
@@ -1,19 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('lookuperror_a', '0002_a2'),
-        ('lookuperror_b', '0001_initial'),
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='B2',
-            fields=[
-                ('id', models.AutoField(primary_key=True, verbose_name='ID', auto_created=True, serialize=False)),
-                ('a1', models.ForeignKey('lookuperror_a.A1', models.CASCADE)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0003_b3.py b/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0003_b3.py
deleted file mode 100644
index 1c76e73ec1..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_b/migrations/0003_b3.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('lookuperror_b', '0002_b2'),
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='B3',
-            fields=[
-                ('id', models.AutoField(verbose_name='ID', serialize=False, primary_key=True, auto_created=True)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/lookuperror_b/migrations/__init__.py b/tests/migrations/migrations_test_apps/lookuperror_b/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/lookuperror_b/models.py b/tests/migrations/migrations_test_apps/lookuperror_b/models.py
deleted file mode 100644
index ed78c48e68..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_b/models.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from django.db import models
-
-
-class B1(models.Model):
-    pass
-
-
-class B2(models.Model):
-    a1 = models.ForeignKey('lookuperror_a.A1', models.CASCADE)
-
-
-class B3(models.Model):
-    pass
diff --git a/tests/migrations/migrations_test_apps/lookuperror_c/__init__.py b/tests/migrations/migrations_test_apps/lookuperror_c/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0001_initial.py
deleted file mode 100644
index 8453148b87..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0001_initial.py
+++ /dev/null
@@ -1,16 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='C1',
-            fields=[
-                ('id', models.AutoField(serialize=False, verbose_name='ID', auto_created=True, primary_key=True)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0002_c2.py b/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0002_c2.py
deleted file mode 100644
index a928da9ae0..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0002_c2.py
+++ /dev/null
@@ -1,19 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('lookuperror_a', '0002_a2'),
-        ('lookuperror_c', '0001_initial'),
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='C2',
-            fields=[
-                ('id', models.AutoField(auto_created=True, verbose_name='ID', primary_key=True, serialize=False)),
-                ('a1', models.ForeignKey('lookuperror_a.A1', models.CASCADE)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0003_c3.py b/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0003_c3.py
deleted file mode 100644
index 58119ac8ac..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_c/migrations/0003_c3.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('lookuperror_c', '0002_c2'),
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='C3',
-            fields=[
-                ('id', models.AutoField(auto_created=True, serialize=False, verbose_name='ID', primary_key=True)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/migrations_test_apps/lookuperror_c/migrations/__init__.py b/tests/migrations/migrations_test_apps/lookuperror_c/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/lookuperror_c/models.py b/tests/migrations/migrations_test_apps/lookuperror_c/models.py
deleted file mode 100644
index 5dc28ae5ba..0000000000
--- a/tests/migrations/migrations_test_apps/lookuperror_c/models.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from django.db import models
-
-
-class C1(models.Model):
-    pass
-
-
-class C2(models.Model):
-    a1 = models.ForeignKey('lookuperror_a.A1', models.CASCADE)
-
-
-class C3(models.Model):
-    pass
diff --git a/tests/migrations/migrations_test_apps/migrated_app/__init__.py b/tests/migrations/migrations_test_apps/migrated_app/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/migrated_app/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/migrated_app/migrations/0001_initial.py
deleted file mode 100644
index 344bebdfe3..0000000000
--- a/tests/migrations/migrations_test_apps/migrated_app/migrations/0001_initial.py
+++ /dev/null
@@ -1,27 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/migrations_test_apps/migrated_app/migrations/__init__.py b/tests/migrations/migrations_test_apps/migrated_app/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/migrated_app/models.py b/tests/migrations/migrations_test_apps/migrated_app/models.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/migrated_unapplied_app/__init__.py b/tests/migrations/migrations_test_apps/migrated_unapplied_app/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/migrated_unapplied_app/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/migrated_unapplied_app/migrations/0001_initial.py
deleted file mode 100644
index 800ceed7e4..0000000000
--- a/tests/migrations/migrations_test_apps/migrated_unapplied_app/migrations/0001_initial.py
+++ /dev/null
@@ -1,19 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-
-        migrations.CreateModel(
-            "OtherAuthor",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-
-    ]
diff --git a/tests/migrations/migrations_test_apps/migrated_unapplied_app/migrations/__init__.py b/tests/migrations/migrations_test_apps/migrated_unapplied_app/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/migrated_unapplied_app/models.py b/tests/migrations/migrations_test_apps/migrated_unapplied_app/models.py
deleted file mode 100644
index efb71e637f..0000000000
--- a/tests/migrations/migrations_test_apps/migrated_unapplied_app/models.py
+++ /dev/null
@@ -1,12 +0,0 @@
-from django.db import models
-
-
-class OtherAuthor(models.Model):
-    id = models.AutoField(primary_key=True)
-    name = models.CharField(max_length=255)
-    slug = models.SlugField(null=True)
-    age = models.IntegerField(default=0)
-    silly_field = models.BooleanField(default=False)
-
-    class Meta:
-        app_label = "migrated_unapplied_app"
diff --git a/tests/migrations/migrations_test_apps/mutate_state_a/__init__.py b/tests/migrations/migrations_test_apps/mutate_state_a/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/mutate_state_a/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/mutate_state_a/migrations/0001_initial.py
deleted file mode 100644
index 37c9bf7377..0000000000
--- a/tests/migrations/migrations_test_apps/mutate_state_a/migrations/0001_initial.py
+++ /dev/null
@@ -1,19 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('mutate_state_b', '0001_initial'),
-    ]
-
-    operations = [
-        migrations.SeparateDatabaseAndState([], [
-            migrations.CreateModel(
-                name='A',
-                fields=[
-                    ('id', models.AutoField(serialize=False, verbose_name='ID', auto_created=True, primary_key=True)),
-                ],
-            ),
-        ])
-    ]
diff --git a/tests/migrations/migrations_test_apps/mutate_state_a/migrations/__init__.py b/tests/migrations/migrations_test_apps/mutate_state_a/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/mutate_state_b/__init__.py b/tests/migrations/migrations_test_apps/mutate_state_b/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/mutate_state_b/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/mutate_state_b/migrations/0001_initial.py
deleted file mode 100644
index 51c022dd7f..0000000000
--- a/tests/migrations/migrations_test_apps/mutate_state_b/migrations/0001_initial.py
+++ /dev/null
@@ -1,18 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-    ]
-
-    operations = [
-        migrations.SeparateDatabaseAndState([], [
-            migrations.CreateModel(
-                name='B',
-                fields=[
-                    ('id', models.AutoField(serialize=False, verbose_name='ID', auto_created=True, primary_key=True)),
-                ],
-            ),
-        ])
-    ]
diff --git a/tests/migrations/migrations_test_apps/mutate_state_b/migrations/0002_add_field.py b/tests/migrations/migrations_test_apps/mutate_state_b/migrations/0002_add_field.py
deleted file mode 100644
index ae968382eb..0000000000
--- a/tests/migrations/migrations_test_apps/mutate_state_b/migrations/0002_add_field.py
+++ /dev/null
@@ -1,18 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('mutate_state_b', '0001_initial'),
-    ]
-
-    operations = [
-        migrations.SeparateDatabaseAndState([], [
-            migrations.AddField(
-                model_name='B',
-                name='added',
-                field=models.TextField(),
-            ),
-        ])
-    ]
diff --git a/tests/migrations/migrations_test_apps/mutate_state_b/migrations/__init__.py b/tests/migrations/migrations_test_apps/mutate_state_b/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/normal/__init__.py b/tests/migrations/migrations_test_apps/normal/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/unmigrated_app/__init__.py b/tests/migrations/migrations_test_apps/unmigrated_app/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/unmigrated_app/models.py b/tests/migrations/migrations_test_apps/unmigrated_app/models.py
deleted file mode 100644
index 03d397c45b..0000000000
--- a/tests/migrations/migrations_test_apps/unmigrated_app/models.py
+++ /dev/null
@@ -1,7 +0,0 @@
-from django.db import models
-
-
-class SillyModel(models.Model):
-    silly_field = models.BooleanField(default=False)
-    silly_tribble = models.ForeignKey("migrations.Tribble", models.CASCADE)
-    is_trouble = models.BooleanField(default=True)
diff --git a/tests/migrations/migrations_test_apps/unmigrated_app_simple/__init__.py b/tests/migrations/migrations_test_apps/unmigrated_app_simple/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/unmigrated_app_simple/models.py b/tests/migrations/migrations_test_apps/unmigrated_app_simple/models.py
deleted file mode 100644
index 785d040800..0000000000
--- a/tests/migrations/migrations_test_apps/unmigrated_app_simple/models.py
+++ /dev/null
@@ -1,9 +0,0 @@
-from django.db import models
-
-
-class UnmigratedModel(models.Model):
-    """
-    A model that is in a migration-less app (which this app is
-    if its migrations directory has not been repointed)
-    """
-    pass
diff --git a/tests/migrations/migrations_test_apps/unmigrated_app_syncdb/__init__.py b/tests/migrations/migrations_test_apps/unmigrated_app_syncdb/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/unmigrated_app_syncdb/models.py b/tests/migrations/migrations_test_apps/unmigrated_app_syncdb/models.py
deleted file mode 100644
index 9f3179cd0d..0000000000
--- a/tests/migrations/migrations_test_apps/unmigrated_app_syncdb/models.py
+++ /dev/null
@@ -1,9 +0,0 @@
-from django.db import models
-
-
-class Classroom(models.Model):
-    pass
-
-
-class Lesson(models.Model):
-    classroom = models.ForeignKey(Classroom, on_delete=models.CASCADE)
diff --git a/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/__init__.py b/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0001_initial.py b/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0001_initial.py
deleted file mode 100644
index 344bebdfe3..0000000000
--- a/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0001_initial.py
+++ /dev/null
@@ -1,27 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0002_conflicting_second.py b/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0002_conflicting_second.py
deleted file mode 100644
index ad44031030..0000000000
--- a/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0002_conflicting_second.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("unspecified_app_with_conflict", "0001_initial")]
-
-    operations = [
-
-        migrations.CreateModel(
-            "Something",
-            [
-                ("id", models.AutoField(primary_key=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0002_second.py b/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0002_second.py
deleted file mode 100644
index fbf5a9110c..0000000000
--- a/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/0002_second.py
+++ /dev/null
@@ -1,23 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("unspecified_app_with_conflict", "0001_initial")]
-
-    operations = [
-
-        migrations.DeleteModel("Tribble"),
-
-        migrations.RemoveField("Author", "silly_field"),
-
-        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/__init__.py b/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/models.py b/tests/migrations/migrations_test_apps/unspecified_app_with_conflict/models.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/with_package_model/__init__.py b/tests/migrations/migrations_test_apps/with_package_model/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/with_package_model/models/__init__.py b/tests/migrations/migrations_test_apps/with_package_model/models/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/without_init_file/__init__.py b/tests/migrations/migrations_test_apps/without_init_file/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/migrations_test_apps/without_init_file/migrations/.keep b/tests/migrations/migrations_test_apps/without_init_file/migrations/.keep
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/models.py b/tests/migrations/models.py
deleted file mode 100644
index 440aa582d6..0000000000
--- a/tests/migrations/models.py
+++ /dev/null
@@ -1,68 +0,0 @@
-from django.apps.registry import Apps
-from django.db import models
-
-
-class CustomModelBase(models.base.ModelBase):
-    pass
-
-
-class ModelWithCustomBase(models.Model, metaclass=CustomModelBase):
-    pass
-
-
-class UnicodeModel(models.Model):
-    title = models.CharField('ÚÑÍ¢ÓÐÉ', max_length=20, default='“Ðjáñgó”')
-
-    class Meta:
-        # Disable auto loading of this model as we load it on our own
-        apps = Apps()
-        verbose_name = 'úñí©óðé µóðéø'
-        verbose_name_plural = 'úñí©óðé µóðéøß'
-
-    def __str__(self):
-        return self.title
-
-
-class Unserializable:
-    """
-    An object that migration doesn't know how to serialize.
-    """
-    pass
-
-
-class UnserializableModel(models.Model):
-    title = models.CharField(max_length=20, default=Unserializable())
-
-    class Meta:
-        # Disable auto loading of this model as we load it on our own
-        apps = Apps()
-
-
-class UnmigratedModel(models.Model):
-    """
-    A model that is in a migration-less app (which this app is
-    if its migrations directory has not been repointed)
-    """
-    pass
-
-
-class EmptyManager(models.Manager):
-    use_in_migrations = True
-
-
-class FoodQuerySet(models.query.QuerySet):
-    pass
-
-
-class BaseFoodManager(models.Manager):
-    def __init__(self, a, b, c=1, d=2):
-        super().__init__()
-        self.args = (a, b, c, d)
-
-
-class FoodManager(BaseFoodManager.from_queryset(FoodQuerySet)):
-    use_in_migrations = True
-
-
-class NoMigrationFoodManager(BaseFoodManager.from_queryset(FoodQuerySet)):
-    pass
diff --git a/tests/migrations/related_models_app/__init__.py b/tests/migrations/related_models_app/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/routers.py b/tests/migrations/routers.py
deleted file mode 100644
index bc036382a7..0000000000
--- a/tests/migrations/routers.py
+++ /dev/null
@@ -1,14 +0,0 @@
-class DefaultOtherRouter:
-    def allow_migrate(self, db, app_label, model_name=None, **hints):
-        return db in {'default', 'other'}
-
-
-class TestRouter:
-    def allow_migrate(self, db, app_label, model_name=None, **hints):
-        """
-        The Tribble model should be the only one to appear in the 'other' db.
-        """
-        if model_name == 'tribble':
-            return db == 'other'
-        elif db != 'default':
-            return False
diff --git a/tests/migrations/test_add_many_to_many_field_initial/0001_initial.py b/tests/migrations/test_add_many_to_many_field_initial/0001_initial.py
deleted file mode 100644
index 50fd06a35f..0000000000
--- a/tests/migrations/test_add_many_to_many_field_initial/0001_initial.py
+++ /dev/null
@@ -1,29 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    initial = True
-
-    dependencies = [
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='Project',
-            fields=[
-                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
-            ],
-        ),
-        migrations.CreateModel(
-            name='Task',
-            fields=[
-                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
-            ],
-        ),
-        migrations.AddField(
-            model_name='project',
-            name='tasks',
-            field=models.ManyToManyField(to='Task'),
-        ),
-    ]
diff --git a/tests/migrations/test_add_many_to_many_field_initial/0002_initial.py b/tests/migrations/test_add_many_to_many_field_initial/0002_initial.py
deleted file mode 100644
index 1bc6c8aafa..0000000000
--- a/tests/migrations/test_add_many_to_many_field_initial/0002_initial.py
+++ /dev/null
@@ -1,18 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    initial = True
-
-    dependencies = [
-        ("migrations", "0001_initial"),
-    ]
-
-    operations = [
-        migrations.AddField(
-            model_name='task',
-            name='projects',
-            field=models.ManyToManyField(to='Project'),
-        ),
-    ]
diff --git a/tests/migrations/test_add_many_to_many_field_initial/__init__.py b/tests/migrations/test_add_many_to_many_field_initial/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_auto_now_add/0001_initial.py b/tests/migrations/test_auto_now_add/0001_initial.py
deleted file mode 100644
index f1bfb44657..0000000000
--- a/tests/migrations/test_auto_now_add/0001_initial.py
+++ /dev/null
@@ -1,16 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    initial = True
-
-    operations = [
-        migrations.CreateModel(
-            name='Entry',
-            fields=[
-                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
-                ('title', models.CharField(max_length=255)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/test_auto_now_add/__init__.py b/tests/migrations/test_auto_now_add/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py
deleted file mode 100644
index ab52b8116d..0000000000
--- a/tests/migrations/test_autodetector.py
+++ /dev/null
@@ -1,2505 +0,0 @@
-import functools
-import re
-from unittest import mock
-
-from django.apps import apps
-from django.conf import settings
-from django.contrib.auth.models import AbstractBaseUser
-from django.core.validators import RegexValidator, validate_slug
-from django.db import connection, migrations, models
-from django.db.migrations.autodetector import MigrationAutodetector
-from django.db.migrations.graph import MigrationGraph
-from django.db.migrations.loader import MigrationLoader
-from django.db.migrations.questioner import MigrationQuestioner
-from django.db.migrations.state import ModelState, ProjectState
-from django.test import SimpleTestCase, TestCase, override_settings
-from django.test.utils import isolate_lru_cache
-
-from .models import FoodManager, FoodQuerySet
-
-
-class DeconstructibleObject:
-    """
-    A custom deconstructible object.
-    """
-
-    def __init__(self, *args, **kwargs):
-        self.args = args
-        self.kwargs = kwargs
-
-    def deconstruct(self):
-        return (
-            self.__module__ + '.' + self.__class__.__name__,
-            self.args,
-            self.kwargs
-        )
-
-
-class AutodetectorTests(TestCase):
-    """
-    Tests the migration autodetector.
-    """
-
-    author_empty = ModelState("testapp", "Author", [("id", models.AutoField(primary_key=True))])
-    author_name = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200)),
-    ])
-    author_name_null = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, null=True)),
-    ])
-    author_name_longer = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=400)),
-    ])
-    author_name_renamed = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("names", models.CharField(max_length=200)),
-    ])
-    author_name_default = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default='Ada Lovelace')),
-    ])
-    author_name_check_constraint = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200)),
-    ],
-        {'constraints': [models.CheckConstraint(check=models.Q(name__contains='Bob'), name='name_contains_bob')]},
-    )
-    author_dates_of_birth_auto_now = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("date_of_birth", models.DateField(auto_now=True)),
-        ("date_time_of_birth", models.DateTimeField(auto_now=True)),
-        ("time_of_birth", models.TimeField(auto_now=True)),
-    ])
-    author_dates_of_birth_auto_now_add = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("date_of_birth", models.DateField(auto_now_add=True)),
-        ("date_time_of_birth", models.DateTimeField(auto_now_add=True)),
-        ("time_of_birth", models.TimeField(auto_now_add=True)),
-    ])
-    author_name_deconstructible_1 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=DeconstructibleObject())),
-    ])
-    author_name_deconstructible_2 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=DeconstructibleObject())),
-    ])
-    author_name_deconstructible_3 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=models.IntegerField())),
-    ])
-    author_name_deconstructible_4 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=models.IntegerField())),
-    ])
-    author_name_deconstructible_list_1 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=[DeconstructibleObject(), 123])),
-    ])
-    author_name_deconstructible_list_2 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=[DeconstructibleObject(), 123])),
-    ])
-    author_name_deconstructible_list_3 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=[DeconstructibleObject(), 999])),
-    ])
-    author_name_deconstructible_tuple_1 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=(DeconstructibleObject(), 123))),
-    ])
-    author_name_deconstructible_tuple_2 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=(DeconstructibleObject(), 123))),
-    ])
-    author_name_deconstructible_tuple_3 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=(DeconstructibleObject(), 999))),
-    ])
-    author_name_deconstructible_dict_1 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default={
-            'item': DeconstructibleObject(), 'otheritem': 123
-        })),
-    ])
-    author_name_deconstructible_dict_2 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default={
-            'item': DeconstructibleObject(), 'otheritem': 123
-        })),
-    ])
-    author_name_deconstructible_dict_3 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default={
-            'item': DeconstructibleObject(), 'otheritem': 999
-        })),
-    ])
-    author_name_nested_deconstructible_1 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=DeconstructibleObject(
-            DeconstructibleObject(1),
-            (DeconstructibleObject('t1'), DeconstructibleObject('t2'),),
-            a=DeconstructibleObject('A'),
-            b=DeconstructibleObject(B=DeconstructibleObject('c')),
-        ))),
-    ])
-    author_name_nested_deconstructible_2 = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=DeconstructibleObject(
-            DeconstructibleObject(1),
-            (DeconstructibleObject('t1'), DeconstructibleObject('t2'),),
-            a=DeconstructibleObject('A'),
-            b=DeconstructibleObject(B=DeconstructibleObject('c')),
-        ))),
-    ])
-    author_name_nested_deconstructible_changed_arg = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=DeconstructibleObject(
-            DeconstructibleObject(1),
-            (DeconstructibleObject('t1'), DeconstructibleObject('t2-changed'),),
-            a=DeconstructibleObject('A'),
-            b=DeconstructibleObject(B=DeconstructibleObject('c')),
-        ))),
-    ])
-    author_name_nested_deconstructible_extra_arg = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=DeconstructibleObject(
-            DeconstructibleObject(1),
-            (DeconstructibleObject('t1'), DeconstructibleObject('t2'),),
-            None,
-            a=DeconstructibleObject('A'),
-            b=DeconstructibleObject(B=DeconstructibleObject('c')),
-        ))),
-    ])
-    author_name_nested_deconstructible_changed_kwarg = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=DeconstructibleObject(
-            DeconstructibleObject(1),
-            (DeconstructibleObject('t1'), DeconstructibleObject('t2'),),
-            a=DeconstructibleObject('A'),
-            b=DeconstructibleObject(B=DeconstructibleObject('c-changed')),
-        ))),
-    ])
-    author_name_nested_deconstructible_extra_kwarg = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200, default=DeconstructibleObject(
-            DeconstructibleObject(1),
-            (DeconstructibleObject('t1'), DeconstructibleObject('t2'),),
-            a=DeconstructibleObject('A'),
-            b=DeconstructibleObject(B=DeconstructibleObject('c')),
-            c=None,
-        ))),
-    ])
-    author_custom_pk = ModelState("testapp", "Author", [("pk_field", models.IntegerField(primary_key=True))])
-    author_with_biography_non_blank = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField()),
-        ("biography", models.TextField()),
-    ])
-    author_with_biography_blank = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(blank=True)),
-        ("biography", models.TextField(blank=True)),
-    ])
-    author_with_book = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200)),
-        ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
-    ])
-    author_with_book_order_wrt = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200)),
-        ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
-    ], options={"order_with_respect_to": "book"})
-    author_renamed_with_book = ModelState("testapp", "Writer", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200)),
-        ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
-    ])
-    author_with_publisher_string = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200)),
-        ("publisher_name", models.CharField(max_length=200)),
-    ])
-    author_with_publisher = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200)),
-        ("publisher", models.ForeignKey("testapp.Publisher", models.CASCADE)),
-    ])
-    author_with_user = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200)),
-        ("user", models.ForeignKey("auth.User", models.CASCADE)),
-    ])
-    author_with_custom_user = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=200)),
-        ("user", models.ForeignKey("thirdapp.CustomUser", models.CASCADE)),
-    ])
-    author_proxy = ModelState("testapp", "AuthorProxy", [], {"proxy": True}, ("testapp.author",))
-    author_proxy_options = ModelState("testapp", "AuthorProxy", [], {
-        "proxy": True,
-        "verbose_name": "Super Author",
-    }, ("testapp.author",))
-    author_proxy_notproxy = ModelState("testapp", "AuthorProxy", [], {}, ("testapp.author",))
-    author_proxy_third = ModelState("thirdapp", "AuthorProxy", [], {"proxy": True}, ("testapp.author",))
-    author_proxy_third_notproxy = ModelState("thirdapp", "AuthorProxy", [], {}, ("testapp.author",))
-    author_proxy_proxy = ModelState("testapp", "AAuthorProxyProxy", [], {"proxy": True}, ("testapp.authorproxy",))
-    author_unmanaged = ModelState("testapp", "AuthorUnmanaged", [], {"managed": False}, ("testapp.author",))
-    author_unmanaged_managed = ModelState("testapp", "AuthorUnmanaged", [], {}, ("testapp.author",))
-    author_unmanaged_default_pk = ModelState("testapp", "Author", [("id", models.AutoField(primary_key=True))])
-    author_unmanaged_custom_pk = ModelState("testapp", "Author", [
-        ("pk_field", models.IntegerField(primary_key=True)),
-    ])
-    author_with_m2m = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("publishers", models.ManyToManyField("testapp.Publisher")),
-    ])
-    author_with_m2m_blank = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("publishers", models.ManyToManyField("testapp.Publisher", blank=True)),
-    ])
-    author_with_m2m_through = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("publishers", models.ManyToManyField("testapp.Publisher", through="testapp.Contract")),
-    ])
-    author_with_renamed_m2m_through = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("publishers", models.ManyToManyField("testapp.Publisher", through="testapp.Deal")),
-    ])
-    author_with_former_m2m = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-        ("publishers", models.CharField(max_length=100)),
-    ])
-    author_with_options = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-    ], {
-        "permissions": [('can_hire', 'Can hire')],
-        "verbose_name": "Authi",
-    })
-    author_with_db_table_options = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-    ], {"db_table": "author_one"})
-    author_with_new_db_table_options = ModelState("testapp", "Author", [
-        ("id", models.AutoField(primary_key=True)),
-    ], {"db_table": "author_two"})
-    author_renamed_with_db_table_options = ModelState("testapp", "NewAuthor", [
-        ("id", models.AutoField(primary_key=True)),
-    ], {"db_table": "author_one"})
-    author_renamed_with_new_db_table_options = ModelState("testapp", "NewAuthor", [
-        ("id", models.AutoField(primary_key=True)),
-    ], {"db_table": "author_three"})
-    contract = ModelState("testapp", "Contract", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("publisher", models.ForeignKey("testapp.Publisher", models.CASCADE)),
-    ])
-    contract_renamed = ModelState("testapp", "Deal", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("publisher", models.ForeignKey("testapp.Publisher", models.CASCADE)),
-    ])
-    publisher = ModelState("testapp", "Publisher", [
-        ("id", models.AutoField(primary_key=True)),
-        ("name", models.CharField(max_length=100)),
-    ])
-    publisher_with_author = ModelState("testapp", "Publisher", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("name", models.CharField(max_length=100)),
-    ])
-    publisher_with_aardvark_author = ModelState("testapp", "Publisher", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Aardvark", models.CASCADE)),
-        ("name", models.CharField(max_length=100)),
-    ])
-    publisher_with_book = ModelState("testapp", "Publisher", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("otherapp.Book", models.CASCADE)),
-        ("name", models.CharField(max_length=100)),
-    ])
-    other_pony = ModelState("otherapp", "Pony", [
-        ("id", models.AutoField(primary_key=True)),
-    ])
-    other_pony_food = ModelState("otherapp", "Pony", [
-        ("id", models.AutoField(primary_key=True)),
-    ], managers=[
-        ('food_qs', FoodQuerySet.as_manager()),
-        ('food_mgr', FoodManager('a', 'b')),
-        ('food_mgr_kwargs', FoodManager('x', 'y', 3, 4)),
-    ])
-    other_stable = ModelState("otherapp", "Stable", [("id", models.AutoField(primary_key=True))])
-    third_thing = ModelState("thirdapp", "Thing", [("id", models.AutoField(primary_key=True))])
-    book = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ])
-    book_proxy_fk = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("thirdapp.AuthorProxy", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ])
-    book_proxy_proxy_fk = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.AAuthorProxyProxy", models.CASCADE)),
-    ])
-    book_migrations_fk = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("migrations.UnmigratedModel", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ])
-    book_with_no_author_fk = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.IntegerField()),
-        ("title", models.CharField(max_length=200)),
-    ])
-    book_with_no_author = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("title", models.CharField(max_length=200)),
-    ])
-    book_with_author_renamed = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Writer", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ])
-    book_with_field_and_author_renamed = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("writer", models.ForeignKey("testapp.Writer", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ])
-    book_with_multiple_authors = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("authors", models.ManyToManyField("testapp.Author")),
-        ("title", models.CharField(max_length=200)),
-    ])
-    book_with_multiple_authors_through_attribution = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("authors", models.ManyToManyField("testapp.Author", through="otherapp.Attribution")),
-        ("title", models.CharField(max_length=200)),
-    ])
-    book_indexes = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ], {
-        "indexes": [models.Index(fields=["author", "title"], name="book_title_author_idx")],
-    })
-    book_unordered_indexes = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ], {
-        "indexes": [models.Index(fields=["title", "author"], name="book_author_title_idx")],
-    })
-    book_foo_together = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ], {
-        "index_together": {("author", "title")},
-        "unique_together": {("author", "title")},
-    })
-    book_foo_together_2 = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ], {
-        "index_together": {("title", "author")},
-        "unique_together": {("title", "author")},
-    })
-    book_foo_together_3 = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("newfield", models.IntegerField()),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ], {
-        "index_together": {("title", "newfield")},
-        "unique_together": {("title", "newfield")},
-    })
-    book_foo_together_4 = ModelState("otherapp", "Book", [
-        ("id", models.AutoField(primary_key=True)),
-        ("newfield2", models.IntegerField()),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("title", models.CharField(max_length=200)),
-    ], {
-        "index_together": {("title", "newfield2")},
-        "unique_together": {("title", "newfield2")},
-    })
-    attribution = ModelState("otherapp", "Attribution", [
-        ("id", models.AutoField(primary_key=True)),
-        ("author", models.ForeignKey("testapp.Author", models.CASCADE)),
-        ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
-    ])
-    edition = ModelState("thirdapp", "Edition", [
-        ("id", models.AutoField(primary_key=True)),
-        ("book", models.ForeignKey("otherapp.Book", models.CASCADE)),
-    ])
-    custom_user = ModelState("thirdapp", "CustomUser", [
-        ("id", models.AutoField(primary_key=True)),
-        ("username", models.CharField(max_length=255)),
-    ], bases=(AbstractBaseUser,))
-    custom_user_no_inherit = ModelState("thirdapp", "CustomUser", [
-        ("id", models.AutoField(primary_key=True)),
-        ("username", models.CharField(max_length=255)),
-    ])
-    aardvark = ModelState("thirdapp", "Aardvark", [("id", models.AutoField(primary_key=True))])
-    aardvark_testapp = ModelState("testapp", "Aardvark", [("id", models.AutoField(primary_key=True))])
-    aardvark_based_on_author = ModelState("testapp", "Aardvark", [], bases=("testapp.Author",))
-    aardvark_pk_fk_author = ModelState("testapp", "Aardvark", [
-        ("id", models.OneToOneField("testapp.Author", models.CASCADE, primary_key=True)),
-    ])
-    knight = ModelState("eggs", "Knight", [("id", models.AutoField(primary_key=True))])
-    rabbit = ModelState("eggs", "Rabbit", [
-        ("id", models.AutoField(primary_key=True)),
-        ("knight", models.ForeignKey("eggs.Knight", models.CASCADE)),
-        ("parent", models.ForeignKey("eggs.Rabbit", models.CASCADE)),
-    ], {
-        "unique_together": {("parent", "knight")},
-        "indexes": [models.Index(fields=["parent", "knight"], name='rabbit_circular_fk_index')],
-    })
-
-    def repr_changes(self, changes, include_dependencies=False):
-        output = ""
-        for app_label, migrations_ in sorted(changes.items()):
-            output += "  %s:\n" % app_label
-            for migration in migrations_:
-                output += "    %s\n" % migration.name
-                for operation in migration.operations:
-                    output += "      %s\n" % operation
-                if include_dependencies:
-                    output += "      Dependencies:\n"
-                    if migration.dependencies:
-                        for dep in migration.dependencies:
-                            output += "        %s\n" % (dep,)
-                    else:
-                        output += "        None\n"
-        return output
-
-    def assertNumberMigrations(self, changes, app_label, number):
-        if len(changes.get(app_label, [])) != number:
-            self.fail("Incorrect number of migrations (%s) for %s (expected %s)\n%s" % (
-                len(changes.get(app_label, [])),
-                app_label,
-                number,
-                self.repr_changes(changes),
-            ))
-
-    def assertMigrationDependencies(self, changes, app_label, position, dependencies):
-        if not changes.get(app_label):
-            self.fail("No migrations found for %s\n%s" % (app_label, self.repr_changes(changes)))
-        if len(changes[app_label]) < position + 1:
-            self.fail("No migration at index %s for %s\n%s" % (position, app_label, self.repr_changes(changes)))
-        migration = changes[app_label][position]
-        if set(migration.dependencies) != set(dependencies):
-            self.fail("Migration dependencies mismatch for %s.%s (expected %s):\n%s" % (
-                app_label,
-                migration.name,
-                dependencies,
-                self.repr_changes(changes, include_dependencies=True),
-            ))
-
-    def assertOperationTypes(self, changes, app_label, position, types):
-        if not changes.get(app_label):
-            self.fail("No migrations found for %s\n%s" % (app_label, self.repr_changes(changes)))
-        if len(changes[app_label]) < position + 1:
-            self.fail("No migration at index %s for %s\n%s" % (position, app_label, self.repr_changes(changes)))
-        migration = changes[app_label][position]
-        real_types = [operation.__class__.__name__ for operation in migration.operations]
-        if types != real_types:
-            self.fail("Operation type mismatch for %s.%s (expected %s):\n%s" % (
-                app_label,
-                migration.name,
-                types,
-                self.repr_changes(changes),
-            ))
-
-    def assertOperationAttributes(self, changes, app_label, position, operation_position, **attrs):
-        if not changes.get(app_label):
-            self.fail("No migrations found for %s\n%s" % (app_label, self.repr_changes(changes)))
-        if len(changes[app_label]) < position + 1:
-            self.fail("No migration at index %s for %s\n%s" % (position, app_label, self.repr_changes(changes)))
-        migration = changes[app_label][position]
-        if len(changes[app_label]) < position + 1:
-            self.fail("No operation at index %s for %s.%s\n%s" % (
-                operation_position,
-                app_label,
-                migration.name,
-                self.repr_changes(changes),
-            ))
-        operation = migration.operations[operation_position]
-        for attr, value in attrs.items():
-            if getattr(operation, attr, None) != value:
-                self.fail("Attribute mismatch for %s.%s op #%s, %s (expected %r, got %r):\n%s" % (
-                    app_label,
-                    migration.name,
-                    operation_position,
-                    attr,
-                    value,
-                    getattr(operation, attr, None),
-                    self.repr_changes(changes),
-                ))
-
-    def assertOperationFieldAttributes(self, changes, app_label, position, operation_position, **attrs):
-        if not changes.get(app_label):
-            self.fail("No migrations found for %s\n%s" % (app_label, self.repr_changes(changes)))
-        if len(changes[app_label]) < position + 1:
-            self.fail("No migration at index %s for %s\n%s" % (position, app_label, self.repr_changes(changes)))
-        migration = changes[app_label][position]
-        if len(changes[app_label]) < position + 1:
-            self.fail("No operation at index %s for %s.%s\n%s" % (
-                operation_position,
-                app_label,
-                migration.name,
-                self.repr_changes(changes),
-            ))
-        operation = migration.operations[operation_position]
-        if not hasattr(operation, 'field'):
-            self.fail("No field attribute for %s.%s op #%s." % (
-                app_label,
-                migration.name,
-                operation_position,
-            ))
-        field = operation.field
-        for attr, value in attrs.items():
-            if getattr(field, attr, None) != value:
-                self.fail("Field attribute mismatch for %s.%s op #%s, field.%s (expected %r, got %r):\n%s" % (
-                    app_label,
-                    migration.name,
-                    operation_position,
-                    attr,
-                    value,
-                    getattr(field, attr, None),
-                    self.repr_changes(changes),
-                ))
-
-    def make_project_state(self, model_states):
-        "Shortcut to make ProjectStates from lists of predefined models"
-        project_state = ProjectState()
-        for model_state in model_states:
-            project_state.add_model(model_state.clone())
-        return project_state
-
-    def get_changes(self, before_states, after_states, questioner=None):
-        return MigrationAutodetector(
-            self.make_project_state(before_states),
-            self.make_project_state(after_states),
-            questioner,
-        )._detect_changes()
-
-    def test_arrange_for_graph(self):
-        """Tests auto-naming of migrations for graph matching."""
-        # Make a fake graph
-        graph = MigrationGraph()
-        graph.add_node(("testapp", "0001_initial"), None)
-        graph.add_node(("testapp", "0002_foobar"), None)
-        graph.add_node(("otherapp", "0001_initial"), None)
-        graph.add_dependency("testapp.0002_foobar", ("testapp", "0002_foobar"), ("testapp", "0001_initial"))
-        graph.add_dependency("testapp.0002_foobar", ("testapp", "0002_foobar"), ("otherapp", "0001_initial"))
-        # Use project state to make a new migration change set
-        before = self.make_project_state([])
-        after = self.make_project_state([self.author_empty, self.other_pony, self.other_stable])
-        autodetector = MigrationAutodetector(before, after)
-        changes = autodetector._detect_changes()
-        # Run through arrange_for_graph
-        changes = autodetector.arrange_for_graph(changes, graph)
-        # Make sure there's a new name, deps match, etc.
-        self.assertEqual(changes["testapp"][0].name, "0003_author")
-        self.assertEqual(changes["testapp"][0].dependencies, [("testapp", "0002_foobar")])
-        self.assertEqual(changes["otherapp"][0].name, "0002_pony_stable")
-        self.assertEqual(changes["otherapp"][0].dependencies, [("otherapp", "0001_initial")])
-
-    def test_trim_apps(self):
-        """
-        Trim does not remove dependencies but does remove unwanted apps.
-        """
-        # Use project state to make a new migration change set
-        before = self.make_project_state([])
-        after = self.make_project_state([self.author_empty, self.other_pony, self.other_stable, self.third_thing])
-        autodetector = MigrationAutodetector(before, after, MigrationQuestioner({"ask_initial": True}))
-        changes = autodetector._detect_changes()
-        # Run through arrange_for_graph
-        graph = MigrationGraph()
-        changes = autodetector.arrange_for_graph(changes, graph)
-        changes["testapp"][0].dependencies.append(("otherapp", "0001_initial"))
-        changes = autodetector._trim_to_apps(changes, {"testapp"})
-        # Make sure there's the right set of migrations
-        self.assertEqual(changes["testapp"][0].name, "0001_initial")
-        self.assertEqual(changes["otherapp"][0].name, "0001_initial")
-        self.assertNotIn("thirdapp", changes)
-
-    def test_custom_migration_name(self):
-        """Tests custom naming of migrations for graph matching."""
-        # Make a fake graph
-        graph = MigrationGraph()
-        graph.add_node(("testapp", "0001_initial"), None)
-        graph.add_node(("testapp", "0002_foobar"), None)
-        graph.add_node(("otherapp", "0001_initial"), None)
-        graph.add_dependency("testapp.0002_foobar", ("testapp", "0002_foobar"), ("testapp", "0001_initial"))
-
-        # Use project state to make a new migration change set
-        before = self.make_project_state([])
-        after = self.make_project_state([self.author_empty, self.other_pony, self.other_stable])
-        autodetector = MigrationAutodetector(before, after)
-        changes = autodetector._detect_changes()
-
-        # Run through arrange_for_graph
-        migration_name = 'custom_name'
-        changes = autodetector.arrange_for_graph(changes, graph, migration_name)
-
-        # Make sure there's a new name, deps match, etc.
-        self.assertEqual(changes["testapp"][0].name, "0003_%s" % migration_name)
-        self.assertEqual(changes["testapp"][0].dependencies, [("testapp", "0002_foobar")])
-        self.assertEqual(changes["otherapp"][0].name, "0002_%s" % migration_name)
-        self.assertEqual(changes["otherapp"][0].dependencies, [("otherapp", "0001_initial")])
-
-    def test_new_model(self):
-        """Tests autodetection of new models."""
-        changes = self.get_changes([], [self.other_pony_food])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, "otherapp", 0, 0, name="Pony")
-        self.assertEqual([name for name, mgr in changes['otherapp'][0].operations[0].managers],
-                         ['food_qs', 'food_mgr', 'food_mgr_kwargs'])
-
-    def test_old_model(self):
-        """Tests deletion of old models."""
-        changes = self.get_changes([self.author_empty], [])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["DeleteModel"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
-
-    def test_add_field(self):
-        """Tests autodetection of new fields."""
-        changes = self.get_changes([self.author_empty], [self.author_name])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AddField"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="name")
-
-    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition',
-                side_effect=AssertionError("Should not have prompted for not null addition"))
-    def test_add_date_fields_with_auto_now_not_asking_for_default(self, mocked_ask_method):
-        changes = self.get_changes([self.author_empty], [self.author_dates_of_birth_auto_now])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AddField", "AddField", "AddField"])
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 0, auto_now=True)
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 1, auto_now=True)
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 2, auto_now=True)
-
-    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition',
-                side_effect=AssertionError("Should not have prompted for not null addition"))
-    def test_add_date_fields_with_auto_now_add_not_asking_for_null_addition(self, mocked_ask_method):
-        changes = self.get_changes([self.author_empty], [self.author_dates_of_birth_auto_now_add])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AddField", "AddField", "AddField"])
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 0, auto_now_add=True)
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 1, auto_now_add=True)
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 2, auto_now_add=True)
-
-    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_auto_now_add_addition')
-    def test_add_date_fields_with_auto_now_add_asking_for_default(self, mocked_ask_method):
-        changes = self.get_changes([self.author_empty], [self.author_dates_of_birth_auto_now_add])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AddField", "AddField", "AddField"])
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 0, auto_now_add=True)
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 1, auto_now_add=True)
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 2, auto_now_add=True)
-        self.assertEqual(mocked_ask_method.call_count, 3)
-
-    def test_remove_field(self):
-        """Tests autodetection of removed fields."""
-        changes = self.get_changes([self.author_name], [self.author_empty])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["RemoveField"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="name")
-
-    def test_alter_field(self):
-        """Tests autodetection of new fields."""
-        changes = self.get_changes([self.author_name], [self.author_name_longer])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterField"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="name", preserve_default=True)
-
-    def test_supports_functools_partial(self):
-        def _content_file_name(instance, filename, key, **kwargs):
-            return '{}/{}'.format(instance, filename)
-
-        def content_file_name(key, **kwargs):
-            return functools.partial(_content_file_name, key, **kwargs)
-
-        # An unchanged partial reference.
-        before = [ModelState("testapp", "Author", [
-            ("id", models.AutoField(primary_key=True)),
-            ("file", models.FileField(max_length=200, upload_to=content_file_name('file'))),
-        ])]
-        after = [ModelState("testapp", "Author", [
-            ("id", models.AutoField(primary_key=True)),
-            ("file", models.FileField(max_length=200, upload_to=content_file_name('file'))),
-        ])]
-        changes = self.get_changes(before, after)
-        self.assertNumberMigrations(changes, 'testapp', 0)
-
-        # A changed partial reference.
-        args_changed = [ModelState("testapp", "Author", [
-            ("id", models.AutoField(primary_key=True)),
-            ("file", models.FileField(max_length=200, upload_to=content_file_name('other-file'))),
-        ])]
-        changes = self.get_changes(before, args_changed)
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ['AlterField'])
-        # Can't use assertOperationFieldAttributes because we need the
-        # deconstructed version, i.e., the exploded func/args/keywords rather
-        # than the partial: we don't care if it's not the same instance of the
-        # partial, only if it's the same source function, args, and keywords.
-        value = changes['testapp'][0].operations[0].field.upload_to
-        self.assertEqual(
-            (_content_file_name, ('other-file',), {}),
-            (value.func, value.args, value.keywords)
-        )
-
-        kwargs_changed = [ModelState("testapp", "Author", [
-            ("id", models.AutoField(primary_key=True)),
-            ("file", models.FileField(max_length=200, upload_to=content_file_name('file', spam='eggs'))),
-        ])]
-        changes = self.get_changes(before, kwargs_changed)
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ['AlterField'])
-        value = changes['testapp'][0].operations[0].field.upload_to
-        self.assertEqual(
-            (_content_file_name, ('file',), {'spam': 'eggs'}),
-            (value.func, value.args, value.keywords)
-        )
-
-    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_alteration',
-                side_effect=AssertionError("Should not have prompted for not null addition"))
-    def test_alter_field_to_not_null_with_default(self, mocked_ask_method):
-        """
-        #23609 - Tests autodetection of nullable to non-nullable alterations.
-        """
-        changes = self.get_changes([self.author_name_null], [self.author_name_default])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterField"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="name", preserve_default=True)
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 0, default='Ada Lovelace')
-
-    @mock.patch(
-        'django.db.migrations.questioner.MigrationQuestioner.ask_not_null_alteration',
-        return_value=models.NOT_PROVIDED,
-    )
-    def test_alter_field_to_not_null_without_default(self, mocked_ask_method):
-        """
-        #23609 - Tests autodetection of nullable to non-nullable alterations.
-        """
-        changes = self.get_changes([self.author_name_null], [self.author_name])
-        self.assertEqual(mocked_ask_method.call_count, 1)
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterField"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="name", preserve_default=True)
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 0, default=models.NOT_PROVIDED)
-
-    @mock.patch(
-        'django.db.migrations.questioner.MigrationQuestioner.ask_not_null_alteration',
-        return_value='Some Name',
-    )
-    def test_alter_field_to_not_null_oneoff_default(self, mocked_ask_method):
-        """
-        #23609 - Tests autodetection of nullable to non-nullable alterations.
-        """
-        changes = self.get_changes([self.author_name_null], [self.author_name])
-        self.assertEqual(mocked_ask_method.call_count, 1)
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterField"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="name", preserve_default=False)
-        self.assertOperationFieldAttributes(changes, "testapp", 0, 0, default="Some Name")
-
-    def test_rename_field(self):
-        """Tests autodetection of renamed fields."""
-        changes = self.get_changes(
-            [self.author_name], [self.author_name_renamed], MigrationQuestioner({"ask_rename": True})
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["RenameField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name="name", new_name="names")
-
-    def test_rename_field_foreign_key_to_field(self):
-        before = [
-            ModelState('app', 'Foo', [
-                ('id', models.AutoField(primary_key=True)),
-                ('field', models.IntegerField(unique=True)),
-            ]),
-            ModelState('app', 'Bar', [
-                ('id', models.AutoField(primary_key=True)),
-                ('foo', models.ForeignKey('app.Foo', models.CASCADE, to_field='field')),
-            ]),
-        ]
-        after = [
-            ModelState('app', 'Foo', [
-                ('id', models.AutoField(primary_key=True)),
-                ('renamed_field', models.IntegerField(unique=True)),
-            ]),
-            ModelState('app', 'Bar', [
-                ('id', models.AutoField(primary_key=True)),
-                ('foo', models.ForeignKey('app.Foo', models.CASCADE, to_field='renamed_field')),
-            ]),
-        ]
-        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'app', 1)
-        self.assertOperationTypes(changes, 'app', 0, ['RenameField'])
-        self.assertOperationAttributes(changes, 'app', 0, 0, old_name='field', new_name='renamed_field')
-
-    def test_rename_foreign_object_fields(self):
-        fields = ('first', 'second')
-        renamed_fields = ('first_renamed', 'second_renamed')
-        before = [
-            ModelState('app', 'Foo', [
-                ('id', models.AutoField(primary_key=True)),
-                ('first', models.IntegerField()),
-                ('second', models.IntegerField()),
-            ], options={'unique_together': {fields}}),
-            ModelState('app', 'Bar', [
-                ('id', models.AutoField(primary_key=True)),
-                ('first', models.IntegerField()),
-                ('second', models.IntegerField()),
-                ('foo', models.ForeignObject(
-                    'app.Foo', models.CASCADE, from_fields=fields, to_fields=fields,
-                )),
-            ]),
-        ]
-        # Case 1: to_fields renames.
-        after = [
-            ModelState('app', 'Foo', [
-                ('id', models.AutoField(primary_key=True)),
-                ('first_renamed', models.IntegerField()),
-                ('second_renamed', models.IntegerField()),
-            ], options={'unique_together': {renamed_fields}}),
-            ModelState('app', 'Bar', [
-                ('id', models.AutoField(primary_key=True)),
-                ('first', models.IntegerField()),
-                ('second', models.IntegerField()),
-                ('foo', models.ForeignObject(
-                    'app.Foo', models.CASCADE, from_fields=fields, to_fields=renamed_fields,
-                )),
-            ]),
-        ]
-        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))
-        self.assertNumberMigrations(changes, 'app', 1)
-        self.assertOperationTypes(changes, 'app', 0, ['RenameField', 'RenameField', 'AlterUniqueTogether'])
-        self.assertOperationAttributes(
-            changes, 'app', 0, 0, model_name='foo', old_name='first', new_name='first_renamed',
-        )
-        self.assertOperationAttributes(
-            changes, 'app', 0, 1, model_name='foo', old_name='second', new_name='second_renamed',
-        )
-        # Case 2: from_fields renames.
-        after = [
-            ModelState('app', 'Foo', [
-                ('id', models.AutoField(primary_key=True)),
-                ('first', models.IntegerField()),
-                ('second', models.IntegerField()),
-            ], options={'unique_together': {fields}}),
-            ModelState('app', 'Bar', [
-                ('id', models.AutoField(primary_key=True)),
-                ('first_renamed', models.IntegerField()),
-                ('second_renamed', models.IntegerField()),
-                ('foo', models.ForeignObject(
-                    'app.Foo', models.CASCADE, from_fields=renamed_fields, to_fields=fields,
-                )),
-            ]),
-        ]
-        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))
-        self.assertNumberMigrations(changes, 'app', 1)
-        self.assertOperationTypes(changes, 'app', 0, ['RenameField', 'RenameField'])
-        self.assertOperationAttributes(
-            changes, 'app', 0, 0, model_name='bar', old_name='first', new_name='first_renamed',
-        )
-        self.assertOperationAttributes(
-            changes, 'app', 0, 1, model_name='bar', old_name='second', new_name='second_renamed',
-        )
-
-    def test_rename_referenced_primary_key(self):
-        before = [
-            ModelState('app', 'Foo', [
-                ('id', models.CharField(primary_key=True, serialize=False)),
-            ]),
-            ModelState('app', 'Bar', [
-                ('id', models.AutoField(primary_key=True)),
-                ('foo', models.ForeignKey('app.Foo', models.CASCADE)),
-            ]),
-        ]
-        after = [
-            ModelState('app', 'Foo', [
-                ('renamed_id', models.CharField(primary_key=True, serialize=False))
-            ]),
-            ModelState('app', 'Bar', [
-                ('id', models.AutoField(primary_key=True)),
-                ('foo', models.ForeignKey('app.Foo', models.CASCADE)),
-            ]),
-        ]
-        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))
-        self.assertNumberMigrations(changes, 'app', 1)
-        self.assertOperationTypes(changes, 'app', 0, ['RenameField'])
-        self.assertOperationAttributes(changes, 'app', 0, 0, old_name='id', new_name='renamed_id')
-
-    def test_rename_field_preserved_db_column(self):
-        """
-        RenameField is used if a field is renamed and db_column equal to the
-        old field's column is added.
-        """
-        before = [
-            ModelState('app', 'Foo', [
-                ('id', models.AutoField(primary_key=True)),
-                ('field', models.IntegerField()),
-            ]),
-        ]
-        after = [
-            ModelState('app', 'Foo', [
-                ('id', models.AutoField(primary_key=True)),
-                ('renamed_field', models.IntegerField(db_column='field')),
-            ]),
-        ]
-        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))
-        self.assertNumberMigrations(changes, 'app', 1)
-        self.assertOperationTypes(changes, 'app', 0, ['RenameField', 'AlterField'])
-        self.assertOperationAttributes(
-            changes, 'app', 0, 0, model_name='foo', old_name='field', new_name='renamed_field',
-        )
-        self.assertOperationAttributes(changes, 'app', 0, 1, model_name='foo', name='renamed_field')
-        self.assertEqual(changes['app'][0].operations[-1].field.deconstruct(), (
-            'renamed_field', 'django.db.models.IntegerField', [], {'db_column': 'field'},
-        ))
-
-    def test_rename_related_field_preserved_db_column(self):
-        before = [
-            ModelState('app', 'Foo', [
-                ('id', models.AutoField(primary_key=True)),
-            ]),
-            ModelState('app', 'Bar', [
-                ('id', models.AutoField(primary_key=True)),
-                ('foo', models.ForeignKey('app.Foo', models.CASCADE)),
-            ]),
-        ]
-        after = [
-            ModelState('app', 'Foo', [
-                ('id', models.AutoField(primary_key=True)),
-            ]),
-            ModelState('app', 'Bar', [
-                ('id', models.AutoField(primary_key=True)),
-                ('renamed_foo', models.ForeignKey('app.Foo', models.CASCADE, db_column='foo_id')),
-            ]),
-        ]
-        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename': True}))
-        self.assertNumberMigrations(changes, 'app', 1)
-        self.assertOperationTypes(changes, 'app', 0, ['RenameField', 'AlterField'])
-        self.assertOperationAttributes(
-            changes, 'app', 0, 0, model_name='bar', old_name='foo', new_name='renamed_foo',
-        )
-        self.assertOperationAttributes(changes, 'app', 0, 1, model_name='bar', name='renamed_foo')
-        self.assertEqual(changes['app'][0].operations[-1].field.deconstruct(), (
-            'renamed_foo',
-            'django.db.models.ForeignKey',
-            [],
-            {'to': 'app.foo', 'on_delete': models.CASCADE, 'db_column': 'foo_id'},
-        ))
-
-    def test_rename_model(self):
-        """Tests autodetection of renamed models."""
-        changes = self.get_changes(
-            [self.author_with_book, self.book],
-            [self.author_renamed_with_book, self.book_with_author_renamed],
-            MigrationQuestioner({"ask_rename_model": True}),
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["RenameModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name="Author", new_name="Writer")
-        # Now that RenameModel handles related fields too, there should be
-        # no AlterField for the related field.
-        self.assertNumberMigrations(changes, 'otherapp', 0)
-
-    def test_rename_model_case(self):
-        """
-        Model name is case-insensitive. Changing case doesn't lead to any
-        autodetected operations.
-        """
-        author_renamed = ModelState('testapp', 'author', [
-            ('id', models.AutoField(primary_key=True)),
-        ])
-        changes = self.get_changes(
-            [self.author_empty, self.book],
-            [author_renamed, self.book],
-            questioner=MigrationQuestioner({'ask_rename_model': True}),
-        )
-        self.assertNumberMigrations(changes, 'testapp', 0)
-        self.assertNumberMigrations(changes, 'otherapp', 0)
-
-    def test_rename_m2m_through_model(self):
-        """
-        Tests autodetection of renamed models that are used in M2M relations as
-        through models.
-        """
-        changes = self.get_changes(
-            [self.author_with_m2m_through, self.publisher, self.contract],
-            [self.author_with_renamed_m2m_through, self.publisher, self.contract_renamed],
-            MigrationQuestioner({'ask_rename_model': True})
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ['RenameModel'])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name='Contract', new_name='Deal')
-
-    def test_rename_model_with_renamed_rel_field(self):
-        """
-        Tests autodetection of renamed models while simultaneously renaming one
-        of the fields that relate to the renamed model.
-        """
-        changes = self.get_changes(
-            [self.author_with_book, self.book],
-            [self.author_renamed_with_book, self.book_with_field_and_author_renamed],
-            MigrationQuestioner({"ask_rename": True, "ask_rename_model": True}),
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["RenameModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name="Author", new_name="Writer")
-        # Right number/type of migrations for related field rename?
-        # Alter is already taken care of.
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ["RenameField"])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, old_name="author", new_name="writer")
-
-    def test_rename_model_with_fks_in_different_position(self):
-        """
-        #24537 - The order of fields in a model does not influence
-        the RenameModel detection.
-        """
-        before = [
-            ModelState("testapp", "EntityA", [
-                ("id", models.AutoField(primary_key=True)),
-            ]),
-            ModelState("testapp", "EntityB", [
-                ("id", models.AutoField(primary_key=True)),
-                ("some_label", models.CharField(max_length=255)),
-                ("entity_a", models.ForeignKey("testapp.EntityA", models.CASCADE)),
-            ]),
-        ]
-        after = [
-            ModelState("testapp", "EntityA", [
-                ("id", models.AutoField(primary_key=True)),
-            ]),
-            ModelState("testapp", "RenamedEntityB", [
-                ("id", models.AutoField(primary_key=True)),
-                ("entity_a", models.ForeignKey("testapp.EntityA", models.CASCADE)),
-                ("some_label", models.CharField(max_length=255)),
-            ]),
-        ]
-        changes = self.get_changes(before, after, MigrationQuestioner({"ask_rename_model": True}))
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["RenameModel"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, old_name="EntityB", new_name="RenamedEntityB")
-
-    def test_rename_model_reverse_relation_dependencies(self):
-        """
-        The migration to rename a model pointed to by a foreign key in another
-        app must run after the other app's migration that adds the foreign key
-        with model's original name. Therefore, the renaming migration has a
-        dependency on that other migration.
-        """
-        before = [
-            ModelState('testapp', 'EntityA', [
-                ('id', models.AutoField(primary_key=True)),
-            ]),
-            ModelState('otherapp', 'EntityB', [
-                ('id', models.AutoField(primary_key=True)),
-                ('entity_a', models.ForeignKey('testapp.EntityA', models.CASCADE)),
-            ]),
-        ]
-        after = [
-            ModelState('testapp', 'RenamedEntityA', [
-                ('id', models.AutoField(primary_key=True)),
-            ]),
-            ModelState('otherapp', 'EntityB', [
-                ('id', models.AutoField(primary_key=True)),
-                ('entity_a', models.ForeignKey('testapp.RenamedEntityA', models.CASCADE)),
-            ]),
-        ]
-        changes = self.get_changes(before, after, MigrationQuestioner({'ask_rename_model': True}))
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertMigrationDependencies(changes, 'testapp', 0, [('otherapp', '__first__')])
-        self.assertOperationTypes(changes, 'testapp', 0, ['RenameModel'])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, old_name='EntityA', new_name='RenamedEntityA')
-
-    def test_fk_dependency(self):
-        """Having a ForeignKey automatically adds a dependency."""
-        # Note that testapp (author) has no dependencies,
-        # otherapp (book) depends on testapp (author),
-        # thirdapp (edition) depends on otherapp (book)
-        changes = self.get_changes([], [self.author_name, self.book, self.edition])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="Author")
-        self.assertMigrationDependencies(changes, 'testapp', 0, [])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name="Book")
-        self.assertMigrationDependencies(changes, 'otherapp', 0, [("testapp", "auto_1")])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'thirdapp', 1)
-        self.assertOperationTypes(changes, 'thirdapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, 'thirdapp', 0, 0, name="Edition")
-        self.assertMigrationDependencies(changes, 'thirdapp', 0, [("otherapp", "auto_1")])
-
-    def test_proxy_fk_dependency(self):
-        """FK dependencies still work on proxy models."""
-        # Note that testapp (author) has no dependencies,
-        # otherapp (book) depends on testapp (authorproxy)
-        changes = self.get_changes([], [self.author_empty, self.author_proxy_third, self.book_proxy_fk])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="Author")
-        self.assertMigrationDependencies(changes, 'testapp', 0, [])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name="Book")
-        self.assertMigrationDependencies(changes, 'otherapp', 0, [("thirdapp", "auto_1")])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'thirdapp', 1)
-        self.assertOperationTypes(changes, 'thirdapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, 'thirdapp', 0, 0, name="AuthorProxy")
-        self.assertMigrationDependencies(changes, 'thirdapp', 0, [("testapp", "auto_1")])
-
-    def test_same_app_no_fk_dependency(self):
-        """
-        A migration with a FK between two models of the same app
-        does not have a dependency to itself.
-        """
-        changes = self.get_changes([], [self.author_with_publisher, self.publisher])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel", "CreateModel"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="Publisher")
-        self.assertOperationAttributes(changes, "testapp", 0, 1, name="Author")
-        self.assertMigrationDependencies(changes, 'testapp', 0, [])
-
-    def test_circular_fk_dependency(self):
-        """
-        Having a circular ForeignKey dependency automatically
-        resolves the situation into 2 migrations on one side and 1 on the other.
-        """
-        changes = self.get_changes([], [self.author_with_book, self.book, self.publisher_with_book])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel", "CreateModel"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="Publisher")
-        self.assertOperationAttributes(changes, "testapp", 0, 1, name="Author")
-        self.assertMigrationDependencies(changes, 'testapp', 0, [("otherapp", "auto_1")])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'otherapp', 2)
-        self.assertOperationTypes(changes, 'otherapp', 0, ["CreateModel"])
-        self.assertOperationTypes(changes, 'otherapp', 1, ["AddField"])
-        self.assertMigrationDependencies(changes, 'otherapp', 0, [])
-        self.assertMigrationDependencies(changes, 'otherapp', 1, [("otherapp", "auto_1"), ("testapp", "auto_1")])
-        # both split migrations should be `initial`
-        self.assertTrue(changes['otherapp'][0].initial)
-        self.assertTrue(changes['otherapp'][1].initial)
-
-    def test_same_app_circular_fk_dependency(self):
-        """
-        A migration with a FK between two models of the same app does
-        not have a dependency to itself.
-        """
-        changes = self.get_changes([], [self.author_with_publisher, self.publisher_with_author])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel", "CreateModel", "AddField"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="Author")
-        self.assertOperationAttributes(changes, "testapp", 0, 1, name="Publisher")
-        self.assertOperationAttributes(changes, "testapp", 0, 2, name="publisher")
-        self.assertMigrationDependencies(changes, 'testapp', 0, [])
-
-    def test_same_app_circular_fk_dependency_with_unique_together_and_indexes(self):
-        """
-        #22275 - A migration with circular FK dependency does not try
-        to create unique together constraint and indexes before creating all
-        required fields first.
-        """
-        changes = self.get_changes([], [self.knight, self.rabbit])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'eggs', 1)
-        self.assertOperationTypes(
-            changes, 'eggs', 0, ["CreateModel", "CreateModel", "AddIndex", "AlterUniqueTogether"]
-        )
-        self.assertNotIn("unique_together", changes['eggs'][0].operations[0].options)
-        self.assertNotIn("unique_together", changes['eggs'][0].operations[1].options)
-        self.assertMigrationDependencies(changes, 'eggs', 0, [])
-
-    def test_alter_db_table_add(self):
-        """Tests detection for adding db_table in model's options."""
-        changes = self.get_changes([self.author_empty], [self.author_with_db_table_options])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterModelTable"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="author", table="author_one")
-
-    def test_alter_db_table_change(self):
-        """Tests detection for changing db_table in model's options'."""
-        changes = self.get_changes([self.author_with_db_table_options], [self.author_with_new_db_table_options])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterModelTable"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="author", table="author_two")
-
-    def test_alter_db_table_remove(self):
-        """Tests detection for removing db_table in model's options."""
-        changes = self.get_changes([self.author_with_db_table_options], [self.author_empty])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterModelTable"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="author", table=None)
-
-    def test_alter_db_table_no_changes(self):
-        """
-        Alter_db_table doesn't generate a migration if no changes have been made.
-        """
-        changes = self.get_changes([self.author_with_db_table_options], [self.author_with_db_table_options])
-        # Right number of migrations?
-        self.assertEqual(len(changes), 0)
-
-    def test_keep_db_table_with_model_change(self):
-        """
-        Tests when model changes but db_table stays as-is, autodetector must not
-        create more than one operation.
-        """
-        changes = self.get_changes(
-            [self.author_with_db_table_options],
-            [self.author_renamed_with_db_table_options],
-            MigrationQuestioner({"ask_rename_model": True}),
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["RenameModel"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, old_name="Author", new_name="NewAuthor")
-
-    def test_alter_db_table_with_model_change(self):
-        """
-        Tests when model and db_table changes, autodetector must create two
-        operations.
-        """
-        changes = self.get_changes(
-            [self.author_with_db_table_options],
-            [self.author_renamed_with_new_db_table_options],
-            MigrationQuestioner({"ask_rename_model": True}),
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["RenameModel", "AlterModelTable"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, old_name="Author", new_name="NewAuthor")
-        self.assertOperationAttributes(changes, "testapp", 0, 1, name="newauthor", table="author_three")
-
-    def test_identical_regex_doesnt_alter(self):
-        from_state = ModelState(
-            "testapp", "model", [("id", models.AutoField(primary_key=True, validators=[
-                RegexValidator(
-                    re.compile('^[-a-zA-Z0-9_]+\\Z'),
-                    'Enter a valid “slug” consisting of letters, numbers, underscores or hyphens.',
-                    'invalid'
-                )
-            ]))]
-        )
-        to_state = ModelState(
-            "testapp", "model", [("id", models.AutoField(primary_key=True, validators=[validate_slug]))]
-        )
-        changes = self.get_changes([from_state], [to_state])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 0)
-
-    def test_different_regex_does_alter(self):
-        from_state = ModelState(
-            "testapp", "model", [("id", models.AutoField(primary_key=True, validators=[
-                RegexValidator(
-                    re.compile('^[a-z]+\\Z', 32),
-                    'Enter a valid “slug” consisting of letters, numbers, underscores or hyphens.',
-                    'invalid'
-                )
-            ]))]
-        )
-        to_state = ModelState(
-            "testapp", "model", [("id", models.AutoField(primary_key=True, validators=[validate_slug]))]
-        )
-        changes = self.get_changes([from_state], [to_state])
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["AlterField"])
-
-    def test_empty_foo_together(self):
-        """
-        #23452 - Empty unique/index_together shouldn't generate a migration.
-        """
-        # Explicitly testing for not specified, since this is the case after
-        # a CreateModel operation w/o any definition on the original model
-        model_state_not_specified = ModelState("a", "model", [("id", models.AutoField(primary_key=True))])
-        # Explicitly testing for None, since this was the issue in #23452 after
-        # an AlterFooTogether operation with e.g. () as value
-        model_state_none = ModelState("a", "model", [
-            ("id", models.AutoField(primary_key=True))
-        ], {
-            "index_together": None,
-            "unique_together": None,
-        })
-        # Explicitly testing for the empty set, since we now always have sets.
-        # During removal (('col1', 'col2'),) --> () this becomes set([])
-        model_state_empty = ModelState("a", "model", [
-            ("id", models.AutoField(primary_key=True))
-        ], {
-            "index_together": set(),
-            "unique_together": set(),
-        })
-
-        def test(from_state, to_state, msg):
-            changes = self.get_changes([from_state], [to_state])
-            if changes:
-                ops = ', '.join(o.__class__.__name__ for o in changes['a'][0].operations)
-                self.fail('Created operation(s) %s from %s' % (ops, msg))
-
-        tests = (
-            (model_state_not_specified, model_state_not_specified, '"not specified" to "not specified"'),
-            (model_state_not_specified, model_state_none, '"not specified" to "None"'),
-            (model_state_not_specified, model_state_empty, '"not specified" to "empty"'),
-            (model_state_none, model_state_not_specified, '"None" to "not specified"'),
-            (model_state_none, model_state_none, '"None" to "None"'),
-            (model_state_none, model_state_empty, '"None" to "empty"'),
-            (model_state_empty, model_state_not_specified, '"empty" to "not specified"'),
-            (model_state_empty, model_state_none, '"empty" to "None"'),
-            (model_state_empty, model_state_empty, '"empty" to "empty"'),
-        )
-
-        for t in tests:
-            test(*t)
-
-    def test_create_model_with_indexes(self):
-        """Test creation of new model with indexes already defined."""
-        author = ModelState('otherapp', 'Author', [
-            ('id', models.AutoField(primary_key=True)),
-            ('name', models.CharField(max_length=200)),
-        ], {'indexes': [models.Index(fields=['name'], name='create_model_with_indexes_idx')]})
-        changes = self.get_changes([], [author])
-        added_index = models.Index(fields=['name'], name='create_model_with_indexes_idx')
-        # Right number of migrations?
-        self.assertEqual(len(changes['otherapp']), 1)
-        # Right number of actions?
-        migration = changes['otherapp'][0]
-        self.assertEqual(len(migration.operations), 2)
-        # Right actions order?
-        self.assertOperationTypes(changes, 'otherapp', 0, ['CreateModel', 'AddIndex'])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name='Author')
-        self.assertOperationAttributes(changes, 'otherapp', 0, 1, model_name='author', index=added_index)
-
-    def test_add_indexes(self):
-        """Test change detection of new indexes."""
-        changes = self.get_changes([self.author_empty, self.book], [self.author_empty, self.book_indexes])
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ['AddIndex'])
-        added_index = models.Index(fields=['author', 'title'], name='book_title_author_idx')
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, model_name='book', index=added_index)
-
-    def test_remove_indexes(self):
-        """Test change detection of removed indexes."""
-        changes = self.get_changes([self.author_empty, self.book_indexes], [self.author_empty, self.book])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ['RemoveIndex'])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, model_name='book', name='book_title_author_idx')
-
-    def test_order_fields_indexes(self):
-        """Test change detection of reordering of fields in indexes."""
-        changes = self.get_changes(
-            [self.author_empty, self.book_indexes], [self.author_empty, self.book_unordered_indexes]
-        )
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ['RemoveIndex', 'AddIndex'])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, model_name='book', name='book_title_author_idx')
-        added_index = models.Index(fields=['title', 'author'], name='book_author_title_idx')
-        self.assertOperationAttributes(changes, 'otherapp', 0, 1, model_name='book', index=added_index)
-
-    def test_create_model_with_check_constraint(self):
-        """Test creation of new model with constraints already defined."""
-        author = ModelState('otherapp', 'Author', [
-            ('id', models.AutoField(primary_key=True)),
-            ('name', models.CharField(max_length=200)),
-        ], {'constraints': [models.CheckConstraint(check=models.Q(name__contains='Bob'), name='name_contains_bob')]})
-        changes = self.get_changes([], [author])
-        added_constraint = models.CheckConstraint(check=models.Q(name__contains='Bob'), name='name_contains_bob')
-        # Right number of migrations?
-        self.assertEqual(len(changes['otherapp']), 1)
-        # Right number of actions?
-        migration = changes['otherapp'][0]
-        self.assertEqual(len(migration.operations), 2)
-        # Right actions order?
-        self.assertOperationTypes(changes, 'otherapp', 0, ['CreateModel', 'AddConstraint'])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name='Author')
-        self.assertOperationAttributes(changes, 'otherapp', 0, 1, model_name='author', constraint=added_constraint)
-
-    def test_add_constraints(self):
-        """Test change detection of new constraints."""
-        changes = self.get_changes([self.author_name], [self.author_name_check_constraint])
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ['AddConstraint'])
-        added_constraint = models.CheckConstraint(check=models.Q(name__contains='Bob'), name='name_contains_bob')
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, model_name='author', constraint=added_constraint)
-
-    def test_remove_constraints(self):
-        """Test change detection of removed constraints."""
-        changes = self.get_changes([self.author_name_check_constraint], [self.author_name])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ['RemoveConstraint'])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, model_name='author', name='name_contains_bob')
-
-    def test_add_foo_together(self):
-        """Tests index/unique_together detection."""
-        changes = self.get_changes([self.author_empty, self.book], [self.author_empty, self.book_foo_together])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "otherapp", 1)
-        self.assertOperationTypes(changes, "otherapp", 0, ["AlterUniqueTogether", "AlterIndexTogether"])
-        self.assertOperationAttributes(changes, "otherapp", 0, 0, name="book", unique_together={("author", "title")})
-        self.assertOperationAttributes(changes, "otherapp", 0, 1, name="book", index_together={("author", "title")})
-
-    def test_remove_foo_together(self):
-        """Tests index/unique_together detection."""
-        changes = self.get_changes([self.author_empty, self.book_foo_together], [self.author_empty, self.book])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "otherapp", 1)
-        self.assertOperationTypes(changes, "otherapp", 0, ["AlterUniqueTogether", "AlterIndexTogether"])
-        self.assertOperationAttributes(changes, "otherapp", 0, 0, name="book", unique_together=set())
-        self.assertOperationAttributes(changes, "otherapp", 0, 1, name="book", index_together=set())
-
-    def test_foo_together_remove_fk(self):
-        """Tests unique_together and field removal detection & ordering"""
-        changes = self.get_changes(
-            [self.author_empty, self.book_foo_together], [self.author_empty, self.book_with_no_author]
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "otherapp", 1)
-        self.assertOperationTypes(changes, "otherapp", 0, [
-            "AlterUniqueTogether", "AlterIndexTogether", "RemoveField"
-        ])
-        self.assertOperationAttributes(changes, "otherapp", 0, 0, name="book", unique_together=set())
-        self.assertOperationAttributes(changes, "otherapp", 0, 1, name="book", index_together=set())
-        self.assertOperationAttributes(changes, "otherapp", 0, 2, model_name="book", name="author")
-
-    def test_foo_together_no_changes(self):
-        """
-        index/unique_together doesn't generate a migration if no
-        changes have been made.
-        """
-        changes = self.get_changes(
-            [self.author_empty, self.book_foo_together], [self.author_empty, self.book_foo_together]
-        )
-        # Right number of migrations?
-        self.assertEqual(len(changes), 0)
-
-    def test_foo_together_ordering(self):
-        """
-        index/unique_together also triggers on ordering changes.
-        """
-        changes = self.get_changes(
-            [self.author_empty, self.book_foo_together], [self.author_empty, self.book_foo_together_2]
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "otherapp", 1)
-        self.assertOperationTypes(changes, "otherapp", 0, ["AlterUniqueTogether", "AlterIndexTogether"])
-        self.assertOperationAttributes(changes, "otherapp", 0, 0, name="book", unique_together={("title", "author")})
-        self.assertOperationAttributes(changes, "otherapp", 0, 1, name="book", index_together={("title", "author")})
-
-    def test_add_field_and_foo_together(self):
-        """
-        Added fields will be created before using them in index/unique_together.
-        """
-        changes = self.get_changes([self.author_empty, self.book], [self.author_empty, self.book_foo_together_3])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "otherapp", 1)
-        self.assertOperationTypes(changes, "otherapp", 0, ["AddField", "AlterUniqueTogether", "AlterIndexTogether"])
-        self.assertOperationAttributes(changes, "otherapp", 0, 1, name="book", unique_together={("title", "newfield")})
-        self.assertOperationAttributes(changes, "otherapp", 0, 2, name="book", index_together={("title", "newfield")})
-
-    def test_create_model_and_unique_together(self):
-        author = ModelState("otherapp", "Author", [
-            ("id", models.AutoField(primary_key=True)),
-            ("name", models.CharField(max_length=200)),
-        ])
-        book_with_author = ModelState("otherapp", "Book", [
-            ("id", models.AutoField(primary_key=True)),
-            ("author", models.ForeignKey("otherapp.Author", models.CASCADE)),
-            ("title", models.CharField(max_length=200)),
-        ], {
-            "index_together": {("title", "author")},
-            "unique_together": {("title", "author")},
-        })
-        changes = self.get_changes([self.book_with_no_author], [author, book_with_author])
-        # Right number of migrations?
-        self.assertEqual(len(changes['otherapp']), 1)
-        # Right number of actions?
-        migration = changes['otherapp'][0]
-        self.assertEqual(len(migration.operations), 4)
-        # Right actions order?
-        self.assertOperationTypes(
-            changes, 'otherapp', 0,
-            ['CreateModel', 'AddField', 'AlterUniqueTogether', 'AlterIndexTogether']
-        )
-
-    def test_remove_field_and_foo_together(self):
-        """
-        Removed fields will be removed after updating index/unique_together.
-        """
-        changes = self.get_changes(
-            [self.author_empty, self.book_foo_together_3], [self.author_empty, self.book_foo_together]
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "otherapp", 1)
-        self.assertOperationTypes(changes, "otherapp", 0, ["AlterUniqueTogether", "AlterIndexTogether", "RemoveField"])
-        self.assertOperationAttributes(changes, "otherapp", 0, 0, name="book", unique_together={("author", "title")})
-        self.assertOperationAttributes(changes, "otherapp", 0, 1, name="book", index_together={("author", "title")})
-        self.assertOperationAttributes(changes, "otherapp", 0, 2, model_name="book", name="newfield")
-
-    def test_rename_field_and_foo_together(self):
-        """
-        Removed fields will be removed after updating index/unique_together.
-        """
-        changes = self.get_changes(
-            [self.author_empty, self.book_foo_together_3],
-            [self.author_empty, self.book_foo_together_4],
-            MigrationQuestioner({"ask_rename": True}),
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "otherapp", 1)
-        self.assertOperationTypes(changes, "otherapp", 0, ["RenameField", "AlterUniqueTogether", "AlterIndexTogether"])
-        self.assertOperationAttributes(changes, "otherapp", 0, 1, name="book", unique_together={
-            ("title", "newfield2")
-        })
-        self.assertOperationAttributes(changes, "otherapp", 0, 2, name="book", index_together={("title", "newfield2")})
-
-    def test_proxy(self):
-        """The autodetector correctly deals with proxy models."""
-        # First, we test adding a proxy model
-        changes = self.get_changes([self.author_empty], [self.author_empty, self.author_proxy])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["CreateModel"])
-        self.assertOperationAttributes(
-            changes, "testapp", 0, 0, name="AuthorProxy", options={"proxy": True, "indexes": [], "constraints": []}
-        )
-        # Now, we test turning a proxy model into a non-proxy model
-        # It should delete the proxy then make the real one
-        changes = self.get_changes(
-            [self.author_empty, self.author_proxy], [self.author_empty, self.author_proxy_notproxy]
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["DeleteModel", "CreateModel"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="AuthorProxy")
-        self.assertOperationAttributes(changes, "testapp", 0, 1, name="AuthorProxy", options={})
-
-    def test_proxy_custom_pk(self):
-        """
-        #23415 - The autodetector must correctly deal with custom FK on proxy
-        models.
-        """
-        # First, we test the default pk field name
-        changes = self.get_changes([], [self.author_empty, self.author_proxy_third, self.book_proxy_fk])
-        # The field name the FK on the book model points to
-        self.assertEqual(changes['otherapp'][0].operations[0].fields[2][1].remote_field.field_name, 'id')
-        # Now, we test the custom pk field name
-        changes = self.get_changes([], [self.author_custom_pk, self.author_proxy_third, self.book_proxy_fk])
-        # The field name the FK on the book model points to
-        self.assertEqual(changes['otherapp'][0].operations[0].fields[2][1].remote_field.field_name, 'pk_field')
-
-    def test_proxy_to_mti_with_fk_to_proxy(self):
-        # First, test the pk table and field name.
-        changes = self.get_changes(
-            [],
-            [self.author_empty, self.author_proxy_third, self.book_proxy_fk],
-        )
-        self.assertEqual(
-            changes['otherapp'][0].operations[0].fields[2][1].remote_field.model._meta.db_table,
-            'testapp_author',
-        )
-        self.assertEqual(changes['otherapp'][0].operations[0].fields[2][1].remote_field.field_name, 'id')
-
-        # Change AuthorProxy to use MTI.
-        changes = self.get_changes(
-            [self.author_empty, self.author_proxy_third, self.book_proxy_fk],
-            [self.author_empty, self.author_proxy_third_notproxy, self.book_proxy_fk],
-        )
-        # Right number/type of migrations for the AuthorProxy model?
-        self.assertNumberMigrations(changes, 'thirdapp', 1)
-        self.assertOperationTypes(changes, 'thirdapp', 0, ['DeleteModel', 'CreateModel'])
-        # Right number/type of migrations for the Book model with a FK to
-        # AuthorProxy?
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ['AlterField'])
-        # otherapp should depend on thirdapp.
-        self.assertMigrationDependencies(changes, 'otherapp', 0, [('thirdapp', 'auto_1')])
-        # Now, test the pk table and field name.
-        self.assertEqual(
-            changes['otherapp'][0].operations[0].field.remote_field.model._meta.db_table,
-            'thirdapp_authorproxy',
-        )
-        self.assertEqual(changes['otherapp'][0].operations[0].field.remote_field.field_name, 'author_ptr')
-
-    def test_proxy_to_mti_with_fk_to_proxy_proxy(self):
-        # First, test the pk table and field name.
-        changes = self.get_changes(
-            [],
-            [self.author_empty, self.author_proxy, self.author_proxy_proxy, self.book_proxy_proxy_fk],
-        )
-        self.assertEqual(
-            changes['otherapp'][0].operations[0].fields[1][1].remote_field.model._meta.db_table,
-            'testapp_author',
-        )
-        self.assertEqual(changes['otherapp'][0].operations[0].fields[1][1].remote_field.field_name, 'id')
-
-        # Change AuthorProxy to use MTI. FK still points to AAuthorProxyProxy,
-        # a proxy of AuthorProxy.
-        changes = self.get_changes(
-            [self.author_empty, self.author_proxy, self.author_proxy_proxy, self.book_proxy_proxy_fk],
-            [self.author_empty, self.author_proxy_notproxy, self.author_proxy_proxy, self.book_proxy_proxy_fk],
-        )
-        # Right number/type of migrations for the AuthorProxy model?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ['DeleteModel', 'CreateModel'])
-        # Right number/type of migrations for the Book model with a FK to
-        # AAuthorProxyProxy?
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ['AlterField'])
-        # otherapp should depend on testapp.
-        self.assertMigrationDependencies(changes, 'otherapp', 0, [('testapp', 'auto_1')])
-        # Now, test the pk table and field name.
-        self.assertEqual(
-            changes['otherapp'][0].operations[0].field.remote_field.model._meta.db_table,
-            'testapp_authorproxy',
-        )
-        self.assertEqual(changes['otherapp'][0].operations[0].field.remote_field.field_name, 'author_ptr')
-
-    def test_unmanaged_create(self):
-        """The autodetector correctly deals with managed models."""
-        # First, we test adding an unmanaged model
-        changes = self.get_changes([self.author_empty], [self.author_empty, self.author_unmanaged])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="AuthorUnmanaged", options={"managed": False})
-
-    def test_unmanaged_delete(self):
-        changes = self.get_changes([self.author_empty, self.author_unmanaged], [self.author_empty])
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ['DeleteModel'])
-
-    def test_unmanaged_to_managed(self):
-        # Now, we test turning an unmanaged model into a managed model
-        changes = self.get_changes(
-            [self.author_empty, self.author_unmanaged], [self.author_empty, self.author_unmanaged_managed]
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterModelOptions"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="authorunmanaged", options={})
-
-    def test_managed_to_unmanaged(self):
-        # Now, we turn managed to unmanaged.
-        changes = self.get_changes(
-            [self.author_empty, self.author_unmanaged_managed], [self.author_empty, self.author_unmanaged]
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["AlterModelOptions"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="authorunmanaged", options={"managed": False})
-
-    def test_unmanaged_custom_pk(self):
-        """
-        #23415 - The autodetector must correctly deal with custom FK on
-        unmanaged models.
-        """
-        # First, we test the default pk field name
-        changes = self.get_changes([], [self.author_unmanaged_default_pk, self.book])
-        # The field name the FK on the book model points to
-        self.assertEqual(changes['otherapp'][0].operations[0].fields[2][1].remote_field.field_name, 'id')
-        # Now, we test the custom pk field name
-        changes = self.get_changes([], [self.author_unmanaged_custom_pk, self.book])
-        # The field name the FK on the book model points to
-        self.assertEqual(changes['otherapp'][0].operations[0].fields[2][1].remote_field.field_name, 'pk_field')
-
-    @override_settings(AUTH_USER_MODEL="thirdapp.CustomUser")
-    def test_swappable(self):
-        with isolate_lru_cache(apps.get_swappable_settings_name):
-            changes = self.get_changes([self.custom_user], [self.custom_user, self.author_with_custom_user])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="Author")
-        self.assertMigrationDependencies(changes, 'testapp', 0, [("__setting__", "AUTH_USER_MODEL")])
-
-    def test_swappable_changed(self):
-        with isolate_lru_cache(apps.get_swappable_settings_name):
-            before = self.make_project_state([self.custom_user, self.author_with_user])
-            with override_settings(AUTH_USER_MODEL="thirdapp.CustomUser"):
-                after = self.make_project_state([self.custom_user, self.author_with_custom_user])
-            autodetector = MigrationAutodetector(before, after)
-            changes = autodetector._detect_changes()
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, model_name="author", name='user')
-        fk_field = changes['testapp'][0].operations[0].field
-        to_model = '%s.%s' % (
-            fk_field.remote_field.model._meta.app_label,
-            fk_field.remote_field.model._meta.object_name,
-        )
-        self.assertEqual(to_model, 'thirdapp.CustomUser')
-
-    def test_add_field_with_default(self):
-        """#22030 - Adding a field with a default should work."""
-        changes = self.get_changes([self.author_empty], [self.author_name_default])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AddField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="name")
-
-    def test_custom_deconstructible(self):
-        """
-        Two instances which deconstruct to the same value aren't considered a
-        change.
-        """
-        changes = self.get_changes([self.author_name_deconstructible_1], [self.author_name_deconstructible_2])
-        # Right number of migrations?
-        self.assertEqual(len(changes), 0)
-
-    def test_deconstruct_field_kwarg(self):
-        """Field instances are handled correctly by nested deconstruction."""
-        changes = self.get_changes([self.author_name_deconstructible_3], [self.author_name_deconstructible_4])
-        self.assertEqual(changes, {})
-
-    def test_deconstructible_list(self):
-        """Nested deconstruction descends into lists."""
-        # When lists contain items that deconstruct to identical values, those lists
-        # should be considered equal for the purpose of detecting state changes
-        # (even if the original items are unequal).
-        changes = self.get_changes(
-            [self.author_name_deconstructible_list_1], [self.author_name_deconstructible_list_2]
-        )
-        self.assertEqual(changes, {})
-        # Legitimate differences within the deconstructed lists should be reported
-        # as a change
-        changes = self.get_changes(
-            [self.author_name_deconstructible_list_1], [self.author_name_deconstructible_list_3]
-        )
-        self.assertEqual(len(changes), 1)
-
-    def test_deconstructible_tuple(self):
-        """Nested deconstruction descends into tuples."""
-        # When tuples contain items that deconstruct to identical values, those tuples
-        # should be considered equal for the purpose of detecting state changes
-        # (even if the original items are unequal).
-        changes = self.get_changes(
-            [self.author_name_deconstructible_tuple_1], [self.author_name_deconstructible_tuple_2]
-        )
-        self.assertEqual(changes, {})
-        # Legitimate differences within the deconstructed tuples should be reported
-        # as a change
-        changes = self.get_changes(
-            [self.author_name_deconstructible_tuple_1], [self.author_name_deconstructible_tuple_3]
-        )
-        self.assertEqual(len(changes), 1)
-
-    def test_deconstructible_dict(self):
-        """Nested deconstruction descends into dict values."""
-        # When dicts contain items whose values deconstruct to identical values,
-        # those dicts should be considered equal for the purpose of detecting
-        # state changes (even if the original values are unequal).
-        changes = self.get_changes(
-            [self.author_name_deconstructible_dict_1], [self.author_name_deconstructible_dict_2]
-        )
-        self.assertEqual(changes, {})
-        # Legitimate differences within the deconstructed dicts should be reported
-        # as a change
-        changes = self.get_changes(
-            [self.author_name_deconstructible_dict_1], [self.author_name_deconstructible_dict_3]
-        )
-        self.assertEqual(len(changes), 1)
-
-    def test_nested_deconstructible_objects(self):
-        """
-        Nested deconstruction is applied recursively to the args/kwargs of
-        deconstructed objects.
-        """
-        # If the items within a deconstructed object's args/kwargs have the same
-        # deconstructed values - whether or not the items themselves are different
-        # instances - then the object as a whole is regarded as unchanged.
-        changes = self.get_changes(
-            [self.author_name_nested_deconstructible_1], [self.author_name_nested_deconstructible_2]
-        )
-        self.assertEqual(changes, {})
-        # Differences that exist solely within the args list of a deconstructed object
-        # should be reported as changes
-        changes = self.get_changes(
-            [self.author_name_nested_deconstructible_1], [self.author_name_nested_deconstructible_changed_arg]
-        )
-        self.assertEqual(len(changes), 1)
-        # Additional args should also be reported as a change
-        changes = self.get_changes(
-            [self.author_name_nested_deconstructible_1], [self.author_name_nested_deconstructible_extra_arg]
-        )
-        self.assertEqual(len(changes), 1)
-        # Differences that exist solely within the kwargs dict of a deconstructed object
-        # should be reported as changes
-        changes = self.get_changes(
-            [self.author_name_nested_deconstructible_1], [self.author_name_nested_deconstructible_changed_kwarg]
-        )
-        self.assertEqual(len(changes), 1)
-        # Additional kwargs should also be reported as a change
-        changes = self.get_changes(
-            [self.author_name_nested_deconstructible_1], [self.author_name_nested_deconstructible_extra_kwarg]
-        )
-        self.assertEqual(len(changes), 1)
-
-    def test_deconstruct_type(self):
-        """
-        #22951 -- Uninstantiated classes with deconstruct are correctly returned
-        by deep_deconstruct during serialization.
-        """
-        author = ModelState(
-            "testapp",
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(
-                    max_length=200,
-                    # IntegerField intentionally not instantiated.
-                    default=models.IntegerField,
-                ))
-            ],
-        )
-        changes = self.get_changes([], [author])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel"])
-
-    def test_replace_string_with_foreignkey(self):
-        """
-        #22300 - Adding an FK in the same "spot" as a deleted CharField should
-        work.
-        """
-        changes = self.get_changes([self.author_with_publisher_string], [self.author_with_publisher, self.publisher])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel", "RemoveField", "AddField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="Publisher")
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, name="publisher_name")
-        self.assertOperationAttributes(changes, 'testapp', 0, 2, name="publisher")
-
-    def test_foreign_key_removed_before_target_model(self):
-        """
-        Removing an FK and the model it targets in the same change must remove
-        the FK field before the model to maintain consistency.
-        """
-        changes = self.get_changes(
-            [self.author_with_publisher, self.publisher], [self.author_name]
-        )  # removes both the model and FK
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["RemoveField", "DeleteModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="publisher")
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, name="Publisher")
-
-    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition',
-                side_effect=AssertionError("Should not have prompted for not null addition"))
-    def test_add_many_to_many(self, mocked_ask_method):
-        """#22435 - Adding a ManyToManyField should not prompt for a default."""
-        changes = self.get_changes([self.author_empty, self.publisher], [self.author_with_m2m, self.publisher])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AddField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="publishers")
-
-    def test_alter_many_to_many(self):
-        changes = self.get_changes(
-            [self.author_with_m2m, self.publisher], [self.author_with_m2m_blank, self.publisher]
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="publishers")
-
-    def test_create_with_through_model(self):
-        """
-        Adding a m2m with a through model and the models that use it should be
-        ordered correctly.
-        """
-        changes = self.get_changes([], [self.author_with_m2m_through, self.publisher, self.contract])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, [
-            'CreateModel', 'CreateModel', 'CreateModel', 'AddField',
-        ])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name='Author')
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, name='Publisher')
-        self.assertOperationAttributes(changes, 'testapp', 0, 2, name='Contract')
-        self.assertOperationAttributes(changes, 'testapp', 0, 3, model_name='author', name='publishers')
-
-    def test_many_to_many_removed_before_through_model(self):
-        """
-        Removing a ManyToManyField and the "through" model in the same change
-        must remove the field before the model to maintain consistency.
-        """
-        changes = self.get_changes(
-            [self.book_with_multiple_authors_through_attribution, self.author_name, self.attribution],
-            [self.book_with_no_author, self.author_name],
-        )
-        # Remove both the through model and ManyToMany
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "otherapp", 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ['RemoveField', 'DeleteModel'])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name='authors', model_name='book')
-        self.assertOperationAttributes(changes, 'otherapp', 0, 1, name='Attribution')
-
-    def test_many_to_many_removed_before_through_model_2(self):
-        """
-        Removing a model that contains a ManyToManyField and the "through" model
-        in the same change must remove the field before the model to maintain
-        consistency.
-        """
-        changes = self.get_changes(
-            [self.book_with_multiple_authors_through_attribution, self.author_name, self.attribution],
-            [self.author_name],
-        )
-        # Remove both the through model and ManyToMany
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "otherapp", 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ['RemoveField', 'DeleteModel', 'DeleteModel'])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name='authors', model_name='book')
-        self.assertOperationAttributes(changes, 'otherapp', 0, 1, name='Attribution')
-        self.assertOperationAttributes(changes, 'otherapp', 0, 2, name='Book')
-
-    def test_m2m_w_through_multistep_remove(self):
-        """
-        A model with a m2m field that specifies a "through" model cannot be
-        removed in the same migration as that through model as the schema will
-        pass through an inconsistent state. The autodetector should produce two
-        migrations to avoid this issue.
-        """
-        changes = self.get_changes([self.author_with_m2m_through, self.publisher, self.contract], [self.publisher])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, [
-            "RemoveField", "RemoveField", "DeleteModel", "DeleteModel"
-        ])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="author", model_name='contract')
-        self.assertOperationAttributes(changes, "testapp", 0, 1, name="publisher", model_name='contract')
-        self.assertOperationAttributes(changes, "testapp", 0, 2, name="Author")
-        self.assertOperationAttributes(changes, "testapp", 0, 3, name="Contract")
-
-    def test_concrete_field_changed_to_many_to_many(self):
-        """
-        #23938 - Changing a concrete field into a ManyToManyField
-        first removes the concrete field and then adds the m2m field.
-        """
-        changes = self.get_changes([self.author_with_former_m2m], [self.author_with_m2m, self.publisher])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["CreateModel", "RemoveField", "AddField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name='Publisher')
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, name="publishers", model_name='author')
-        self.assertOperationAttributes(changes, 'testapp', 0, 2, name="publishers", model_name='author')
-
-    def test_many_to_many_changed_to_concrete_field(self):
-        """
-        #23938 - Changing a ManyToManyField into a concrete field
-        first removes the m2m field and then adds the concrete field.
-        """
-        changes = self.get_changes([self.author_with_m2m, self.publisher], [self.author_with_former_m2m])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["RemoveField", "AddField", "DeleteModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="publishers", model_name='author')
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, name="publishers", model_name='author')
-        self.assertOperationAttributes(changes, 'testapp', 0, 2, name='Publisher')
-        self.assertOperationFieldAttributes(changes, 'testapp', 0, 1, max_length=100)
-
-    def test_non_circular_foreignkey_dependency_removal(self):
-        """
-        If two models with a ForeignKey from one to the other are removed at the
-        same time, the autodetector should remove them in the correct order.
-        """
-        changes = self.get_changes([self.author_with_publisher, self.publisher_with_author], [])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["RemoveField", "DeleteModel", "DeleteModel"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="author", model_name='publisher')
-        self.assertOperationAttributes(changes, "testapp", 0, 1, name="Author")
-        self.assertOperationAttributes(changes, "testapp", 0, 2, name="Publisher")
-
-    def test_alter_model_options(self):
-        """Changing a model's options should make a change."""
-        changes = self.get_changes([self.author_empty], [self.author_with_options])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["AlterModelOptions"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, options={
-            "permissions": [('can_hire', 'Can hire')],
-            "verbose_name": "Authi",
-        })
-
-        # Changing them back to empty should also make a change
-        changes = self.get_changes([self.author_with_options], [self.author_empty])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["AlterModelOptions"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="author", options={})
-
-    def test_alter_model_options_proxy(self):
-        """Changing a proxy model's options should also make a change."""
-        changes = self.get_changes(
-            [self.author_proxy, self.author_empty], [self.author_proxy_options, self.author_empty]
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "testapp", 1)
-        self.assertOperationTypes(changes, "testapp", 0, ["AlterModelOptions"])
-        self.assertOperationAttributes(changes, "testapp", 0, 0, name="authorproxy", options={
-            "verbose_name": "Super Author"
-        })
-
-    def test_set_alter_order_with_respect_to(self):
-        """Setting order_with_respect_to adds a field."""
-        changes = self.get_changes([self.book, self.author_with_book], [self.book, self.author_with_book_order_wrt])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterOrderWithRespectTo"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="author", order_with_respect_to="book")
-
-    def test_add_alter_order_with_respect_to(self):
-        """
-        Setting order_with_respect_to when adding the FK too does
-        things in the right order.
-        """
-        changes = self.get_changes([self.author_name], [self.book, self.author_with_book_order_wrt])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AddField", "AlterOrderWithRespectTo"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, model_name="author", name="book")
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, name="author", order_with_respect_to="book")
-
-    def test_remove_alter_order_with_respect_to(self):
-        """
-        Removing order_with_respect_to when removing the FK too does
-        things in the right order.
-        """
-        changes = self.get_changes([self.book, self.author_with_book_order_wrt], [self.author_name])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AlterOrderWithRespectTo", "RemoveField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="author", order_with_respect_to=None)
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, model_name="author", name="book")
-
-    def test_add_model_order_with_respect_to(self):
-        """
-        Setting order_with_respect_to when adding the whole model
-        does things in the right order.
-        """
-        changes = self.get_changes([], [self.book, self.author_with_book_order_wrt])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(
-            changes, 'testapp', 0, 0, name="Author", options={'order_with_respect_to': 'book'}
-        )
-        self.assertNotIn("_order", [name for name, field in changes['testapp'][0].operations[0].fields])
-
-    def test_alter_model_managers(self):
-        """
-        Changing the model managers adds a new operation.
-        """
-        changes = self.get_changes([self.other_pony], [self.other_pony_food])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ["AlterModelManagers"])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name="pony")
-        self.assertEqual([name for name, mgr in changes['otherapp'][0].operations[0].managers],
-                         ['food_qs', 'food_mgr', 'food_mgr_kwargs'])
-        self.assertEqual(changes['otherapp'][0].operations[0].managers[1][1].args, ('a', 'b', 1, 2))
-        self.assertEqual(changes['otherapp'][0].operations[0].managers[2][1].args, ('x', 'y', 3, 4))
-
-    def test_swappable_first_inheritance(self):
-        """Swappable models get their CreateModel first."""
-        changes = self.get_changes([], [self.custom_user, self.aardvark])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'thirdapp', 1)
-        self.assertOperationTypes(changes, 'thirdapp', 0, ["CreateModel", "CreateModel"])
-        self.assertOperationAttributes(changes, 'thirdapp', 0, 0, name="CustomUser")
-        self.assertOperationAttributes(changes, 'thirdapp', 0, 1, name="Aardvark")
-
-    def test_default_related_name_option(self):
-        model_state = ModelState('app', 'model', [
-            ('id', models.AutoField(primary_key=True)),
-        ], options={'default_related_name': 'related_name'})
-        changes = self.get_changes([], [model_state])
-        self.assertNumberMigrations(changes, 'app', 1)
-        self.assertOperationTypes(changes, 'app', 0, ['CreateModel'])
-        self.assertOperationAttributes(
-            changes, 'app', 0, 0, name='model',
-            options={'default_related_name': 'related_name'},
-        )
-        altered_model_state = ModelState('app', 'Model', [
-            ('id', models.AutoField(primary_key=True)),
-        ])
-        changes = self.get_changes([model_state], [altered_model_state])
-        self.assertNumberMigrations(changes, 'app', 1)
-        self.assertOperationTypes(changes, 'app', 0, ['AlterModelOptions'])
-        self.assertOperationAttributes(changes, 'app', 0, 0, name='model', options={})
-
-    @override_settings(AUTH_USER_MODEL="thirdapp.CustomUser")
-    def test_swappable_first_setting(self):
-        """Swappable models get their CreateModel first."""
-        with isolate_lru_cache(apps.get_swappable_settings_name):
-            changes = self.get_changes([], [self.custom_user_no_inherit, self.aardvark])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'thirdapp', 1)
-        self.assertOperationTypes(changes, 'thirdapp', 0, ["CreateModel", "CreateModel"])
-        self.assertOperationAttributes(changes, 'thirdapp', 0, 0, name="CustomUser")
-        self.assertOperationAttributes(changes, 'thirdapp', 0, 1, name="Aardvark")
-
-    def test_bases_first(self):
-        """Bases of other models come first."""
-        changes = self.get_changes([], [self.aardvark_based_on_author, self.author_name])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel", "CreateModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="Author")
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, name="Aardvark")
-
-    def test_multiple_bases(self):
-        """#23956 - Inheriting models doesn't move *_ptr fields into AddField operations."""
-        A = ModelState("app", "A", [("a_id", models.AutoField(primary_key=True))])
-        B = ModelState("app", "B", [("b_id", models.AutoField(primary_key=True))])
-        C = ModelState("app", "C", [], bases=("app.A", "app.B"))
-        D = ModelState("app", "D", [], bases=("app.A", "app.B"))
-        E = ModelState("app", "E", [], bases=("app.A", "app.B"))
-        changes = self.get_changes([], [A, B, C, D, E])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, "app", 1)
-        self.assertOperationTypes(changes, "app", 0, [
-            "CreateModel", "CreateModel", "CreateModel", "CreateModel", "CreateModel"
-        ])
-        self.assertOperationAttributes(changes, "app", 0, 0, name="A")
-        self.assertOperationAttributes(changes, "app", 0, 1, name="B")
-        self.assertOperationAttributes(changes, "app", 0, 2, name="C")
-        self.assertOperationAttributes(changes, "app", 0, 3, name="D")
-        self.assertOperationAttributes(changes, "app", 0, 4, name="E")
-
-    def test_proxy_bases_first(self):
-        """Bases of proxies come first."""
-        changes = self.get_changes([], [self.author_empty, self.author_proxy, self.author_proxy_proxy])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel", "CreateModel", "CreateModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="Author")
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, name="AuthorProxy")
-        self.assertOperationAttributes(changes, 'testapp', 0, 2, name="AAuthorProxyProxy")
-
-    def test_pk_fk_included(self):
-        """
-        A relation used as the primary key is kept as part of CreateModel.
-        """
-        changes = self.get_changes([], [self.aardvark_pk_fk_author, self.author_name])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel", "CreateModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="Author")
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, name="Aardvark")
-
-    def test_first_dependency(self):
-        """
-        A dependency to an app with no migrations uses __first__.
-        """
-        # Load graph
-        loader = MigrationLoader(connection)
-        before = self.make_project_state([])
-        after = self.make_project_state([self.book_migrations_fk])
-        after.real_apps = ["migrations"]
-        autodetector = MigrationAutodetector(before, after)
-        changes = autodetector._detect_changes(graph=loader.graph)
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name="Book")
-        self.assertMigrationDependencies(changes, 'otherapp', 0, [("migrations", "__first__")])
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
-    def test_last_dependency(self):
-        """
-        A dependency to an app with existing migrations uses the
-        last migration of that app.
-        """
-        # Load graph
-        loader = MigrationLoader(connection)
-        before = self.make_project_state([])
-        after = self.make_project_state([self.book_migrations_fk])
-        after.real_apps = ["migrations"]
-        autodetector = MigrationAutodetector(before, after)
-        changes = autodetector._detect_changes(graph=loader.graph)
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ["CreateModel"])
-        self.assertOperationAttributes(changes, 'otherapp', 0, 0, name="Book")
-        self.assertMigrationDependencies(changes, 'otherapp', 0, [("migrations", "0002_second")])
-
-    def test_alter_fk_before_model_deletion(self):
-        """
-        ForeignKeys are altered _before_ the model they used to
-        refer to are deleted.
-        """
-        changes = self.get_changes(
-            [self.author_name, self.publisher_with_author],
-            [self.aardvark_testapp, self.publisher_with_aardvark_author]
-        )
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["CreateModel", "AlterField", "DeleteModel"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="Aardvark")
-        self.assertOperationAttributes(changes, 'testapp', 0, 1, name="author")
-        self.assertOperationAttributes(changes, 'testapp', 0, 2, name="Author")
-
-    def test_fk_dependency_other_app(self):
-        """
-        #23100 - ForeignKeys correctly depend on other apps' models.
-        """
-        changes = self.get_changes([self.author_name, self.book], [self.author_with_book, self.book])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AddField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0, name="book")
-        self.assertMigrationDependencies(changes, 'testapp', 0, [("otherapp", "__first__")])
-
-    def test_alter_field_to_fk_dependency_other_app(self):
-        changes = self.get_changes(
-            [self.author_empty, self.book_with_no_author_fk],
-            [self.author_empty, self.book],
-        )
-        self.assertNumberMigrations(changes, 'otherapp', 1)
-        self.assertOperationTypes(changes, 'otherapp', 0, ['AlterField'])
-        self.assertMigrationDependencies(changes, 'otherapp', 0, [('testapp', '__first__')])
-
-    def test_circular_dependency_mixed_addcreate(self):
-        """
-        #23315 - The dependency resolver knows to put all CreateModel
-        before AddField and not become unsolvable.
-        """
-        address = ModelState("a", "Address", [
-            ("id", models.AutoField(primary_key=True)),
-            ("country", models.ForeignKey("b.DeliveryCountry", models.CASCADE)),
-        ])
-        person = ModelState("a", "Person", [
-            ("id", models.AutoField(primary_key=True)),
-        ])
-        apackage = ModelState("b", "APackage", [
-            ("id", models.AutoField(primary_key=True)),
-            ("person", models.ForeignKey("a.Person", models.CASCADE)),
-        ])
-        country = ModelState("b", "DeliveryCountry", [
-            ("id", models.AutoField(primary_key=True)),
-        ])
-        changes = self.get_changes([], [address, person, apackage, country])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'a', 2)
-        self.assertNumberMigrations(changes, 'b', 1)
-        self.assertOperationTypes(changes, 'a', 0, ["CreateModel", "CreateModel"])
-        self.assertOperationTypes(changes, 'a', 1, ["AddField"])
-        self.assertOperationTypes(changes, 'b', 0, ["CreateModel", "CreateModel"])
-
-    @override_settings(AUTH_USER_MODEL="a.Tenant")
-    def test_circular_dependency_swappable(self):
-        """
-        #23322 - The dependency resolver knows to explicitly resolve
-        swappable models.
-        """
-        with isolate_lru_cache(apps.get_swappable_settings_name):
-            tenant = ModelState("a", "Tenant", [
-                ("id", models.AutoField(primary_key=True)),
-                ("primary_address", models.ForeignKey("b.Address", models.CASCADE))],
-                bases=(AbstractBaseUser,)
-            )
-            address = ModelState("b", "Address", [
-                ("id", models.AutoField(primary_key=True)),
-                ("tenant", models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE)),
-            ])
-            changes = self.get_changes([], [address, tenant])
-
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'a', 2)
-        self.assertOperationTypes(changes, 'a', 0, ["CreateModel"])
-        self.assertOperationTypes(changes, 'a', 1, ["AddField"])
-        self.assertMigrationDependencies(changes, 'a', 0, [])
-        self.assertMigrationDependencies(changes, 'a', 1, [('a', 'auto_1'), ('b', 'auto_1')])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'b', 1)
-        self.assertOperationTypes(changes, 'b', 0, ["CreateModel"])
-        self.assertMigrationDependencies(changes, 'b', 0, [('__setting__', 'AUTH_USER_MODEL')])
-
-    @override_settings(AUTH_USER_MODEL="b.Tenant")
-    def test_circular_dependency_swappable2(self):
-        """
-        #23322 - The dependency resolver knows to explicitly resolve
-        swappable models but with the swappable not being the first migrated
-        model.
-        """
-        with isolate_lru_cache(apps.get_swappable_settings_name):
-            address = ModelState("a", "Address", [
-                ("id", models.AutoField(primary_key=True)),
-                ("tenant", models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE)),
-            ])
-            tenant = ModelState("b", "Tenant", [
-                ("id", models.AutoField(primary_key=True)),
-                ("primary_address", models.ForeignKey("a.Address", models.CASCADE))],
-                bases=(AbstractBaseUser,)
-            )
-            changes = self.get_changes([], [address, tenant])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'a', 2)
-        self.assertOperationTypes(changes, 'a', 0, ["CreateModel"])
-        self.assertOperationTypes(changes, 'a', 1, ["AddField"])
-        self.assertMigrationDependencies(changes, 'a', 0, [])
-        self.assertMigrationDependencies(changes, 'a', 1, [('__setting__', 'AUTH_USER_MODEL'), ('a', 'auto_1')])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'b', 1)
-        self.assertOperationTypes(changes, 'b', 0, ["CreateModel"])
-        self.assertMigrationDependencies(changes, 'b', 0, [('a', 'auto_1')])
-
-    @override_settings(AUTH_USER_MODEL="a.Person")
-    def test_circular_dependency_swappable_self(self):
-        """
-        #23322 - The dependency resolver knows to explicitly resolve
-        swappable models.
-        """
-        with isolate_lru_cache(apps.get_swappable_settings_name):
-            person = ModelState("a", "Person", [
-                ("id", models.AutoField(primary_key=True)),
-                ("parent1", models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE, related_name='children'))
-            ])
-            changes = self.get_changes([], [person])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'a', 1)
-        self.assertOperationTypes(changes, 'a', 0, ["CreateModel"])
-        self.assertMigrationDependencies(changes, 'a', 0, [])
-
-    @override_settings(AUTH_USER_MODEL='a.User')
-    def test_swappable_circular_multi_mti(self):
-        with isolate_lru_cache(apps.get_swappable_settings_name):
-            parent = ModelState('a', 'Parent', [
-                ('user', models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE))
-            ])
-            child = ModelState('a', 'Child', [], bases=('a.Parent',))
-            user = ModelState('a', 'User', [], bases=(AbstractBaseUser, 'a.Child'))
-            changes = self.get_changes([], [parent, child, user])
-        self.assertNumberMigrations(changes, 'a', 1)
-        self.assertOperationTypes(changes, 'a', 0, ['CreateModel', 'CreateModel', 'CreateModel', 'AddField'])
-
-    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition',
-                side_effect=AssertionError("Should not have prompted for not null addition"))
-    def test_add_blank_textfield_and_charfield(self, mocked_ask_method):
-        """
-        #23405 - Adding a NOT NULL and blank `CharField` or `TextField`
-        without default should not prompt for a default.
-        """
-        changes = self.get_changes([self.author_empty], [self.author_with_biography_blank])
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AddField", "AddField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0)
-
-    @mock.patch('django.db.migrations.questioner.MigrationQuestioner.ask_not_null_addition')
-    def test_add_non_blank_textfield_and_charfield(self, mocked_ask_method):
-        """
-        #23405 - Adding a NOT NULL and non-blank `CharField` or `TextField`
-        without default should prompt for a default.
-        """
-        changes = self.get_changes([self.author_empty], [self.author_with_biography_non_blank])
-        self.assertEqual(mocked_ask_method.call_count, 2)
-        # Right number/type of migrations?
-        self.assertNumberMigrations(changes, 'testapp', 1)
-        self.assertOperationTypes(changes, 'testapp', 0, ["AddField", "AddField"])
-        self.assertOperationAttributes(changes, 'testapp', 0, 0)
-
-    def test_mti_inheritance_model_removal(self):
-        Animal = ModelState('app', 'Animal', [
-            ("id", models.AutoField(primary_key=True)),
-        ])
-        Dog = ModelState('app', 'Dog', [], bases=('app.Animal',))
-        changes = self.get_changes([Animal, Dog], [Animal])
-        self.assertNumberMigrations(changes, 'app', 1)
-        self.assertOperationTypes(changes, 'app', 0, ['DeleteModel'])
-        self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')
-
-    def test_add_model_with_field_removed_from_base_model(self):
-        """
-        Removing a base field takes place before adding a new inherited model
-        that has a field with the same name.
-        """
-        before = [
-            ModelState('app', 'readable', [
-                ('id', models.AutoField(primary_key=True)),
-                ('title', models.CharField(max_length=200)),
-            ]),
-        ]
-        after = [
-            ModelState('app', 'readable', [
-                ('id', models.AutoField(primary_key=True)),
-            ]),
-            ModelState('app', 'book', [
-                ('title', models.CharField(max_length=200)),
-            ], bases=('app.readable',)),
-        ]
-        changes = self.get_changes(before, after)
-        self.assertNumberMigrations(changes, 'app', 1)
-        self.assertOperationTypes(changes, 'app', 0, ['RemoveField', 'CreateModel'])
-        self.assertOperationAttributes(changes, 'app', 0, 0, name='title', model_name='readable')
-        self.assertOperationAttributes(changes, 'app', 0, 1, name='book')
-
-
-class AutodetectorSuggestNameTests(SimpleTestCase):
-    def test_single_operation(self):
-        ops = [migrations.CreateModel('Person', fields=[])]
-        self.assertEqual(MigrationAutodetector.suggest_name(ops), 'person')
-        ops = [migrations.DeleteModel('Person')]
-        self.assertEqual(MigrationAutodetector.suggest_name(ops), 'delete_person')
-
-    def test_two_create_models(self):
-        ops = [
-            migrations.CreateModel('Person', fields=[]),
-            migrations.CreateModel('Animal', fields=[]),
-        ]
-        self.assertEqual(MigrationAutodetector.suggest_name(ops), 'animal_person')
-
-    def test_none_name(self):
-        ops = [migrations.RunSQL('SELECT 1 FROM person;')]
-        suggest_name = MigrationAutodetector.suggest_name(ops)
-        self.assertIs(suggest_name.startswith('auto_'), True)
-
-    def test_auto(self):
-        suggest_name = MigrationAutodetector.suggest_name([])
-        self.assertIs(suggest_name.startswith('auto_'), True)
diff --git a/tests/migrations/test_base.py b/tests/migrations/test_base.py
deleted file mode 100644
index 28a57f552d..0000000000
--- a/tests/migrations/test_base.py
+++ /dev/null
@@ -1,291 +0,0 @@
-import os
-import shutil
-import tempfile
-from contextlib import contextmanager
-from importlib import import_module
-
-from django.apps import apps
-from django.db import connection, connections, migrations, models
-from django.db.migrations.migration import Migration
-from django.db.migrations.recorder import MigrationRecorder
-from django.db.migrations.state import ProjectState
-from django.test import TransactionTestCase
-from django.test.utils import extend_sys_path
-from django.utils.module_loading import module_dir
-
-
-class MigrationTestBase(TransactionTestCase):
-    """
-    Contains an extended set of asserts for testing migrations and schema operations.
-    """
-
-    available_apps = ["migrations"]
-    databases = {'default', 'other'}
-
-    def tearDown(self):
-        # Reset applied-migrations state.
-        for db in self.databases:
-            recorder = MigrationRecorder(connections[db])
-            recorder.migration_qs.filter(app='migrations').delete()
-
-    def get_table_description(self, table, using='default'):
-        with connections[using].cursor() as cursor:
-            return connections[using].introspection.get_table_description(cursor, table)
-
-    def assertTableExists(self, table, using='default'):
-        with connections[using].cursor() as cursor:
-            self.assertIn(table, connections[using].introspection.table_names(cursor))
-
-    def assertTableNotExists(self, table, using='default'):
-        with connections[using].cursor() as cursor:
-            self.assertNotIn(table, connections[using].introspection.table_names(cursor))
-
-    def assertColumnExists(self, table, column, using='default'):
-        self.assertIn(column, [c.name for c in self.get_table_description(table, using=using)])
-
-    def assertColumnNotExists(self, table, column, using='default'):
-        self.assertNotIn(column, [c.name for c in self.get_table_description(table, using=using)])
-
-    def _get_column_allows_null(self, table, column, using):
-        return [c.null_ok for c in self.get_table_description(table, using=using) if c.name == column][0]
-
-    def assertColumnNull(self, table, column, using='default'):
-        self.assertTrue(self._get_column_allows_null(table, column, using))
-
-    def assertColumnNotNull(self, table, column, using='default'):
-        self.assertFalse(self._get_column_allows_null(table, column, using))
-
-    def assertIndexExists(self, table, columns, value=True, using='default', index_type=None):
-        with connections[using].cursor() as cursor:
-            self.assertEqual(
-                value,
-                any(
-                    c["index"]
-                    for c in connections[using].introspection.get_constraints(cursor, table).values()
-                    if (
-                        c['columns'] == list(columns) and
-                        (index_type is None or c['type'] == index_type) and
-                        not c['unique']
-                    )
-                ),
-            )
-
-    def assertIndexNotExists(self, table, columns):
-        return self.assertIndexExists(table, columns, False)
-
-    def assertConstraintExists(self, table, name, value=True, using='default'):
-        with connections[using].cursor() as cursor:
-            constraints = connections[using].introspection.get_constraints(cursor, table).items()
-            self.assertEqual(
-                value,
-                any(c['check'] for n, c in constraints if n == name),
-            )
-
-    def assertConstraintNotExists(self, table, name):
-        return self.assertConstraintExists(table, name, False)
-
-    def assertUniqueConstraintExists(self, table, columns, value=True, using='default'):
-        with connections[using].cursor() as cursor:
-            constraints = connections[using].introspection.get_constraints(cursor, table).values()
-            self.assertEqual(
-                value,
-                any(c['unique'] for c in constraints if c['columns'] == list(columns)),
-            )
-
-    def assertFKExists(self, table, columns, to, value=True, using='default'):
-        with connections[using].cursor() as cursor:
-            self.assertEqual(
-                value,
-                any(
-                    c["foreign_key"] == to
-                    for c in connections[using].introspection.get_constraints(cursor, table).values()
-                    if c['columns'] == list(columns)
-                ),
-            )
-
-    def assertFKNotExists(self, table, columns, to):
-        return self.assertFKExists(table, columns, to, False)
-
-    @contextmanager
-    def temporary_migration_module(self, app_label='migrations', module=None):
-        """
-        Allows testing management commands in a temporary migrations module.
-
-        Wrap all invocations to makemigrations and squashmigrations with this
-        context manager in order to avoid creating migration files in your
-        source tree inadvertently.
-
-        Takes the application label that will be passed to makemigrations or
-        squashmigrations and the Python path to a migrations module.
-
-        The migrations module is used as a template for creating the temporary
-        migrations module. If it isn't provided, the application's migrations
-        module is used, if it exists.
-
-        Returns the filesystem path to the temporary migrations module.
-        """
-        with tempfile.TemporaryDirectory() as temp_dir:
-            target_dir = tempfile.mkdtemp(dir=temp_dir)
-            with open(os.path.join(target_dir, '__init__.py'), 'w'):
-                pass
-            target_migrations_dir = os.path.join(target_dir, 'migrations')
-
-            if module is None:
-                module = apps.get_app_config(app_label).name + '.migrations'
-
-            try:
-                source_migrations_dir = module_dir(import_module(module))
-            except (ImportError, ValueError):
-                pass
-            else:
-                shutil.copytree(source_migrations_dir, target_migrations_dir)
-
-            with extend_sys_path(temp_dir):
-                new_module = os.path.basename(target_dir) + '.migrations'
-                with self.settings(MIGRATION_MODULES={app_label: new_module}):
-                    yield target_migrations_dir
-
-
-class OperationTestBase(MigrationTestBase):
-    """Common functions to help test operations."""
-
-    @classmethod
-    def setUpClass(cls):
-        super().setUpClass()
-        cls._initial_table_names = frozenset(connection.introspection.table_names())
-
-    def tearDown(self):
-        self.cleanup_test_tables()
-        super().tearDown()
-
-    def cleanup_test_tables(self):
-        table_names = frozenset(connection.introspection.table_names()) - self._initial_table_names
-        with connection.schema_editor() as editor:
-            with connection.constraint_checks_disabled():
-                for table_name in table_names:
-                    editor.execute(editor.sql_delete_table % {
-                        'table': editor.quote_name(table_name),
-                    })
-
-    def apply_operations(self, app_label, project_state, operations, atomic=True):
-        migration = Migration('name', app_label)
-        migration.operations = operations
-        with connection.schema_editor(atomic=atomic) as editor:
-            return migration.apply(project_state, editor)
-
-    def unapply_operations(self, app_label, project_state, operations, atomic=True):
-        migration = Migration('name', app_label)
-        migration.operations = operations
-        with connection.schema_editor(atomic=atomic) as editor:
-            return migration.unapply(project_state, editor)
-
-    def make_test_state(self, app_label, operation, **kwargs):
-        """
-        Makes a test state using set_up_test_model and returns the
-        original state and the state after the migration is applied.
-        """
-        project_state = self.set_up_test_model(app_label, **kwargs)
-        new_state = project_state.clone()
-        operation.state_forwards(app_label, new_state)
-        return project_state, new_state
-
-    def set_up_test_model(
-        self, app_label, second_model=False, third_model=False, index=False,
-        multicol_index=False, related_model=False, mti_model=False,
-        proxy_model=False, manager_model=False, unique_together=False,
-        options=False, db_table=None, index_together=False, constraints=None,
-    ):
-        """Creates a test model state and database table."""
-        # Make the "current" state.
-        model_options = {
-            'swappable': 'TEST_SWAP_MODEL',
-            'index_together': [['weight', 'pink']] if index_together else [],
-            'unique_together': [['pink', 'weight']] if unique_together else [],
-        }
-        if options:
-            model_options['permissions'] = [('can_groom', 'Can groom')]
-        if db_table:
-            model_options['db_table'] = db_table
-        operations = [migrations.CreateModel(
-            'Pony',
-            [
-                ('id', models.AutoField(primary_key=True)),
-                ('pink', models.IntegerField(default=3)),
-                ('weight', models.FloatField()),
-            ],
-            options=model_options,
-        )]
-        if index:
-            operations.append(migrations.AddIndex(
-                'Pony',
-                models.Index(fields=['pink'], name='pony_pink_idx'),
-            ))
-        if multicol_index:
-            operations.append(migrations.AddIndex(
-                'Pony',
-                models.Index(fields=['pink', 'weight'], name='pony_test_idx'),
-            ))
-        if constraints:
-            for constraint in constraints:
-                operations.append(migrations.AddConstraint('Pony', constraint))
-        if second_model:
-            operations.append(migrations.CreateModel(
-                'Stable',
-                [
-                    ('id', models.AutoField(primary_key=True)),
-                ]
-            ))
-        if third_model:
-            operations.append(migrations.CreateModel(
-                'Van',
-                [
-                    ('id', models.AutoField(primary_key=True)),
-                ]
-            ))
-        if related_model:
-            operations.append(migrations.CreateModel(
-                'Rider',
-                [
-                    ('id', models.AutoField(primary_key=True)),
-                    ('pony', models.ForeignKey('Pony', models.CASCADE)),
-                    ('friend', models.ForeignKey('self', models.CASCADE))
-                ],
-            ))
-        if mti_model:
-            operations.append(migrations.CreateModel(
-                'ShetlandPony',
-                fields=[
-                    ('pony_ptr', models.OneToOneField(
-                        'Pony',
-                        models.CASCADE,
-                        auto_created=True,
-                        parent_link=True,
-                        primary_key=True,
-                        to_field='id',
-                        serialize=False,
-                    )),
-                    ('cuteness', models.IntegerField(default=1)),
-                ],
-                bases=['%s.Pony' % app_label],
-            ))
-        if proxy_model:
-            operations.append(migrations.CreateModel(
-                'ProxyPony',
-                fields=[],
-                options={'proxy': True},
-                bases=['%s.Pony' % app_label],
-            ))
-        if manager_model:
-            from .models import FoodManager, FoodQuerySet
-            operations.append(migrations.CreateModel(
-                'Food',
-                fields=[
-                    ('id', models.AutoField(primary_key=True)),
-                ],
-                managers=[
-                    ('food_qs', FoodQuerySet.as_manager()),
-                    ('food_mgr', FoodManager('a', 'b')),
-                    ('food_mgr_kwargs', FoodManager('x', 'y', 3, 4)),
-                ]
-            ))
-        return self.apply_operations(app_label, ProjectState(), operations)
diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py
deleted file mode 100644
index 50f3ea8965..0000000000
--- a/tests/migrations/test_commands.py
+++ /dev/null
@@ -1,1767 +0,0 @@
-import datetime
-import importlib
-import io
-import os
-import sys
-from unittest import mock
-
-from django.apps import apps
-from django.core.management import CommandError, call_command
-from django.db import (
-    ConnectionHandler, DatabaseError, OperationalError, connection,
-    connections, models,
-)
-from django.db.backends.base.schema import BaseDatabaseSchemaEditor
-from django.db.backends.utils import truncate_name
-from django.db.migrations.exceptions import InconsistentMigrationHistory
-from django.db.migrations.recorder import MigrationRecorder
-from django.test import TestCase, override_settings, skipUnlessDBFeature
-
-from .models import UnicodeModel, UnserializableModel
-from .routers import TestRouter
-from .test_base import MigrationTestBase
-
-
-class MigrateTests(MigrationTestBase):
-    """
-    Tests running the migrate command.
-    """
-    databases = {'default', 'other'}
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
-    def test_migrate(self):
-        """
-        Tests basic usage of the migrate command.
-        """
-        # No tables are created
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-        self.assertTableNotExists("migrations_book")
-        # Run the migrations to 0001 only
-        stdout = io.StringIO()
-        call_command('migrate', 'migrations', '0001', verbosity=1, stdout=stdout, no_color=True)
-        stdout = stdout.getvalue()
-        self.assertIn('Target specific migration: 0001_initial, from migrations', stdout)
-        self.assertIn('Applying migrations.0001_initial... OK', stdout)
-        # The correct tables exist
-        self.assertTableExists("migrations_author")
-        self.assertTableExists("migrations_tribble")
-        self.assertTableNotExists("migrations_book")
-        # Run migrations all the way
-        call_command("migrate", verbosity=0)
-        # The correct tables exist
-        self.assertTableExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-        self.assertTableExists("migrations_book")
-        # Unmigrate everything
-        stdout = io.StringIO()
-        call_command('migrate', 'migrations', 'zero', verbosity=1, stdout=stdout, no_color=True)
-        stdout = stdout.getvalue()
-        self.assertIn('Unapply all migrations: migrations', stdout)
-        self.assertIn('Unapplying migrations.0002_second... OK', stdout)
-        # Tables are gone
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-        self.assertTableNotExists("migrations_book")
-
-    @override_settings(INSTALLED_APPS=[
-        'django.contrib.auth',
-        'django.contrib.contenttypes',
-        'migrations.migrations_test_apps.migrated_app',
-    ])
-    def test_migrate_with_system_checks(self):
-        out = io.StringIO()
-        call_command('migrate', skip_checks=False, no_color=True, stdout=out)
-        self.assertIn('Apply all migrations: migrated_app', out.getvalue())
-
-    @override_settings(INSTALLED_APPS=['migrations', 'migrations.migrations_test_apps.unmigrated_app_syncdb'])
-    def test_app_without_migrations(self):
-        msg = "App 'unmigrated_app_syncdb' does not have migrations."
-        with self.assertRaisesMessage(CommandError, msg):
-            call_command('migrate', app_label='unmigrated_app_syncdb')
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_clashing_prefix'})
-    def test_ambiguous_prefix(self):
-        msg = (
-            "More than one migration matches 'a' in app 'migrations'. Please "
-            "be more specific."
-        )
-        with self.assertRaisesMessage(CommandError, msg):
-            call_command('migrate', app_label='migrations', migration_name='a')
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations'})
-    def test_unknown_prefix(self):
-        msg = "Cannot find a migration matching 'nonexistent' from app 'migrations'."
-        with self.assertRaisesMessage(CommandError, msg):
-            call_command('migrate', app_label='migrations', migration_name='nonexistent')
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_initial_false"})
-    def test_migrate_initial_false(self):
-        """
-        `Migration.initial = False` skips fake-initial detection.
-        """
-        # Make sure no tables are created
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-        # Run the migrations to 0001 only
-        call_command("migrate", "migrations", "0001", verbosity=0)
-        # Fake rollback
-        call_command("migrate", "migrations", "zero", fake=True, verbosity=0)
-        # Make sure fake-initial detection does not run
-        with self.assertRaises(DatabaseError):
-            call_command("migrate", "migrations", "0001", fake_initial=True, verbosity=0)
-
-        call_command("migrate", "migrations", "0001", fake=True, verbosity=0)
-        # Real rollback
-        call_command("migrate", "migrations", "zero", verbosity=0)
-        # Make sure it's all gone
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-        self.assertTableNotExists("migrations_book")
-
-    @override_settings(
-        MIGRATION_MODULES={"migrations": "migrations.test_migrations"},
-        DATABASE_ROUTERS=['migrations.routers.TestRouter'],
-    )
-    def test_migrate_fake_initial(self):
-        """
-        --fake-initial only works if all tables created in the initial
-        migration of an app exists. Database routers must be obeyed when doing
-        that check.
-        """
-        # Make sure no tables are created
-        for db in self.databases:
-            self.assertTableNotExists("migrations_author", using=db)
-            self.assertTableNotExists("migrations_tribble", using=db)
-        # Run the migrations to 0001 only
-        call_command("migrate", "migrations", "0001", verbosity=0)
-        call_command("migrate", "migrations", "0001", verbosity=0, database="other")
-        # Make sure the right tables exist
-        self.assertTableExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-        # Also check the "other" database
-        self.assertTableNotExists("migrations_author", using="other")
-        self.assertTableExists("migrations_tribble", using="other")
-
-        # Fake a roll-back
-        call_command("migrate", "migrations", "zero", fake=True, verbosity=0)
-        call_command("migrate", "migrations", "zero", fake=True, verbosity=0, database="other")
-        # Make sure the tables still exist
-        self.assertTableExists("migrations_author")
-        self.assertTableExists("migrations_tribble", using="other")
-        # Try to run initial migration
-        with self.assertRaises(DatabaseError):
-            call_command("migrate", "migrations", "0001", verbosity=0)
-        # Run initial migration with an explicit --fake-initial
-        out = io.StringIO()
-        with mock.patch('django.core.management.color.supports_color', lambda *args: False):
-            call_command("migrate", "migrations", "0001", fake_initial=True, stdout=out, verbosity=1)
-            call_command("migrate", "migrations", "0001", fake_initial=True, verbosity=0, database="other")
-        self.assertIn(
-            "migrations.0001_initial... faked",
-            out.getvalue().lower()
-        )
-        try:
-            # Run migrations all the way.
-            call_command('migrate', verbosity=0)
-            call_command('migrate', verbosity=0, database="other")
-            self.assertTableExists('migrations_author')
-            self.assertTableNotExists('migrations_tribble')
-            self.assertTableExists('migrations_book')
-            self.assertTableNotExists('migrations_author', using='other')
-            self.assertTableNotExists('migrations_tribble', using='other')
-            self.assertTableNotExists('migrations_book', using='other')
-            # Fake a roll-back.
-            call_command('migrate', 'migrations', 'zero', fake=True, verbosity=0)
-            call_command('migrate', 'migrations', 'zero', fake=True, verbosity=0, database='other')
-            self.assertTableExists('migrations_author')
-            self.assertTableNotExists('migrations_tribble')
-            self.assertTableExists('migrations_book')
-            # Run initial migration.
-            with self.assertRaises(DatabaseError):
-                call_command('migrate', 'migrations', verbosity=0)
-            # Run initial migration with an explicit --fake-initial.
-            with self.assertRaises(DatabaseError):
-                # Fails because "migrations_tribble" does not exist but needs
-                # to in order to make --fake-initial work.
-                call_command('migrate', 'migrations', fake_initial=True, verbosity=0)
-            # Fake an apply.
-            call_command('migrate', 'migrations', fake=True, verbosity=0)
-            call_command('migrate', 'migrations', fake=True, verbosity=0, database='other')
-        finally:
-            # Unmigrate everything.
-            call_command('migrate', 'migrations', 'zero', verbosity=0)
-            call_command('migrate', 'migrations', 'zero', verbosity=0, database='other')
-        # Make sure it's all gone
-        for db in self.databases:
-            self.assertTableNotExists("migrations_author", using=db)
-            self.assertTableNotExists("migrations_tribble", using=db)
-            self.assertTableNotExists("migrations_book", using=db)
-
-    @skipUnlessDBFeature('ignores_table_name_case')
-    def test_migrate_fake_initial_case_insensitive(self):
-        with override_settings(MIGRATION_MODULES={
-            'migrations': 'migrations.test_fake_initial_case_insensitive.initial',
-        }):
-            call_command('migrate', 'migrations', '0001', verbosity=0)
-            call_command('migrate', 'migrations', 'zero', fake=True, verbosity=0)
-
-        with override_settings(MIGRATION_MODULES={
-            'migrations': 'migrations.test_fake_initial_case_insensitive.fake_initial',
-        }):
-            out = io.StringIO()
-            call_command(
-                'migrate',
-                'migrations',
-                '0001',
-                fake_initial=True,
-                stdout=out,
-                verbosity=1,
-                no_color=True,
-            )
-            self.assertIn(
-                'migrations.0001_initial... faked',
-                out.getvalue().lower(),
-            )
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_fake_split_initial"})
-    def test_migrate_fake_split_initial(self):
-        """
-        Split initial migrations can be faked with --fake-initial.
-        """
-        call_command("migrate", "migrations", "0002", verbosity=0)
-        call_command("migrate", "migrations", "zero", fake=True, verbosity=0)
-        out = io.StringIO()
-        with mock.patch('django.core.management.color.supports_color', lambda *args: False):
-            call_command("migrate", "migrations", "0002", fake_initial=True, stdout=out, verbosity=1)
-        value = out.getvalue().lower()
-        self.assertIn("migrations.0001_initial... faked", value)
-        self.assertIn("migrations.0002_second... faked", value)
-        # Fake an apply
-        call_command("migrate", "migrations", fake=True, verbosity=0)
-        # Unmigrate everything
-        call_command("migrate", "migrations", "zero", verbosity=0)
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_conflict"})
-    def test_migrate_conflict_exit(self):
-        """
-        migrate exits if it detects a conflict.
-        """
-        with self.assertRaisesMessage(CommandError, "Conflicting migrations detected"):
-            call_command("migrate", "migrations")
-
-    @override_settings(MIGRATION_MODULES={
-        'migrations': 'migrations.test_migrations',
-    })
-    def test_migrate_check(self):
-        with self.assertRaises(SystemExit):
-            call_command('migrate', 'migrations', '0001', check_unapplied=True)
-        self.assertTableNotExists('migrations_author')
-        self.assertTableNotExists('migrations_tribble')
-        self.assertTableNotExists('migrations_book')
-
-    @override_settings(MIGRATION_MODULES={
-        'migrations': 'migrations.test_migrations_plan',
-    })
-    def test_migrate_check_plan(self):
-        out = io.StringIO()
-        with self.assertRaises(SystemExit):
-            call_command(
-                'migrate',
-                'migrations',
-                '0001',
-                check_unapplied=True,
-                plan=True,
-                stdout=out,
-                no_color=True,
-            )
-        self.assertEqual(
-            'Planned operations:\n'
-            'migrations.0001_initial\n'
-            '    Create model Salamander\n'
-            '    Raw Python operation -> Grow salamander tail.\n',
-            out.getvalue(),
-        )
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
-    def test_showmigrations_list(self):
-        """
-        showmigrations --list  displays migrations and whether or not they're
-        applied.
-        """
-        out = io.StringIO()
-        with mock.patch('django.core.management.color.supports_color', lambda *args: True):
-            call_command("showmigrations", format='list', stdout=out, verbosity=0, no_color=False)
-        self.assertEqual(
-            '\x1b[1mmigrations\n\x1b[0m'
-            ' [ ] 0001_initial\n'
-            ' [ ] 0002_second\n',
-            out.getvalue().lower()
-        )
-
-        call_command("migrate", "migrations", "0001", verbosity=0)
-
-        out = io.StringIO()
-        # Giving the explicit app_label tests for selective `show_list` in the command
-        call_command("showmigrations", "migrations", format='list', stdout=out, verbosity=0, no_color=True)
-        self.assertEqual(
-            'migrations\n'
-            ' [x] 0001_initial\n'
-            ' [ ] 0002_second\n',
-            out.getvalue().lower()
-        )
-        out = io.StringIO()
-        # Applied datetimes are displayed at verbosity 2+.
-        call_command('showmigrations', 'migrations', stdout=out, verbosity=2, no_color=True)
-        migration1 = MigrationRecorder(connection).migration_qs.get(app='migrations', name='0001_initial')
-        self.assertEqual(
-            'migrations\n'
-            ' [x] 0001_initial (applied at %s)\n'
-            ' [ ] 0002_second\n' % migration1.applied.strftime('%Y-%m-%d %H:%M:%S'),
-            out.getvalue().lower()
-        )
-        # Cleanup by unmigrating everything
-        call_command("migrate", "migrations", "zero", verbosity=0)
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_run_before"})
-    def test_showmigrations_plan(self):
-        """
-        Tests --plan output of showmigrations command
-        """
-        out = io.StringIO()
-        call_command("showmigrations", format='plan', stdout=out)
-        self.assertEqual(
-            "[ ]  migrations.0001_initial\n"
-            "[ ]  migrations.0003_third\n"
-            "[ ]  migrations.0002_second\n",
-            out.getvalue().lower()
-        )
-
-        out = io.StringIO()
-        call_command("showmigrations", format='plan', stdout=out, verbosity=2)
-        self.assertEqual(
-            "[ ]  migrations.0001_initial\n"
-            "[ ]  migrations.0003_third ... (migrations.0001_initial)\n"
-            "[ ]  migrations.0002_second ... (migrations.0001_initial, migrations.0003_third)\n",
-            out.getvalue().lower()
-        )
-        call_command("migrate", "migrations", "0003", verbosity=0)
-
-        out = io.StringIO()
-        call_command("showmigrations", format='plan', stdout=out)
-        self.assertEqual(
-            "[x]  migrations.0001_initial\n"
-            "[x]  migrations.0003_third\n"
-            "[ ]  migrations.0002_second\n",
-            out.getvalue().lower()
-        )
-
-        out = io.StringIO()
-        call_command("showmigrations", format='plan', stdout=out, verbosity=2)
-        self.assertEqual(
-            "[x]  migrations.0001_initial\n"
-            "[x]  migrations.0003_third ... (migrations.0001_initial)\n"
-            "[ ]  migrations.0002_second ... (migrations.0001_initial, migrations.0003_third)\n",
-            out.getvalue().lower()
-        )
-
-        # Cleanup by unmigrating everything
-        call_command("migrate", "migrations", "zero", verbosity=0)
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_plan'})
-    def test_migrate_plan(self):
-        """Tests migrate --plan output."""
-        out = io.StringIO()
-        # Show the plan up to the third migration.
-        call_command('migrate', 'migrations', '0003', plan=True, stdout=out, no_color=True)
-        self.assertEqual(
-            'Planned operations:\n'
-            'migrations.0001_initial\n'
-            '    Create model Salamander\n'
-            '    Raw Python operation -> Grow salamander tail.\n'
-            'migrations.0002_second\n'
-            '    Create model Book\n'
-            "    Raw SQL operation -> ['SELECT * FROM migrations_book']\n"
-            'migrations.0003_third\n'
-            '    Create model Author\n'
-            "    Raw SQL operation -> ['SELECT * FROM migrations_author']\n",
-            out.getvalue()
-        )
-        try:
-            # Migrate to the third migration.
-            call_command('migrate', 'migrations', '0003', verbosity=0)
-            out = io.StringIO()
-            # Show the plan for when there is nothing to apply.
-            call_command('migrate', 'migrations', '0003', plan=True, stdout=out, no_color=True)
-            self.assertEqual(
-                'Planned operations:\n'
-                '  No planned migration operations.\n',
-                out.getvalue()
-            )
-            out = io.StringIO()
-            # Show the plan for reverse migration back to 0001.
-            call_command('migrate', 'migrations', '0001', plan=True, stdout=out, no_color=True)
-            self.assertEqual(
-                'Planned operations:\n'
-                'migrations.0003_third\n'
-                '    Undo Create model Author\n'
-                "    Raw SQL operation -> ['SELECT * FROM migrations_book']\n"
-                'migrations.0002_second\n'
-                '    Undo Create model Book\n'
-                "    Raw SQL operation -> ['SELECT * FROM migrations_salamand…\n",
-                out.getvalue()
-            )
-            out = io.StringIO()
-            # Show the migration plan to fourth, with truncated details.
-            call_command('migrate', 'migrations', '0004', plan=True, stdout=out, no_color=True)
-            self.assertEqual(
-                'Planned operations:\n'
-                'migrations.0004_fourth\n'
-                '    Raw SQL operation -> SELECT * FROM migrations_author WHE…\n',
-                out.getvalue()
-            )
-            # Show the plan when an operation is irreversible.
-            # Migrate to the fourth migration.
-            call_command('migrate', 'migrations', '0004', verbosity=0)
-            out = io.StringIO()
-            call_command('migrate', 'migrations', '0003', plan=True, stdout=out, no_color=True)
-            self.assertEqual(
-                'Planned operations:\n'
-                'migrations.0004_fourth\n'
-                '    Raw SQL operation -> IRREVERSIBLE\n',
-                out.getvalue()
-            )
-            out = io.StringIO()
-            call_command('migrate', 'migrations', '0005', plan=True, stdout=out, no_color=True)
-            # Operation is marked as irreversible only in the revert plan.
-            self.assertEqual(
-                'Planned operations:\n'
-                'migrations.0005_fifth\n'
-                '    Raw Python operation\n'
-                '    Raw Python operation\n'
-                '    Raw Python operation -> Feed salamander.\n',
-                out.getvalue()
-            )
-            call_command('migrate', 'migrations', '0005', verbosity=0)
-            out = io.StringIO()
-            call_command('migrate', 'migrations', '0004', plan=True, stdout=out, no_color=True)
-            self.assertEqual(
-                'Planned operations:\n'
-                'migrations.0005_fifth\n'
-                '    Raw Python operation -> IRREVERSIBLE\n'
-                '    Raw Python operation -> IRREVERSIBLE\n'
-                '    Raw Python operation\n',
-                out.getvalue()
-            )
-        finally:
-            # Cleanup by unmigrating everything: fake the irreversible, then
-            # migrate all to zero.
-            call_command('migrate', 'migrations', '0003', fake=True, verbosity=0)
-            call_command('migrate', 'migrations', 'zero', verbosity=0)
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_empty'})
-    def test_showmigrations_no_migrations(self):
-        out = io.StringIO()
-        call_command('showmigrations', stdout=out, no_color=True)
-        self.assertEqual('migrations\n (no migrations)\n', out.getvalue().lower())
-
-    @override_settings(INSTALLED_APPS=['migrations.migrations_test_apps.unmigrated_app'])
-    def test_showmigrations_unmigrated_app(self):
-        out = io.StringIO()
-        call_command('showmigrations', 'unmigrated_app', stdout=out, no_color=True)
-        self.assertEqual('unmigrated_app\n (no migrations)\n', out.getvalue().lower())
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_empty"})
-    def test_showmigrations_plan_no_migrations(self):
-        """
-        Tests --plan output of showmigrations command without migrations
-        """
-        out = io.StringIO()
-        call_command('showmigrations', format='plan', stdout=out, no_color=True)
-        self.assertEqual('(no migrations)\n', out.getvalue().lower())
-
-        out = io.StringIO()
-        call_command('showmigrations', format='plan', stdout=out, verbosity=2, no_color=True)
-        self.assertEqual('(no migrations)\n', out.getvalue().lower())
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed_complex"})
-    def test_showmigrations_plan_squashed(self):
-        """
-        Tests --plan output of showmigrations command with squashed migrations.
-        """
-        out = io.StringIO()
-        call_command("showmigrations", format='plan', stdout=out)
-        self.assertEqual(
-            "[ ]  migrations.1_auto\n"
-            "[ ]  migrations.2_auto\n"
-            "[ ]  migrations.3_squashed_5\n"
-            "[ ]  migrations.6_auto\n"
-            "[ ]  migrations.7_auto\n",
-            out.getvalue().lower()
-        )
-
-        out = io.StringIO()
-        call_command("showmigrations", format='plan', stdout=out, verbosity=2)
-        self.assertEqual(
-            "[ ]  migrations.1_auto\n"
-            "[ ]  migrations.2_auto ... (migrations.1_auto)\n"
-            "[ ]  migrations.3_squashed_5 ... (migrations.2_auto)\n"
-            "[ ]  migrations.6_auto ... (migrations.3_squashed_5)\n"
-            "[ ]  migrations.7_auto ... (migrations.6_auto)\n",
-            out.getvalue().lower()
-        )
-
-        call_command("migrate", "migrations", "3_squashed_5", verbosity=0)
-
-        out = io.StringIO()
-        call_command("showmigrations", format='plan', stdout=out)
-        self.assertEqual(
-            "[x]  migrations.1_auto\n"
-            "[x]  migrations.2_auto\n"
-            "[x]  migrations.3_squashed_5\n"
-            "[ ]  migrations.6_auto\n"
-            "[ ]  migrations.7_auto\n",
-            out.getvalue().lower()
-        )
-
-        out = io.StringIO()
-        call_command("showmigrations", format='plan', stdout=out, verbosity=2)
-        self.assertEqual(
-            "[x]  migrations.1_auto\n"
-            "[x]  migrations.2_auto ... (migrations.1_auto)\n"
-            "[x]  migrations.3_squashed_5 ... (migrations.2_auto)\n"
-            "[ ]  migrations.6_auto ... (migrations.3_squashed_5)\n"
-            "[ ]  migrations.7_auto ... (migrations.6_auto)\n",
-            out.getvalue().lower()
-        )
-
-    @override_settings(INSTALLED_APPS=[
-        'migrations.migrations_test_apps.mutate_state_b',
-        'migrations.migrations_test_apps.alter_fk.author_app',
-        'migrations.migrations_test_apps.alter_fk.book_app',
-    ])
-    def test_showmigrations_plan_single_app_label(self):
-        """
-        `showmigrations --plan app_label` output with a single app_label.
-        """
-        # Single app with no dependencies on other apps.
-        out = io.StringIO()
-        call_command('showmigrations', 'mutate_state_b', format='plan', stdout=out)
-        self.assertEqual(
-            '[ ]  mutate_state_b.0001_initial\n'
-            '[ ]  mutate_state_b.0002_add_field\n',
-            out.getvalue()
-        )
-        # Single app with dependencies.
-        out = io.StringIO()
-        call_command('showmigrations', 'author_app', format='plan', stdout=out)
-        self.assertEqual(
-            '[ ]  author_app.0001_initial\n'
-            '[ ]  book_app.0001_initial\n'
-            '[ ]  author_app.0002_alter_id\n',
-            out.getvalue()
-        )
-        # Some migrations already applied.
-        call_command('migrate', 'author_app', '0001', verbosity=0)
-        out = io.StringIO()
-        call_command('showmigrations', 'author_app', format='plan', stdout=out)
-        self.assertEqual(
-            '[X]  author_app.0001_initial\n'
-            '[ ]  book_app.0001_initial\n'
-            '[ ]  author_app.0002_alter_id\n',
-            out.getvalue()
-        )
-        # Cleanup by unmigrating author_app.
-        call_command('migrate', 'author_app', 'zero', verbosity=0)
-
-    @override_settings(INSTALLED_APPS=[
-        'migrations.migrations_test_apps.mutate_state_b',
-        'migrations.migrations_test_apps.alter_fk.author_app',
-        'migrations.migrations_test_apps.alter_fk.book_app',
-    ])
-    def test_showmigrations_plan_multiple_app_labels(self):
-        """
-        `showmigrations --plan app_label` output with multiple app_labels.
-        """
-        # Multiple apps: author_app depends on book_app; mutate_state_b doesn't
-        # depend on other apps.
-        out = io.StringIO()
-        call_command('showmigrations', 'mutate_state_b', 'author_app', format='plan', stdout=out)
-        self.assertEqual(
-            '[ ]  author_app.0001_initial\n'
-            '[ ]  book_app.0001_initial\n'
-            '[ ]  author_app.0002_alter_id\n'
-            '[ ]  mutate_state_b.0001_initial\n'
-            '[ ]  mutate_state_b.0002_add_field\n',
-            out.getvalue()
-        )
-        # Multiple apps: args order shouldn't matter (the same result is
-        # expected as above).
-        out = io.StringIO()
-        call_command('showmigrations', 'author_app', 'mutate_state_b', format='plan', stdout=out)
-        self.assertEqual(
-            '[ ]  author_app.0001_initial\n'
-            '[ ]  book_app.0001_initial\n'
-            '[ ]  author_app.0002_alter_id\n'
-            '[ ]  mutate_state_b.0001_initial\n'
-            '[ ]  mutate_state_b.0002_add_field\n',
-            out.getvalue()
-        )
-
-    @override_settings(INSTALLED_APPS=['migrations.migrations_test_apps.unmigrated_app'])
-    def test_showmigrations_plan_app_label_no_migrations(self):
-        out = io.StringIO()
-        call_command('showmigrations', 'unmigrated_app', format='plan', stdout=out, no_color=True)
-        self.assertEqual('(no migrations)\n', out.getvalue())
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
-    def test_sqlmigrate_forwards(self):
-        """
-        sqlmigrate outputs forward looking SQL.
-        """
-        out = io.StringIO()
-        call_command("sqlmigrate", "migrations", "0001", stdout=out)
-        output = out.getvalue().lower()
-
-        index_tx_start = output.find(connection.ops.start_transaction_sql().lower())
-        index_op_desc_author = output.find('-- create model author')
-        index_create_table = output.find('create table')
-        index_op_desc_tribble = output.find('-- create model tribble')
-        index_op_desc_unique_together = output.find('-- alter unique_together')
-        index_tx_end = output.find(connection.ops.end_transaction_sql().lower())
-
-        if connection.features.can_rollback_ddl:
-            self.assertGreater(index_tx_start, -1, "Transaction start not found")
-            self.assertGreater(
-                index_tx_end, index_op_desc_unique_together,
-                "Transaction end not found or found before operation description (unique_together)"
-            )
-
-        self.assertGreater(
-            index_op_desc_author, index_tx_start,
-            "Operation description (author) not found or found before transaction start"
-        )
-        self.assertGreater(
-            index_create_table, index_op_desc_author,
-            "CREATE TABLE not found or found before operation description (author)"
-        )
-        self.assertGreater(
-            index_op_desc_tribble, index_create_table,
-            "Operation description (tribble) not found or found before CREATE TABLE (author)"
-        )
-        self.assertGreater(
-            index_op_desc_unique_together, index_op_desc_tribble,
-            "Operation description (unique_together) not found or found before operation description (tribble)"
-        )
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
-    def test_sqlmigrate_backwards(self):
-        """
-        sqlmigrate outputs reverse looking SQL.
-        """
-        # Cannot generate the reverse SQL unless we've applied the migration.
-        call_command("migrate", "migrations", verbosity=0)
-
-        out = io.StringIO()
-        call_command("sqlmigrate", "migrations", "0001", stdout=out, backwards=True)
-        output = out.getvalue().lower()
-
-        index_tx_start = output.find(connection.ops.start_transaction_sql().lower())
-        index_op_desc_unique_together = output.find('-- alter unique_together')
-        index_op_desc_tribble = output.find('-- create model tribble')
-        index_op_desc_author = output.find('-- create model author')
-        index_drop_table = output.rfind('drop table')
-        index_tx_end = output.find(connection.ops.end_transaction_sql().lower())
-
-        if connection.features.can_rollback_ddl:
-            self.assertGreater(index_tx_start, -1, "Transaction start not found")
-            self.assertGreater(
-                index_tx_end, index_op_desc_unique_together,
-                "Transaction end not found or found before DROP TABLE"
-            )
-        self.assertGreater(
-            index_op_desc_unique_together, index_tx_start,
-            "Operation description (unique_together) not found or found before transaction start"
-        )
-        self.assertGreater(
-            index_op_desc_tribble, index_op_desc_unique_together,
-            "Operation description (tribble) not found or found before operation description (unique_together)"
-        )
-        self.assertGreater(
-            index_op_desc_author, index_op_desc_tribble,
-            "Operation description (author) not found or found before operation description (tribble)"
-        )
-
-        self.assertGreater(
-            index_drop_table, index_op_desc_author,
-            "DROP TABLE not found or found before operation description (author)"
-        )
-
-        # Cleanup by unmigrating everything
-        call_command("migrate", "migrations", "zero", verbosity=0)
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_non_atomic"})
-    def test_sqlmigrate_for_non_atomic_migration(self):
-        """
-        Transaction wrappers aren't shown for non-atomic migrations.
-        """
-        out = io.StringIO()
-        call_command("sqlmigrate", "migrations", "0001", stdout=out)
-        output = out.getvalue().lower()
-        queries = [q.strip() for q in output.splitlines()]
-        if connection.ops.start_transaction_sql():
-            self.assertNotIn(connection.ops.start_transaction_sql().lower(), queries)
-        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations'})
-    def test_sqlmigrate_for_non_transactional_databases(self):
-        """
-        Transaction wrappers aren't shown for databases that don't support
-        transactional DDL.
-        """
-        out = io.StringIO()
-        with mock.patch.object(connection.features, 'can_rollback_ddl', False):
-            call_command('sqlmigrate', 'migrations', '0001', stdout=out)
-        output = out.getvalue().lower()
-        queries = [q.strip() for q in output.splitlines()]
-        start_transaction_sql = connection.ops.start_transaction_sql()
-        if start_transaction_sql:
-            self.assertNotIn(start_transaction_sql.lower(), queries)
-        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed'})
-    def test_sqlmigrate_ambiguous_prefix_squashed_migrations(self):
-        msg = (
-            "More than one migration matches '0001' in app 'migrations'. "
-            "Please be more specific."
-        )
-        with self.assertRaisesMessage(CommandError, msg):
-            call_command('sqlmigrate', 'migrations', '0001')
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed'})
-    def test_sqlmigrate_squashed_migration(self):
-        out = io.StringIO()
-        call_command('sqlmigrate', 'migrations', '0001_squashed_0002', stdout=out)
-        output = out.getvalue().lower()
-        self.assertIn('-- create model author', output)
-        self.assertIn('-- create model book', output)
-        self.assertNotIn('-- create model tribble', output)
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed'})
-    def test_sqlmigrate_replaced_migration(self):
-        out = io.StringIO()
-        call_command('sqlmigrate', 'migrations', '0001_initial', stdout=out)
-        output = out.getvalue().lower()
-        self.assertIn('-- create model author', output)
-        self.assertIn('-- create model tribble', output)
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_no_operations'})
-    def test_migrations_no_operations(self):
-        err = io.StringIO()
-        call_command('sqlmigrate', 'migrations', '0001_initial', stderr=err)
-        self.assertEqual(err.getvalue(), 'No operations found.\n')
-
-    @override_settings(
-        INSTALLED_APPS=[
-            "migrations.migrations_test_apps.migrated_app",
-            "migrations.migrations_test_apps.migrated_unapplied_app",
-            "migrations.migrations_test_apps.unmigrated_app",
-        ],
-    )
-    def test_regression_22823_unmigrated_fk_to_migrated_model(self):
-        """
-        Assuming you have 3 apps, `A`, `B`, and `C`, such that:
-
-        * `A` has migrations
-        * `B` has a migration we want to apply
-        * `C` has no migrations, but has an FK to `A`
-
-        When we try to migrate "B", an exception occurs because the
-        "B" was not included in the ProjectState that is used to detect
-        soft-applied migrations (#22823).
-        """
-        call_command('migrate', 'migrated_unapplied_app', verbosity=0)
-
-        # unmigrated_app.SillyModel has a foreign key to 'migrations.Tribble',
-        # but that model is only defined in a migration, so the global app
-        # registry never sees it and the reference is left dangling. Remove it
-        # to avoid problems in subsequent tests.
-        del apps._pending_operations[('migrations', 'tribble')]
-
-    @override_settings(INSTALLED_APPS=['migrations.migrations_test_apps.unmigrated_app_syncdb'])
-    def test_migrate_syncdb_deferred_sql_executed_with_schemaeditor(self):
-        """
-        For an app without migrations, editor.execute() is used for executing
-        the syncdb deferred SQL.
-        """
-        stdout = io.StringIO()
-        with mock.patch.object(BaseDatabaseSchemaEditor, 'execute') as execute:
-            call_command('migrate', run_syncdb=True, verbosity=1, stdout=stdout, no_color=True)
-            create_table_count = len([call for call in execute.mock_calls if 'CREATE TABLE' in str(call)])
-            self.assertEqual(create_table_count, 2)
-            # There's at least one deferred SQL for creating the foreign key
-            # index.
-            self.assertGreater(len(execute.mock_calls), 2)
-        stdout = stdout.getvalue()
-        self.assertIn('Synchronize unmigrated apps: unmigrated_app_syncdb', stdout)
-        self.assertIn('Creating tables...', stdout)
-        table_name = truncate_name('unmigrated_app_syncdb_classroom', connection.ops.max_name_length())
-        self.assertIn('Creating table %s' % table_name, stdout)
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations'})
-    def test_migrate_syncdb_app_with_migrations(self):
-        msg = "Can't use run_syncdb with app 'migrations' as it has migrations."
-        with self.assertRaisesMessage(CommandError, msg):
-            call_command('migrate', 'migrations', run_syncdb=True, verbosity=0)
-
-    @override_settings(INSTALLED_APPS=[
-        'migrations.migrations_test_apps.unmigrated_app_syncdb',
-        'migrations.migrations_test_apps.unmigrated_app_simple',
-    ])
-    def test_migrate_syncdb_app_label(self):
-        """
-        Running migrate --run-syncdb with an app_label only creates tables for
-        the specified app.
-        """
-        stdout = io.StringIO()
-        with mock.patch.object(BaseDatabaseSchemaEditor, 'execute') as execute:
-            call_command('migrate', 'unmigrated_app_syncdb', run_syncdb=True, stdout=stdout)
-            create_table_count = len([call for call in execute.mock_calls if 'CREATE TABLE' in str(call)])
-            self.assertEqual(create_table_count, 2)
-            self.assertGreater(len(execute.mock_calls), 2)
-            self.assertIn('Synchronize unmigrated app: unmigrated_app_syncdb', stdout.getvalue())
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"})
-    def test_migrate_record_replaced(self):
-        """
-        Running a single squashed migration should record all of the original
-        replaced migrations as run.
-        """
-        recorder = MigrationRecorder(connection)
-        out = io.StringIO()
-        call_command("migrate", "migrations", verbosity=0)
-        call_command("showmigrations", "migrations", stdout=out, no_color=True)
-        self.assertEqual(
-            'migrations\n'
-            ' [x] 0001_squashed_0002 (2 squashed migrations)\n',
-            out.getvalue().lower()
-        )
-        applied_migrations = recorder.applied_migrations()
-        self.assertIn(("migrations", "0001_initial"), applied_migrations)
-        self.assertIn(("migrations", "0002_second"), applied_migrations)
-        self.assertIn(("migrations", "0001_squashed_0002"), applied_migrations)
-        # Rollback changes
-        call_command("migrate", "migrations", "zero", verbosity=0)
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"})
-    def test_migrate_record_squashed(self):
-        """
-        Running migrate for a squashed migration should record as run
-        if all of the replaced migrations have been run (#25231).
-        """
-        recorder = MigrationRecorder(connection)
-        recorder.record_applied("migrations", "0001_initial")
-        recorder.record_applied("migrations", "0002_second")
-        out = io.StringIO()
-        call_command("migrate", "migrations", verbosity=0)
-        call_command("showmigrations", "migrations", stdout=out, no_color=True)
-        self.assertEqual(
-            'migrations\n'
-            ' [x] 0001_squashed_0002 (2 squashed migrations)\n',
-            out.getvalue().lower()
-        )
-        self.assertIn(
-            ("migrations", "0001_squashed_0002"),
-            recorder.applied_migrations()
-        )
-        # No changes were actually applied so there is nothing to rollback
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations'})
-    def test_migrate_inconsistent_history(self):
-        """
-        Running migrate with some migrations applied before their dependencies
-        should not be allowed.
-        """
-        recorder = MigrationRecorder(connection)
-        recorder.record_applied("migrations", "0002_second")
-        msg = "Migration migrations.0002_second is applied before its dependency migrations.0001_initial"
-        with self.assertRaisesMessage(InconsistentMigrationHistory, msg):
-            call_command("migrate")
-        applied_migrations = recorder.applied_migrations()
-        self.assertNotIn(("migrations", "0001_initial"), applied_migrations)
-
-
-class MakeMigrationsTests(MigrationTestBase):
-    """
-    Tests running the makemigrations command.
-    """
-
-    def setUp(self):
-        super().setUp()
-        self._old_models = apps.app_configs['migrations'].models.copy()
-
-    def tearDown(self):
-        apps.app_configs['migrations'].models = self._old_models
-        apps.all_models['migrations'] = self._old_models
-        apps.clear_cache()
-        super().tearDown()
-
-    def test_files_content(self):
-        self.assertTableNotExists("migrations_unicodemodel")
-        apps.register_model('migrations', UnicodeModel)
-        with self.temporary_migration_module() as migration_dir:
-            call_command("makemigrations", "migrations", verbosity=0)
-
-            # Check for empty __init__.py file in migrations folder
-            init_file = os.path.join(migration_dir, "__init__.py")
-            self.assertTrue(os.path.exists(init_file))
-
-            with open(init_file) as fp:
-                content = fp.read()
-            self.assertEqual(content, '')
-
-            # Check for existing 0001_initial.py file in migration folder
-            initial_file = os.path.join(migration_dir, "0001_initial.py")
-            self.assertTrue(os.path.exists(initial_file))
-
-            with open(initial_file, encoding='utf-8') as fp:
-                content = fp.read()
-                self.assertIn('migrations.CreateModel', content)
-                self.assertIn('initial = True', content)
-
-                self.assertIn('úñí©óðé µóðéø', content)  # Meta.verbose_name
-                self.assertIn('úñí©óðé µóðéøß', content)  # Meta.verbose_name_plural
-                self.assertIn('ÚÑÍ¢ÓÐÉ', content)  # title.verbose_name
-                self.assertIn('“Ðjáñgó”', content)  # title.default
-
-    def test_makemigrations_order(self):
-        """
-        makemigrations should recognize number-only migrations (0001.py).
-        """
-        module = 'migrations.test_migrations_order'
-        with self.temporary_migration_module(module=module) as migration_dir:
-            if hasattr(importlib, 'invalidate_caches'):
-                # importlib caches os.listdir() on some platforms like macOS
-                # (#23850).
-                importlib.invalidate_caches()
-            call_command('makemigrations', 'migrations', '--empty', '-n', 'a', '-v', '0')
-            self.assertTrue(os.path.exists(os.path.join(migration_dir, '0002_a.py')))
-
-    def test_makemigrations_empty_connections(self):
-        empty_connections = ConnectionHandler({'default': {}})
-        with mock.patch('django.core.management.commands.makemigrations.connections', new=empty_connections):
-            # with no apps
-            out = io.StringIO()
-            call_command('makemigrations', stdout=out)
-            self.assertIn('No changes detected', out.getvalue())
-            # with an app
-            with self.temporary_migration_module() as migration_dir:
-                call_command('makemigrations', 'migrations', verbosity=0)
-                init_file = os.path.join(migration_dir, '__init__.py')
-                self.assertTrue(os.path.exists(init_file))
-
-    @override_settings(INSTALLED_APPS=['migrations', 'migrations2'])
-    def test_makemigrations_consistency_checks_respect_routers(self):
-        """
-        The history consistency checks in makemigrations respect
-        settings.DATABASE_ROUTERS.
-        """
-        def patched_has_table(migration_recorder):
-            if migration_recorder.connection is connections['other']:
-                raise Exception('Other connection')
-            else:
-                return mock.DEFAULT
-
-        self.assertTableNotExists('migrations_unicodemodel')
-        apps.register_model('migrations', UnicodeModel)
-        with mock.patch.object(
-                MigrationRecorder, 'has_table',
-                autospec=True, side_effect=patched_has_table) as has_table:
-            with self.temporary_migration_module() as migration_dir:
-                call_command("makemigrations", "migrations", verbosity=0)
-                initial_file = os.path.join(migration_dir, "0001_initial.py")
-                self.assertTrue(os.path.exists(initial_file))
-                self.assertEqual(has_table.call_count, 1)  # 'default' is checked
-
-                # Router says not to migrate 'other' so consistency shouldn't
-                # be checked.
-                with self.settings(DATABASE_ROUTERS=['migrations.routers.TestRouter']):
-                    call_command('makemigrations', 'migrations', verbosity=0)
-                self.assertEqual(has_table.call_count, 2)  # 'default' again
-
-                # With a router that doesn't prohibit migrating 'other',
-                # consistency is checked.
-                with self.settings(DATABASE_ROUTERS=['migrations.routers.DefaultOtherRouter']):
-                    with self.assertRaisesMessage(Exception, 'Other connection'):
-                        call_command('makemigrations', 'migrations', verbosity=0)
-                self.assertEqual(has_table.call_count, 4)  # 'default' and 'other'
-
-                # With a router that doesn't allow migrating on any database,
-                # no consistency checks are made.
-                with self.settings(DATABASE_ROUTERS=['migrations.routers.TestRouter']):
-                    with mock.patch.object(TestRouter, 'allow_migrate', return_value=False) as allow_migrate:
-                        call_command('makemigrations', 'migrations', verbosity=0)
-                allow_migrate.assert_any_call('other', 'migrations', model_name='UnicodeModel')
-                # allow_migrate() is called with the correct arguments.
-                self.assertGreater(len(allow_migrate.mock_calls), 0)
-                called_aliases = set()
-                for mock_call in allow_migrate.mock_calls:
-                    _, call_args, call_kwargs = mock_call
-                    connection_alias, app_name = call_args
-                    called_aliases.add(connection_alias)
-                    # Raises an error if invalid app_name/model_name occurs.
-                    apps.get_app_config(app_name).get_model(call_kwargs['model_name'])
-                self.assertEqual(called_aliases, set(connections))
-                self.assertEqual(has_table.call_count, 4)
-
-    def test_failing_migration(self):
-        # If a migration fails to serialize, it shouldn't generate an empty file. #21280
-        apps.register_model('migrations', UnserializableModel)
-
-        with self.temporary_migration_module() as migration_dir:
-            with self.assertRaisesMessage(ValueError, 'Cannot serialize'):
-                call_command("makemigrations", "migrations", verbosity=0)
-
-            initial_file = os.path.join(migration_dir, "0001_initial.py")
-            self.assertFalse(os.path.exists(initial_file))
-
-    def test_makemigrations_conflict_exit(self):
-        """
-        makemigrations exits if it detects a conflict.
-        """
-        with self.temporary_migration_module(module="migrations.test_migrations_conflict"):
-            with self.assertRaises(CommandError) as context:
-                call_command("makemigrations")
-        exception_message = str(context.exception)
-        self.assertIn(
-            'Conflicting migrations detected; multiple leaf nodes '
-            'in the migration graph:',
-            exception_message
-        )
-        self.assertIn('0002_second', exception_message)
-        self.assertIn('0002_conflicting_second', exception_message)
-        self.assertIn('in migrations', exception_message)
-        self.assertIn("To fix them run 'python manage.py makemigrations --merge'", exception_message)
-
-    def test_makemigrations_merge_no_conflict(self):
-        """
-        makemigrations exits if in merge mode with no conflicts.
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations"):
-            call_command("makemigrations", merge=True, stdout=out)
-        self.assertIn("No conflicts detected to merge.", out.getvalue())
-
-    def test_makemigrations_empty_no_app_specified(self):
-        """
-        makemigrations exits if no app is specified with 'empty' mode.
-        """
-        msg = 'You must supply at least one app label when using --empty.'
-        with self.assertRaisesMessage(CommandError, msg):
-            call_command("makemigrations", empty=True)
-
-    def test_makemigrations_empty_migration(self):
-        """
-        makemigrations properly constructs an empty migration.
-        """
-        with self.temporary_migration_module() as migration_dir:
-            call_command("makemigrations", "migrations", empty=True, verbosity=0)
-
-            # Check for existing 0001_initial.py file in migration folder
-            initial_file = os.path.join(migration_dir, "0001_initial.py")
-            self.assertTrue(os.path.exists(initial_file))
-
-            with open(initial_file, encoding='utf-8') as fp:
-                content = fp.read()
-
-                # Remove all whitespace to check for empty dependencies and operations
-                content = content.replace(' ', '')
-                self.assertIn('dependencies=[\n]', content)
-                self.assertIn('operations=[\n]', content)
-
-    @override_settings(MIGRATION_MODULES={"migrations": None})
-    def test_makemigrations_disabled_migrations_for_app(self):
-        """
-        makemigrations raises a nice error when migrations are disabled for an
-        app.
-        """
-        msg = (
-            "Django can't create migrations for app 'migrations' because migrations "
-            "have been disabled via the MIGRATION_MODULES setting."
-        )
-        with self.assertRaisesMessage(ValueError, msg):
-            call_command("makemigrations", "migrations", empty=True, verbosity=0)
-
-    def test_makemigrations_no_changes_no_apps(self):
-        """
-        makemigrations exits when there are no changes and no apps are specified.
-        """
-        out = io.StringIO()
-        call_command("makemigrations", stdout=out)
-        self.assertIn("No changes detected", out.getvalue())
-
-    def test_makemigrations_no_changes(self):
-        """
-        makemigrations exits when there are no changes to an app.
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations_no_changes"):
-            call_command("makemigrations", "migrations", stdout=out)
-        self.assertIn("No changes detected in app 'migrations'", out.getvalue())
-
-    def test_makemigrations_no_apps_initial(self):
-        """
-        makemigrations should detect initial is needed on empty migration
-        modules if no app provided.
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations_empty"):
-            call_command("makemigrations", stdout=out)
-        self.assertIn("0001_initial.py", out.getvalue())
-
-    def test_makemigrations_no_init(self):
-        """Migration directories without an __init__.py file are allowed."""
-        out = io.StringIO()
-        with self.temporary_migration_module(module='migrations.test_migrations_no_init'):
-            call_command('makemigrations', stdout=out)
-        self.assertIn('0001_initial.py', out.getvalue())
-
-    def test_makemigrations_migrations_announce(self):
-        """
-        makemigrations announces the migration at the default verbosity level.
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module():
-            call_command("makemigrations", "migrations", stdout=out)
-        self.assertIn("Migrations for 'migrations'", out.getvalue())
-
-    def test_makemigrations_no_common_ancestor(self):
-        """
-        makemigrations fails to merge migrations with no common ancestor.
-        """
-        with self.assertRaises(ValueError) as context:
-            with self.temporary_migration_module(module="migrations.test_migrations_no_ancestor"):
-                call_command("makemigrations", "migrations", merge=True)
-        exception_message = str(context.exception)
-        self.assertIn("Could not find common ancestor of", exception_message)
-        self.assertIn("0002_second", exception_message)
-        self.assertIn("0002_conflicting_second", exception_message)
-
-    def test_makemigrations_interactive_reject(self):
-        """
-        makemigrations enters and exits interactive mode properly.
-        """
-        # Monkeypatch interactive questioner to auto reject
-        with mock.patch('builtins.input', mock.Mock(return_value='N')):
-            with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
-                call_command("makemigrations", "migrations", name="merge", merge=True, interactive=True, verbosity=0)
-                merge_file = os.path.join(migration_dir, '0003_merge.py')
-                self.assertFalse(os.path.exists(merge_file))
-
-    def test_makemigrations_interactive_accept(self):
-        """
-        makemigrations enters interactive mode and merges properly.
-        """
-        # Monkeypatch interactive questioner to auto accept
-        with mock.patch('builtins.input', mock.Mock(return_value='y')):
-            out = io.StringIO()
-            with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
-                call_command("makemigrations", "migrations", name="merge", merge=True, interactive=True, stdout=out)
-                merge_file = os.path.join(migration_dir, '0003_merge.py')
-                self.assertTrue(os.path.exists(merge_file))
-            self.assertIn("Created new merge migration", out.getvalue())
-
-    @mock.patch('django.db.migrations.utils.datetime')
-    def test_makemigrations_default_merge_name(self, mock_datetime):
-        mock_datetime.datetime.now.return_value = datetime.datetime(2016, 1, 2, 3, 4)
-        with mock.patch('builtins.input', mock.Mock(return_value='y')):
-            out = io.StringIO()
-            with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
-                call_command("makemigrations", "migrations", merge=True, interactive=True, stdout=out)
-                merge_file = os.path.join(migration_dir, '0003_merge_20160102_0304.py')
-                self.assertTrue(os.path.exists(merge_file))
-            self.assertIn("Created new merge migration", out.getvalue())
-
-    def test_makemigrations_non_interactive_not_null_addition(self):
-        """
-        Non-interactive makemigrations fails when a default is missing on a
-        new not-null field.
-        """
-        class SillyModel(models.Model):
-            silly_field = models.BooleanField(default=False)
-            silly_int = models.IntegerField()
-
-            class Meta:
-                app_label = "migrations"
-
-        with self.assertRaises(SystemExit):
-            with self.temporary_migration_module(module="migrations.test_migrations_no_default"):
-                call_command("makemigrations", "migrations", interactive=False)
-
-    def test_makemigrations_non_interactive_not_null_alteration(self):
-        """
-        Non-interactive makemigrations fails when a default is missing on a
-        field changed to not-null.
-        """
-        class Author(models.Model):
-            name = models.CharField(max_length=255)
-            slug = models.SlugField()
-            age = models.IntegerField(default=0)
-
-            class Meta:
-                app_label = "migrations"
-
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations"):
-            call_command("makemigrations", "migrations", interactive=False, stdout=out)
-        self.assertIn("Alter field slug on author", out.getvalue())
-
-    def test_makemigrations_non_interactive_no_model_rename(self):
-        """
-        makemigrations adds and removes a possible model rename in
-        non-interactive mode.
-        """
-        class RenamedModel(models.Model):
-            silly_field = models.BooleanField(default=False)
-
-            class Meta:
-                app_label = "migrations"
-
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations_no_default"):
-            call_command("makemigrations", "migrations", interactive=False, stdout=out)
-        self.assertIn("Delete model SillyModel", out.getvalue())
-        self.assertIn("Create model RenamedModel", out.getvalue())
-
-    def test_makemigrations_non_interactive_no_field_rename(self):
-        """
-        makemigrations adds and removes a possible field rename in
-        non-interactive mode.
-        """
-        class SillyModel(models.Model):
-            silly_rename = models.BooleanField(default=False)
-
-            class Meta:
-                app_label = "migrations"
-
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations_no_default"):
-            call_command("makemigrations", "migrations", interactive=False, stdout=out)
-        self.assertIn("Remove field silly_field from sillymodel", out.getvalue())
-        self.assertIn("Add field silly_rename to sillymodel", out.getvalue())
-
-    def test_makemigrations_handle_merge(self):
-        """
-        makemigrations properly merges the conflicting migrations with --noinput.
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
-            call_command("makemigrations", "migrations", name="merge", merge=True, interactive=False, stdout=out)
-            merge_file = os.path.join(migration_dir, '0003_merge.py')
-            self.assertTrue(os.path.exists(merge_file))
-        output = out.getvalue()
-        self.assertIn("Merging migrations", output)
-        self.assertIn("Branch 0002_second", output)
-        self.assertIn("Branch 0002_conflicting_second", output)
-        self.assertIn("Created new merge migration", output)
-
-    def test_makemigration_merge_dry_run(self):
-        """
-        makemigrations respects --dry-run option when fixing migration
-        conflicts (#24427).
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
-            call_command(
-                "makemigrations", "migrations", name="merge", dry_run=True,
-                merge=True, interactive=False, stdout=out,
-            )
-            merge_file = os.path.join(migration_dir, '0003_merge.py')
-            self.assertFalse(os.path.exists(merge_file))
-        output = out.getvalue()
-        self.assertIn("Merging migrations", output)
-        self.assertIn("Branch 0002_second", output)
-        self.assertIn("Branch 0002_conflicting_second", output)
-        self.assertNotIn("Created new merge migration", output)
-
-    def test_makemigration_merge_dry_run_verbosity_3(self):
-        """
-        `makemigrations --merge --dry-run` writes the merge migration file to
-        stdout with `verbosity == 3` (#24427).
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
-            call_command(
-                "makemigrations", "migrations", name="merge", dry_run=True,
-                merge=True, interactive=False, stdout=out, verbosity=3,
-            )
-            merge_file = os.path.join(migration_dir, '0003_merge.py')
-            self.assertFalse(os.path.exists(merge_file))
-        output = out.getvalue()
-        self.assertIn("Merging migrations", output)
-        self.assertIn("Branch 0002_second", output)
-        self.assertIn("Branch 0002_conflicting_second", output)
-        self.assertNotIn("Created new merge migration", output)
-
-        # Additional output caused by verbosity 3
-        # The complete merge migration file that would be written
-        self.assertIn("class Migration(migrations.Migration):", output)
-        self.assertIn("dependencies = [", output)
-        self.assertIn("('migrations', '0002_second')", output)
-        self.assertIn("('migrations', '0002_conflicting_second')", output)
-        self.assertIn("operations = [", output)
-        self.assertIn("]", output)
-
-    def test_makemigrations_dry_run(self):
-        """
-        `makemigrations --dry-run` should not ask for defaults.
-        """
-        class SillyModel(models.Model):
-            silly_field = models.BooleanField(default=False)
-            silly_date = models.DateField()  # Added field without a default
-
-            class Meta:
-                app_label = "migrations"
-
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations_no_default"):
-            call_command("makemigrations", "migrations", dry_run=True, stdout=out)
-        # Output the expected changes directly, without asking for defaults
-        self.assertIn("Add field silly_date to sillymodel", out.getvalue())
-
-    def test_makemigrations_dry_run_verbosity_3(self):
-        """
-        Allow `makemigrations --dry-run` to output the migrations file to
-        stdout (with verbosity == 3).
-        """
-        class SillyModel(models.Model):
-            silly_field = models.BooleanField(default=False)
-            silly_char = models.CharField(default="")
-
-            class Meta:
-                app_label = "migrations"
-
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations_no_default"):
-            call_command("makemigrations", "migrations", dry_run=True, stdout=out, verbosity=3)
-
-        # Normal --dry-run output
-        self.assertIn("- Add field silly_char to sillymodel", out.getvalue())
-
-        # Additional output caused by verbosity 3
-        # The complete migrations file that would be written
-        self.assertIn("class Migration(migrations.Migration):", out.getvalue())
-        self.assertIn("dependencies = [", out.getvalue())
-        self.assertIn("('migrations', '0001_initial'),", out.getvalue())
-        self.assertIn("migrations.AddField(", out.getvalue())
-        self.assertIn("model_name='sillymodel',", out.getvalue())
-        self.assertIn("name='silly_char',", out.getvalue())
-
-    def test_makemigrations_migrations_modules_path_not_exist(self):
-        """
-        makemigrations creates migrations when specifying a custom location
-        for migration files using MIGRATION_MODULES if the custom path
-        doesn't already exist.
-        """
-        class SillyModel(models.Model):
-            silly_field = models.BooleanField(default=False)
-
-            class Meta:
-                app_label = "migrations"
-
-        out = io.StringIO()
-        migration_module = "migrations.test_migrations_path_doesnt_exist.foo.bar"
-        with self.temporary_migration_module(module=migration_module) as migration_dir:
-            call_command("makemigrations", "migrations", stdout=out)
-
-            # Migrations file is actually created in the expected path.
-            initial_file = os.path.join(migration_dir, "0001_initial.py")
-            self.assertTrue(os.path.exists(initial_file))
-
-        # Command output indicates the migration is created.
-        self.assertIn(" - Create model SillyModel", out.getvalue())
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'some.nonexistent.path'})
-    def test_makemigrations_migrations_modules_nonexistent_toplevel_package(self):
-        msg = (
-            'Could not locate an appropriate location to create migrations '
-            'package some.nonexistent.path. Make sure the toplevel package '
-            'exists and can be imported.'
-        )
-        with self.assertRaisesMessage(ValueError, msg):
-            call_command('makemigrations', 'migrations', empty=True, verbosity=0)
-
-    def test_makemigrations_interactive_by_default(self):
-        """
-        The user is prompted to merge by default if there are conflicts and
-        merge is True. Answer negative to differentiate it from behavior when
-        --noinput is specified.
-        """
-        # Monkeypatch interactive questioner to auto reject
-        out = io.StringIO()
-        with mock.patch('builtins.input', mock.Mock(return_value='N')):
-            with self.temporary_migration_module(module="migrations.test_migrations_conflict") as migration_dir:
-                call_command("makemigrations", "migrations", name="merge", merge=True, stdout=out)
-                merge_file = os.path.join(migration_dir, '0003_merge.py')
-                # This will fail if interactive is False by default
-                self.assertFalse(os.path.exists(merge_file))
-            self.assertNotIn("Created new merge migration", out.getvalue())
-
-    @override_settings(
-        INSTALLED_APPS=[
-            "migrations",
-            "migrations.migrations_test_apps.unspecified_app_with_conflict"])
-    def test_makemigrations_unspecified_app_with_conflict_no_merge(self):
-        """
-        makemigrations does not raise a CommandError when an unspecified app
-        has conflicting migrations.
-        """
-        with self.temporary_migration_module(module="migrations.test_migrations_no_changes"):
-            call_command("makemigrations", "migrations", merge=False, verbosity=0)
-
-    @override_settings(
-        INSTALLED_APPS=[
-            "migrations.migrations_test_apps.migrated_app",
-            "migrations.migrations_test_apps.unspecified_app_with_conflict"])
-    def test_makemigrations_unspecified_app_with_conflict_merge(self):
-        """
-        makemigrations does not create a merge for an unspecified app even if
-        it has conflicting migrations.
-        """
-        # Monkeypatch interactive questioner to auto accept
-        with mock.patch('builtins.input', mock.Mock(return_value='y')):
-            out = io.StringIO()
-            with self.temporary_migration_module(app_label="migrated_app") as migration_dir:
-                call_command("makemigrations", "migrated_app", name="merge", merge=True, interactive=True, stdout=out)
-                merge_file = os.path.join(migration_dir, '0003_merge.py')
-                self.assertFalse(os.path.exists(merge_file))
-            self.assertIn("No conflicts detected to merge.", out.getvalue())
-
-    @override_settings(
-        INSTALLED_APPS=[
-            "migrations.migrations_test_apps.migrated_app",
-            "migrations.migrations_test_apps.conflicting_app_with_dependencies"])
-    def test_makemigrations_merge_dont_output_dependency_operations(self):
-        """
-        makemigrations --merge does not output any operations from apps that
-        don't belong to a given app.
-        """
-        # Monkeypatch interactive questioner to auto accept
-        with mock.patch('builtins.input', mock.Mock(return_value='N')):
-            out = io.StringIO()
-            with mock.patch('django.core.management.color.supports_color', lambda *args: False):
-                call_command(
-                    "makemigrations", "conflicting_app_with_dependencies",
-                    merge=True, interactive=True, stdout=out
-                )
-            val = out.getvalue().lower()
-            self.assertIn('merging conflicting_app_with_dependencies\n', val)
-            self.assertIn(
-                '  branch 0002_conflicting_second\n'
-                '    - create model something\n',
-                val
-            )
-            self.assertIn(
-                '  branch 0002_second\n'
-                '    - delete model tribble\n'
-                '    - remove field silly_field from author\n'
-                '    - add field rating to author\n'
-                '    - create model book\n',
-                val
-            )
-
-    def test_makemigrations_with_custom_name(self):
-        """
-        makemigrations --name generate a custom migration name.
-        """
-        with self.temporary_migration_module() as migration_dir:
-
-            def cmd(migration_count, migration_name, *args):
-                call_command("makemigrations", "migrations", "--verbosity", "0", "--name", migration_name, *args)
-                migration_file = os.path.join(migration_dir, "%s_%s.py" % (migration_count, migration_name))
-                # Check for existing migration file in migration folder
-                self.assertTrue(os.path.exists(migration_file))
-                with open(migration_file, encoding='utf-8') as fp:
-                    content = fp.read()
-                    content = content.replace(" ", "")
-                return content
-
-            # generate an initial migration
-            migration_name_0001 = "my_initial_migration"
-            content = cmd("0001", migration_name_0001)
-            self.assertIn("dependencies=[\n]", content)
-
-            # importlib caches os.listdir() on some platforms like macOS
-            # (#23850).
-            if hasattr(importlib, 'invalidate_caches'):
-                importlib.invalidate_caches()
-
-            # generate an empty migration
-            migration_name_0002 = "my_custom_migration"
-            content = cmd("0002", migration_name_0002, "--empty")
-            self.assertIn("dependencies=[\n('migrations','0001_%s'),\n]" % migration_name_0001, content)
-            self.assertIn("operations=[\n]", content)
-
-    def test_makemigrations_with_invalid_custom_name(self):
-        msg = 'The migration name must be a valid Python identifier.'
-        with self.assertRaisesMessage(CommandError, msg):
-            call_command('makemigrations', 'migrations', '--name', 'invalid name', '--empty')
-
-    def test_makemigrations_check(self):
-        """
-        makemigrations --check should exit with a non-zero status when
-        there are changes to an app requiring migrations.
-        """
-        with self.temporary_migration_module():
-            with self.assertRaises(SystemExit):
-                call_command("makemigrations", "--check", "migrations", verbosity=0)
-
-        with self.temporary_migration_module(module="migrations.test_migrations_no_changes"):
-            call_command("makemigrations", "--check", "migrations", verbosity=0)
-
-    def test_makemigrations_migration_path_output(self):
-        """
-        makemigrations should print the relative paths to the migrations unless
-        they are outside of the current tree, in which case the absolute path
-        should be shown.
-        """
-        out = io.StringIO()
-        apps.register_model('migrations', UnicodeModel)
-        with self.temporary_migration_module() as migration_dir:
-            call_command("makemigrations", "migrations", stdout=out)
-            self.assertIn(os.path.join(migration_dir, '0001_initial.py'), out.getvalue())
-
-    def test_makemigrations_migration_path_output_valueerror(self):
-        """
-        makemigrations prints the absolute path if os.path.relpath() raises a
-        ValueError when it's impossible to obtain a relative path, e.g. on
-        Windows if Django is installed on a different drive than where the
-        migration files are created.
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module() as migration_dir:
-            with mock.patch('os.path.relpath', side_effect=ValueError):
-                call_command('makemigrations', 'migrations', stdout=out)
-        self.assertIn(os.path.join(migration_dir, '0001_initial.py'), out.getvalue())
-
-    def test_makemigrations_inconsistent_history(self):
-        """
-        makemigrations should raise InconsistentMigrationHistory exception if
-        there are some migrations applied before their dependencies.
-        """
-        recorder = MigrationRecorder(connection)
-        recorder.record_applied('migrations', '0002_second')
-        msg = "Migration migrations.0002_second is applied before its dependency migrations.0001_initial"
-        with self.temporary_migration_module(module="migrations.test_migrations"):
-            with self.assertRaisesMessage(InconsistentMigrationHistory, msg):
-                call_command("makemigrations")
-
-    def test_makemigrations_inconsistent_history_db_failure(self):
-        msg = (
-            "Got an error checking a consistent migration history performed "
-            "for database connection 'default': could not connect to server"
-        )
-        with mock.patch(
-            'django.db.migrations.loader.MigrationLoader.check_consistent_history',
-            side_effect=OperationalError('could not connect to server'),
-        ):
-            with self.temporary_migration_module():
-                with self.assertWarnsMessage(RuntimeWarning, msg):
-                    call_command('makemigrations', verbosity=0)
-
-    @mock.patch('builtins.input', return_value='1')
-    @mock.patch('django.db.migrations.questioner.sys.stdin', mock.MagicMock(encoding=sys.getdefaultencoding()))
-    def test_makemigrations_auto_now_add_interactive(self, *args):
-        """
-        makemigrations prompts the user when adding auto_now_add to an existing
-        model.
-        """
-        class Entry(models.Model):
-            title = models.CharField(max_length=255)
-            creation_date = models.DateTimeField(auto_now_add=True)
-
-            class Meta:
-                app_label = 'migrations'
-
-        # Monkeypatch interactive questioner to auto accept
-        with mock.patch('django.db.migrations.questioner.sys.stdout', new_callable=io.StringIO) as prompt_stdout:
-            out = io.StringIO()
-            with self.temporary_migration_module(module='migrations.test_auto_now_add'):
-                call_command('makemigrations', 'migrations', interactive=True, stdout=out)
-            output = out.getvalue()
-            prompt_output = prompt_stdout.getvalue()
-            self.assertIn("You can accept the default 'timezone.now' by pressing 'Enter'", prompt_output)
-            self.assertIn("Add field creation_date to entry", output)
-
-
-class SquashMigrationsTests(MigrationTestBase):
-    """
-    Tests running the squashmigrations command.
-    """
-
-    def test_squashmigrations_squashes(self):
-        """
-        squashmigrations squashes migrations.
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations") as migration_dir:
-            call_command('squashmigrations', 'migrations', '0002', interactive=False, stdout=out, no_color=True)
-
-            squashed_migration_file = os.path.join(migration_dir, "0001_squashed_0002_second.py")
-            self.assertTrue(os.path.exists(squashed_migration_file))
-        self.assertEqual(
-            out.getvalue(),
-            'Will squash the following migrations:\n'
-            ' - 0001_initial\n'
-            ' - 0002_second\n'
-            'Optimizing...\n'
-            '  Optimized from 8 operations to 2 operations.\n'
-            'Created new squashed migration %s\n'
-            '  You should commit this migration but leave the old ones in place;\n'
-            '  the new migration will be used for new installs. Once you are sure\n'
-            '  all instances of the codebase have applied the migrations you squashed,\n'
-            '  you can delete them.\n' % squashed_migration_file
-        )
-
-    def test_squashmigrations_initial_attribute(self):
-        with self.temporary_migration_module(module="migrations.test_migrations") as migration_dir:
-            call_command("squashmigrations", "migrations", "0002", interactive=False, verbosity=0)
-
-            squashed_migration_file = os.path.join(migration_dir, "0001_squashed_0002_second.py")
-            with open(squashed_migration_file, encoding='utf-8') as fp:
-                content = fp.read()
-                self.assertIn("initial = True", content)
-
-    def test_squashmigrations_optimizes(self):
-        """
-        squashmigrations optimizes operations.
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations"):
-            call_command("squashmigrations", "migrations", "0002", interactive=False, verbosity=1, stdout=out)
-        self.assertIn("Optimized from 8 operations to 2 operations.", out.getvalue())
-
-    def test_ticket_23799_squashmigrations_no_optimize(self):
-        """
-        squashmigrations --no-optimize doesn't optimize operations.
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations"):
-            call_command("squashmigrations", "migrations", "0002",
-                         interactive=False, verbosity=1, no_optimize=True, stdout=out)
-        self.assertIn("Skipping optimization", out.getvalue())
-
-    def test_squashmigrations_valid_start(self):
-        """
-        squashmigrations accepts a starting migration.
-        """
-        out = io.StringIO()
-        with self.temporary_migration_module(module="migrations.test_migrations_no_changes") as migration_dir:
-            call_command("squashmigrations", "migrations", "0002", "0003",
-                         interactive=False, verbosity=1, stdout=out)
-
-            squashed_migration_file = os.path.join(migration_dir, "0002_second_squashed_0003_third.py")
-            with open(squashed_migration_file, encoding='utf-8') as fp:
-                content = fp.read()
-                self.assertIn("        ('migrations', '0001_initial')", content)
-                self.assertNotIn("initial = True", content)
-        out = out.getvalue()
-        self.assertNotIn(" - 0001_initial", out)
-        self.assertIn(" - 0002_second", out)
-        self.assertIn(" - 0003_third", out)
-
-    def test_squashmigrations_invalid_start(self):
-        """
-        squashmigrations doesn't accept a starting migration after the ending migration.
-        """
-        with self.temporary_migration_module(module="migrations.test_migrations_no_changes"):
-            msg = (
-                "The migration 'migrations.0003_third' cannot be found. Maybe "
-                "it comes after the migration 'migrations.0002_second'"
-            )
-            with self.assertRaisesMessage(CommandError, msg):
-                call_command("squashmigrations", "migrations", "0003", "0002", interactive=False, verbosity=0)
-
-    def test_squashed_name_with_start_migration_name(self):
-        """--squashed-name specifies the new migration's name."""
-        squashed_name = 'squashed_name'
-        with self.temporary_migration_module(module='migrations.test_migrations') as migration_dir:
-            call_command(
-                'squashmigrations', 'migrations', '0001', '0002',
-                squashed_name=squashed_name, interactive=False, verbosity=0,
-            )
-            squashed_migration_file = os.path.join(migration_dir, '0001_%s.py' % squashed_name)
-            self.assertTrue(os.path.exists(squashed_migration_file))
-
-    def test_squashed_name_without_start_migration_name(self):
-        """--squashed-name also works if a start migration is omitted."""
-        squashed_name = 'squashed_name'
-        with self.temporary_migration_module(module="migrations.test_migrations") as migration_dir:
-            call_command(
-                'squashmigrations', 'migrations', '0001',
-                squashed_name=squashed_name, interactive=False, verbosity=0,
-            )
-            squashed_migration_file = os.path.join(migration_dir, '0001_%s.py' % squashed_name)
-            self.assertTrue(os.path.exists(squashed_migration_file))
-
-
-class AppLabelErrorTests(TestCase):
-    """
-    This class inherits TestCase because MigrationTestBase uses
-    `available_apps = ['migrations']` which means that it's the only installed
-    app. 'django.contrib.auth' must be in INSTALLED_APPS for some of these
-    tests.
-    """
-    nonexistent_app_error = "No installed app with label 'nonexistent_app'."
-    did_you_mean_auth_error = (
-        "No installed app with label 'django.contrib.auth'. Did you mean "
-        "'auth'?"
-    )
-
-    def test_makemigrations_nonexistent_app_label(self):
-        err = io.StringIO()
-        with self.assertRaises(SystemExit):
-            call_command('makemigrations', 'nonexistent_app', stderr=err)
-        self.assertIn(self.nonexistent_app_error, err.getvalue())
-
-    def test_makemigrations_app_name_specified_as_label(self):
-        err = io.StringIO()
-        with self.assertRaises(SystemExit):
-            call_command('makemigrations', 'django.contrib.auth', stderr=err)
-        self.assertIn(self.did_you_mean_auth_error, err.getvalue())
-
-    def test_migrate_nonexistent_app_label(self):
-        with self.assertRaisesMessage(CommandError, self.nonexistent_app_error):
-            call_command('migrate', 'nonexistent_app')
-
-    def test_migrate_app_name_specified_as_label(self):
-        with self.assertRaisesMessage(CommandError, self.did_you_mean_auth_error):
-            call_command('migrate', 'django.contrib.auth')
-
-    def test_showmigrations_nonexistent_app_label(self):
-        err = io.StringIO()
-        with self.assertRaises(SystemExit):
-            call_command('showmigrations', 'nonexistent_app', stderr=err)
-        self.assertIn(self.nonexistent_app_error, err.getvalue())
-
-    def test_showmigrations_app_name_specified_as_label(self):
-        err = io.StringIO()
-        with self.assertRaises(SystemExit):
-            call_command('showmigrations', 'django.contrib.auth', stderr=err)
-        self.assertIn(self.did_you_mean_auth_error, err.getvalue())
-
-    def test_sqlmigrate_nonexistent_app_label(self):
-        with self.assertRaisesMessage(CommandError, self.nonexistent_app_error):
-            call_command('sqlmigrate', 'nonexistent_app', '0002')
-
-    def test_sqlmigrate_app_name_specified_as_label(self):
-        with self.assertRaisesMessage(CommandError, self.did_you_mean_auth_error):
-            call_command('sqlmigrate', 'django.contrib.auth', '0002')
-
-    def test_squashmigrations_nonexistent_app_label(self):
-        with self.assertRaisesMessage(CommandError, self.nonexistent_app_error):
-            call_command('squashmigrations', 'nonexistent_app', '0002')
-
-    def test_squashmigrations_app_name_specified_as_label(self):
-        with self.assertRaisesMessage(CommandError, self.did_you_mean_auth_error):
-            call_command('squashmigrations', 'django.contrib.auth', '0002')
diff --git a/tests/migrations/test_deprecated_fields.py b/tests/migrations/test_deprecated_fields.py
deleted file mode 100644
index 2e9808e20b..0000000000
--- a/tests/migrations/test_deprecated_fields.py
+++ /dev/null
@@ -1,22 +0,0 @@
-from django.core.management import call_command
-from django.test import override_settings
-
-from .test_base import MigrationTestBase
-
-
-class Tests(MigrationTestBase):
-    """
-    Deprecated model fields should still be usable in historic migrations.
-    """
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.deprecated_field_migrations"})
-    def test_migrate(self):
-        # Make sure no tables are created
-        self.assertTableNotExists("migrations_ipaddressfield")
-        # Run migration
-        call_command("migrate", verbosity=0)
-        # Make sure the right tables exist
-        self.assertTableExists("migrations_ipaddressfield")
-        # Unmigrate everything
-        call_command("migrate", "migrations", "zero", verbosity=0)
-        # Make sure it's all gone
-        self.assertTableNotExists("migrations_ipaddressfield")
diff --git a/tests/migrations/test_exceptions.py b/tests/migrations/test_exceptions.py
deleted file mode 100644
index 3d839471f9..0000000000
--- a/tests/migrations/test_exceptions.py
+++ /dev/null
@@ -1,12 +0,0 @@
-from django.db.migrations.exceptions import NodeNotFoundError
-from django.test import SimpleTestCase
-
-
-class ExceptionTests(SimpleTestCase):
-    def test_node_not_found_error_repr(self):
-        node = ('some_app_label', 'some_migration_label')
-        error_repr = repr(NodeNotFoundError('some message', node))
-        self.assertEqual(
-            error_repr,
-            "NodeNotFoundError(('some_app_label', 'some_migration_label'))"
-        )
diff --git a/tests/migrations/test_executor.py b/tests/migrations/test_executor.py
deleted file mode 100644
index 5a122bc6b6..0000000000
--- a/tests/migrations/test_executor.py
+++ /dev/null
@@ -1,811 +0,0 @@
-from unittest import mock
-
-from django.apps.registry import apps as global_apps
-from django.db import DatabaseError, connection
-from django.db.migrations.exceptions import InvalidMigrationPlan
-from django.db.migrations.executor import MigrationExecutor
-from django.db.migrations.graph import MigrationGraph
-from django.db.migrations.recorder import MigrationRecorder
-from django.test import (
-    SimpleTestCase, modify_settings, override_settings, skipUnlessDBFeature,
-)
-
-from .test_base import MigrationTestBase
-
-
-@modify_settings(INSTALLED_APPS={'append': 'migrations2'})
-class ExecutorTests(MigrationTestBase):
-    """
-    Tests the migration executor (full end-to-end running).
-
-    Bear in mind that if these are failing you should fix the other
-    test failures first, as they may be propagating into here.
-    """
-
-    available_apps = ["migrations", "migrations2", "django.contrib.auth", "django.contrib.contenttypes"]
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
-    def test_run(self):
-        """
-        Tests running a simple set of migrations.
-        """
-        executor = MigrationExecutor(connection)
-        # Let's look at the plan first and make sure it's up to scratch
-        plan = executor.migration_plan([("migrations", "0002_second")])
-        self.assertEqual(
-            plan,
-            [
-                (executor.loader.graph.nodes["migrations", "0001_initial"], False),
-                (executor.loader.graph.nodes["migrations", "0002_second"], False),
-            ],
-        )
-        # Were the tables there before?
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_book")
-        # Alright, let's try running it
-        executor.migrate([("migrations", "0002_second")])
-        # Are the tables there now?
-        self.assertTableExists("migrations_author")
-        self.assertTableExists("migrations_book")
-        # Rebuild the graph to reflect the new DB state
-        executor.loader.build_graph()
-        # Alright, let's undo what we did
-        plan = executor.migration_plan([("migrations", None)])
-        self.assertEqual(
-            plan,
-            [
-                (executor.loader.graph.nodes["migrations", "0002_second"], True),
-                (executor.loader.graph.nodes["migrations", "0001_initial"], True),
-            ],
-        )
-        executor.migrate([("migrations", None)])
-        # Are the tables gone?
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_book")
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"})
-    def test_run_with_squashed(self):
-        """
-        Tests running a squashed migration from zero (should ignore what it replaces)
-        """
-        executor = MigrationExecutor(connection)
-        # Check our leaf node is the squashed one
-        leaves = [key for key in executor.loader.graph.leaf_nodes() if key[0] == "migrations"]
-        self.assertEqual(leaves, [("migrations", "0001_squashed_0002")])
-        # Check the plan
-        plan = executor.migration_plan([("migrations", "0001_squashed_0002")])
-        self.assertEqual(
-            plan,
-            [
-                (executor.loader.graph.nodes["migrations", "0001_squashed_0002"], False),
-            ],
-        )
-        # Were the tables there before?
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_book")
-        # Alright, let's try running it
-        executor.migrate([("migrations", "0001_squashed_0002")])
-        # Are the tables there now?
-        self.assertTableExists("migrations_author")
-        self.assertTableExists("migrations_book")
-        # Rebuild the graph to reflect the new DB state
-        executor.loader.build_graph()
-        # Alright, let's undo what we did. Should also just use squashed.
-        plan = executor.migration_plan([("migrations", None)])
-        self.assertEqual(
-            plan,
-            [
-                (executor.loader.graph.nodes["migrations", "0001_squashed_0002"], True),
-            ],
-        )
-        executor.migrate([("migrations", None)])
-        # Are the tables gone?
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_book")
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_non_atomic"})
-    def test_non_atomic_migration(self):
-        """
-        Applying a non-atomic migration works as expected.
-        """
-        executor = MigrationExecutor(connection)
-        with self.assertRaisesMessage(RuntimeError, "Abort migration"):
-            executor.migrate([("migrations", "0001_initial")])
-        self.assertTableExists("migrations_publisher")
-        migrations_apps = executor.loader.project_state(("migrations", "0001_initial")).apps
-        Publisher = migrations_apps.get_model("migrations", "Publisher")
-        self.assertTrue(Publisher.objects.exists())
-        self.assertTableNotExists("migrations_book")
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_atomic_operation"})
-    def test_atomic_operation_in_non_atomic_migration(self):
-        """
-        An atomic operation is properly rolled back inside a non-atomic
-        migration.
-        """
-        executor = MigrationExecutor(connection)
-        with self.assertRaisesMessage(RuntimeError, "Abort migration"):
-            executor.migrate([("migrations", "0001_initial")])
-        migrations_apps = executor.loader.project_state(("migrations", "0001_initial")).apps
-        Editor = migrations_apps.get_model("migrations", "Editor")
-        self.assertFalse(Editor.objects.exists())
-        # Record previous migration as successful.
-        executor.migrate([("migrations", "0001_initial")], fake=True)
-        # Rebuild the graph to reflect the new DB state.
-        executor.loader.build_graph()
-        # Migrating backwards is also atomic.
-        with self.assertRaisesMessage(RuntimeError, "Abort migration"):
-            executor.migrate([("migrations", None)])
-        self.assertFalse(Editor.objects.exists())
-
-    @override_settings(MIGRATION_MODULES={
-        "migrations": "migrations.test_migrations",
-        "migrations2": "migrations2.test_migrations_2",
-    })
-    def test_empty_plan(self):
-        """
-        Re-planning a full migration of a fully-migrated set doesn't
-        perform spurious unmigrations and remigrations.
-
-        There was previously a bug where the executor just always performed the
-        backwards plan for applied migrations - which even for the most recent
-        migration in an app, might include other, dependent apps, and these
-        were being unmigrated.
-        """
-        # Make the initial plan, check it
-        executor = MigrationExecutor(connection)
-        plan = executor.migration_plan([
-            ("migrations", "0002_second"),
-            ("migrations2", "0001_initial"),
-        ])
-        self.assertEqual(
-            plan,
-            [
-                (executor.loader.graph.nodes["migrations", "0001_initial"], False),
-                (executor.loader.graph.nodes["migrations", "0002_second"], False),
-                (executor.loader.graph.nodes["migrations2", "0001_initial"], False),
-            ],
-        )
-        # Fake-apply all migrations
-        executor.migrate([
-            ("migrations", "0002_second"),
-            ("migrations2", "0001_initial")
-        ], fake=True)
-        # Rebuild the graph to reflect the new DB state
-        executor.loader.build_graph()
-        # Now plan a second time and make sure it's empty
-        plan = executor.migration_plan([
-            ("migrations", "0002_second"),
-            ("migrations2", "0001_initial"),
-        ])
-        self.assertEqual(plan, [])
-        # The resulting state should include applied migrations.
-        state = executor.migrate([
-            ("migrations", "0002_second"),
-            ("migrations2", "0001_initial"),
-        ])
-        self.assertIn(('migrations', 'book'), state.models)
-        self.assertIn(('migrations', 'author'), state.models)
-        self.assertIn(('migrations2', 'otherauthor'), state.models)
-        # Erase all the fake records
-        executor.recorder.record_unapplied("migrations2", "0001_initial")
-        executor.recorder.record_unapplied("migrations", "0002_second")
-        executor.recorder.record_unapplied("migrations", "0001_initial")
-
-    @override_settings(MIGRATION_MODULES={
-        "migrations": "migrations.test_migrations",
-        "migrations2": "migrations2.test_migrations_2_no_deps",
-    })
-    def test_mixed_plan_not_supported(self):
-        """
-        Although the MigrationExecutor interfaces allows for mixed migration
-        plans (combined forwards and backwards migrations) this is not
-        supported.
-        """
-        # Prepare for mixed plan
-        executor = MigrationExecutor(connection)
-        plan = executor.migration_plan([("migrations", "0002_second")])
-        self.assertEqual(
-            plan,
-            [
-                (executor.loader.graph.nodes["migrations", "0001_initial"], False),
-                (executor.loader.graph.nodes["migrations", "0002_second"], False),
-            ],
-        )
-        executor.migrate(None, plan)
-        # Rebuild the graph to reflect the new DB state
-        executor.loader.build_graph()
-        self.assertIn(('migrations', '0001_initial'), executor.loader.applied_migrations)
-        self.assertIn(('migrations', '0002_second'), executor.loader.applied_migrations)
-        self.assertNotIn(('migrations2', '0001_initial'), executor.loader.applied_migrations)
-
-        # Generate mixed plan
-        plan = executor.migration_plan([
-            ("migrations", None),
-            ("migrations2", "0001_initial"),
-        ])
-        msg = (
-            'Migration plans with both forwards and backwards migrations are '
-            'not supported. Please split your migration process into separate '
-            'plans of only forwards OR backwards migrations.'
-        )
-        with self.assertRaisesMessage(InvalidMigrationPlan, msg) as cm:
-            executor.migrate(None, plan)
-        self.assertEqual(
-            cm.exception.args[1],
-            [
-                (executor.loader.graph.nodes["migrations", "0002_second"], True),
-                (executor.loader.graph.nodes["migrations", "0001_initial"], True),
-                (executor.loader.graph.nodes["migrations2", "0001_initial"], False),
-            ],
-        )
-        # Rebuild the graph to reflect the new DB state
-        executor.loader.build_graph()
-        executor.migrate([
-            ("migrations", None),
-            ("migrations2", None),
-        ])
-        # Are the tables gone?
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_book")
-        self.assertTableNotExists("migrations2_otherauthor")
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
-    def test_soft_apply(self):
-        """
-        Tests detection of initial migrations already having been applied.
-        """
-        state = {"faked": None}
-
-        def fake_storer(phase, migration=None, fake=None):
-            state["faked"] = fake
-        executor = MigrationExecutor(connection, progress_callback=fake_storer)
-        # Were the tables there before?
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-        # Run it normally
-        self.assertEqual(
-            executor.migration_plan([("migrations", "0001_initial")]),
-            [
-                (executor.loader.graph.nodes["migrations", "0001_initial"], False),
-            ],
-        )
-        executor.migrate([("migrations", "0001_initial")])
-        # Are the tables there now?
-        self.assertTableExists("migrations_author")
-        self.assertTableExists("migrations_tribble")
-        # We shouldn't have faked that one
-        self.assertIs(state["faked"], False)
-        # Rebuild the graph to reflect the new DB state
-        executor.loader.build_graph()
-        # Fake-reverse that
-        executor.migrate([("migrations", None)], fake=True)
-        # Are the tables still there?
-        self.assertTableExists("migrations_author")
-        self.assertTableExists("migrations_tribble")
-        # Make sure that was faked
-        self.assertIs(state["faked"], True)
-        # Finally, migrate forwards; this should fake-apply our initial migration
-        executor.loader.build_graph()
-        self.assertEqual(
-            executor.migration_plan([("migrations", "0001_initial")]),
-            [
-                (executor.loader.graph.nodes["migrations", "0001_initial"], False),
-            ],
-        )
-        # Applying the migration should raise a database level error
-        # because we haven't given the --fake-initial option
-        with self.assertRaises(DatabaseError):
-            executor.migrate([("migrations", "0001_initial")])
-        # Reset the faked state
-        state = {"faked": None}
-        # Allow faking of initial CreateModel operations
-        executor.migrate([("migrations", "0001_initial")], fake_initial=True)
-        self.assertIs(state["faked"], True)
-        # And migrate back to clean up the database
-        executor.loader.build_graph()
-        executor.migrate([("migrations", None)])
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-
-    @override_settings(
-        MIGRATION_MODULES={
-            "migrations": "migrations.test_migrations_custom_user",
-            "django.contrib.auth": "django.contrib.auth.migrations",
-        },
-        AUTH_USER_MODEL="migrations.Author",
-    )
-    def test_custom_user(self):
-        """
-        Regression test for #22325 - references to a custom user model defined in the
-        same app are not resolved correctly.
-        """
-        executor = MigrationExecutor(connection)
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-        # Migrate forwards
-        executor.migrate([("migrations", "0001_initial")])
-        self.assertTableExists("migrations_author")
-        self.assertTableExists("migrations_tribble")
-        # Make sure the soft-application detection works (#23093)
-        # Change table_names to not return auth_user during this as
-        # it wouldn't be there in a normal run, and ensure migrations.Author
-        # exists in the global app registry temporarily.
-        old_table_names = connection.introspection.table_names
-        connection.introspection.table_names = lambda c: [x for x in old_table_names(c) if x != "auth_user"]
-        migrations_apps = executor.loader.project_state(("migrations", "0001_initial")).apps
-        global_apps.get_app_config("migrations").models["author"] = migrations_apps.get_model("migrations", "author")
-        try:
-            migration = executor.loader.get_migration("auth", "0001_initial")
-            self.assertIs(executor.detect_soft_applied(None, migration)[0], True)
-        finally:
-            connection.introspection.table_names = old_table_names
-            del global_apps.get_app_config("migrations").models["author"]
-        # And migrate back to clean up the database
-        executor.loader.build_graph()
-        executor.migrate([("migrations", None)])
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-
-    @override_settings(
-        MIGRATION_MODULES={
-            "migrations": "migrations.test_add_many_to_many_field_initial",
-        },
-    )
-    def test_detect_soft_applied_add_field_manytomanyfield(self):
-        """
-        executor.detect_soft_applied() detects ManyToManyField tables from an
-        AddField operation. This checks the case of AddField in a migration
-        with other operations (0001) and the case of AddField in its own
-        migration (0002).
-        """
-        tables = [
-            # from 0001
-            "migrations_project",
-            "migrations_task",
-            "migrations_project_tasks",
-            # from 0002
-            "migrations_task_projects",
-        ]
-        executor = MigrationExecutor(connection)
-        # Create the tables for 0001 but make it look like the migration hasn't
-        # been applied.
-        executor.migrate([("migrations", "0001_initial")])
-        executor.migrate([("migrations", None)], fake=True)
-        for table in tables[:3]:
-            self.assertTableExists(table)
-        # Table detection sees 0001 is applied but not 0002.
-        migration = executor.loader.get_migration("migrations", "0001_initial")
-        self.assertIs(executor.detect_soft_applied(None, migration)[0], True)
-        migration = executor.loader.get_migration("migrations", "0002_initial")
-        self.assertIs(executor.detect_soft_applied(None, migration)[0], False)
-
-        # Create the tables for both migrations but make it look like neither
-        # has been applied.
-        executor.loader.build_graph()
-        executor.migrate([("migrations", "0001_initial")], fake=True)
-        executor.migrate([("migrations", "0002_initial")])
-        executor.loader.build_graph()
-        executor.migrate([("migrations", None)], fake=True)
-        # Table detection sees 0002 is applied.
-        migration = executor.loader.get_migration("migrations", "0002_initial")
-        self.assertIs(executor.detect_soft_applied(None, migration)[0], True)
-
-        # Leave the tables for 0001 except the many-to-many table. That missing
-        # table should cause detect_soft_applied() to return False.
-        with connection.schema_editor() as editor:
-            for table in tables[2:]:
-                editor.execute(editor.sql_delete_table % {"table": table})
-        migration = executor.loader.get_migration("migrations", "0001_initial")
-        self.assertIs(executor.detect_soft_applied(None, migration)[0], False)
-
-        # Cleanup by removing the remaining tables.
-        with connection.schema_editor() as editor:
-            for table in tables[:2]:
-                editor.execute(editor.sql_delete_table % {"table": table})
-        for table in tables:
-            self.assertTableNotExists(table)
-
-    @override_settings(
-        INSTALLED_APPS=[
-            "migrations.migrations_test_apps.lookuperror_a",
-            "migrations.migrations_test_apps.lookuperror_b",
-            "migrations.migrations_test_apps.lookuperror_c"
-        ]
-    )
-    def test_unrelated_model_lookups_forwards(self):
-        """
-        #24123 - All models of apps already applied which are
-        unrelated to the first app being applied are part of the initial model
-        state.
-        """
-        try:
-            executor = MigrationExecutor(connection)
-            self.assertTableNotExists("lookuperror_a_a1")
-            self.assertTableNotExists("lookuperror_b_b1")
-            self.assertTableNotExists("lookuperror_c_c1")
-            executor.migrate([("lookuperror_b", "0003_b3")])
-            self.assertTableExists("lookuperror_b_b3")
-            # Rebuild the graph to reflect the new DB state
-            executor.loader.build_graph()
-
-            # Migrate forwards -- This led to a lookup LookupErrors because
-            # lookuperror_b.B2 is already applied
-            executor.migrate([
-                ("lookuperror_a", "0004_a4"),
-                ("lookuperror_c", "0003_c3"),
-            ])
-            self.assertTableExists("lookuperror_a_a4")
-            self.assertTableExists("lookuperror_c_c3")
-
-            # Rebuild the graph to reflect the new DB state
-            executor.loader.build_graph()
-        finally:
-            # Cleanup
-            executor.migrate([
-                ("lookuperror_a", None),
-                ("lookuperror_b", None),
-                ("lookuperror_c", None),
-            ])
-            self.assertTableNotExists("lookuperror_a_a1")
-            self.assertTableNotExists("lookuperror_b_b1")
-            self.assertTableNotExists("lookuperror_c_c1")
-
-    @override_settings(
-        INSTALLED_APPS=[
-            "migrations.migrations_test_apps.lookuperror_a",
-            "migrations.migrations_test_apps.lookuperror_b",
-            "migrations.migrations_test_apps.lookuperror_c"
-        ]
-    )
-    def test_unrelated_model_lookups_backwards(self):
-        """
-        #24123 - All models of apps being unapplied which are
-        unrelated to the first app being unapplied are part of the initial
-        model state.
-        """
-        try:
-            executor = MigrationExecutor(connection)
-            self.assertTableNotExists("lookuperror_a_a1")
-            self.assertTableNotExists("lookuperror_b_b1")
-            self.assertTableNotExists("lookuperror_c_c1")
-            executor.migrate([
-                ("lookuperror_a", "0004_a4"),
-                ("lookuperror_b", "0003_b3"),
-                ("lookuperror_c", "0003_c3"),
-            ])
-            self.assertTableExists("lookuperror_b_b3")
-            self.assertTableExists("lookuperror_a_a4")
-            self.assertTableExists("lookuperror_c_c3")
-            # Rebuild the graph to reflect the new DB state
-            executor.loader.build_graph()
-
-            # Migrate backwards -- This led to a lookup LookupErrors because
-            # lookuperror_b.B2 is not in the initial state (unrelated to app c)
-            executor.migrate([("lookuperror_a", None)])
-
-            # Rebuild the graph to reflect the new DB state
-            executor.loader.build_graph()
-        finally:
-            # Cleanup
-            executor.migrate([
-                ("lookuperror_b", None),
-                ("lookuperror_c", None)
-            ])
-            self.assertTableNotExists("lookuperror_a_a1")
-            self.assertTableNotExists("lookuperror_b_b1")
-            self.assertTableNotExists("lookuperror_c_c1")
-
-    @override_settings(
-        INSTALLED_APPS=[
-            'migrations.migrations_test_apps.mutate_state_a',
-            'migrations.migrations_test_apps.mutate_state_b',
-        ]
-    )
-    def test_unrelated_applied_migrations_mutate_state(self):
-        """
-        #26647 - Unrelated applied migrations should be part of the final
-        state in both directions.
-        """
-        executor = MigrationExecutor(connection)
-        executor.migrate([
-            ('mutate_state_b', '0002_add_field'),
-        ])
-        # Migrate forward.
-        executor.loader.build_graph()
-        state = executor.migrate([
-            ('mutate_state_a', '0001_initial'),
-        ])
-        self.assertIn('added', state.models['mutate_state_b', 'b'].fields)
-        executor.loader.build_graph()
-        # Migrate backward.
-        state = executor.migrate([
-            ('mutate_state_a', None),
-        ])
-        self.assertIn('added', state.models['mutate_state_b', 'b'].fields)
-        executor.migrate([
-            ('mutate_state_b', None),
-        ])
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
-    def test_process_callback(self):
-        """
-        #24129 - Tests callback process
-        """
-        call_args_list = []
-
-        def callback(*args):
-            call_args_list.append(args)
-
-        executor = MigrationExecutor(connection, progress_callback=callback)
-        # Were the tables there before?
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-        executor.migrate([
-            ("migrations", "0001_initial"),
-            ("migrations", "0002_second"),
-        ])
-        # Rebuild the graph to reflect the new DB state
-        executor.loader.build_graph()
-
-        executor.migrate([
-            ("migrations", None),
-            ("migrations", None),
-        ])
-        self.assertTableNotExists("migrations_author")
-        self.assertTableNotExists("migrations_tribble")
-
-        migrations = executor.loader.graph.nodes
-        expected = [
-            ("render_start",),
-            ("render_success",),
-            ("apply_start", migrations['migrations', '0001_initial'], False),
-            ("apply_success", migrations['migrations', '0001_initial'], False),
-            ("apply_start", migrations['migrations', '0002_second'], False),
-            ("apply_success", migrations['migrations', '0002_second'], False),
-            ("render_start",),
-            ("render_success",),
-            ("unapply_start", migrations['migrations', '0002_second'], False),
-            ("unapply_success", migrations['migrations', '0002_second'], False),
-            ("unapply_start", migrations['migrations', '0001_initial'], False),
-            ("unapply_success", migrations['migrations', '0001_initial'], False),
-        ]
-        self.assertEqual(call_args_list, expected)
-
-    @override_settings(
-        INSTALLED_APPS=[
-            "migrations.migrations_test_apps.alter_fk.author_app",
-            "migrations.migrations_test_apps.alter_fk.book_app",
-        ]
-    )
-    def test_alter_id_type_with_fk(self):
-        try:
-            executor = MigrationExecutor(connection)
-            self.assertTableNotExists("author_app_author")
-            self.assertTableNotExists("book_app_book")
-            # Apply initial migrations
-            executor.migrate([
-                ("author_app", "0001_initial"),
-                ("book_app", "0001_initial"),
-            ])
-            self.assertTableExists("author_app_author")
-            self.assertTableExists("book_app_book")
-            # Rebuild the graph to reflect the new DB state
-            executor.loader.build_graph()
-
-            # Apply PK type alteration
-            executor.migrate([("author_app", "0002_alter_id")])
-
-            # Rebuild the graph to reflect the new DB state
-            executor.loader.build_graph()
-        finally:
-            # We can't simply unapply the migrations here because there is no
-            # implicit cast from VARCHAR to INT on the database level.
-            with connection.schema_editor() as editor:
-                editor.execute(editor.sql_delete_table % {"table": "book_app_book"})
-                editor.execute(editor.sql_delete_table % {"table": "author_app_author"})
-            self.assertTableNotExists("author_app_author")
-            self.assertTableNotExists("book_app_book")
-            executor.migrate([("author_app", None)], fake=True)
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"})
-    def test_apply_all_replaced_marks_replacement_as_applied(self):
-        """
-        Applying all replaced migrations marks replacement as applied (#24628).
-        """
-        recorder = MigrationRecorder(connection)
-        # Place the database in a state where the replaced migrations are
-        # partially applied: 0001 is applied, 0002 is not.
-        recorder.record_applied("migrations", "0001_initial")
-        executor = MigrationExecutor(connection)
-        # Use fake because we don't actually have the first migration
-        # applied, so the second will fail. And there's no need to actually
-        # create/modify tables here, we're just testing the
-        # MigrationRecord, which works the same with or without fake.
-        executor.migrate([("migrations", "0002_second")], fake=True)
-
-        # Because we've now applied 0001 and 0002 both, their squashed
-        # replacement should be marked as applied.
-        self.assertIn(
-            ("migrations", "0001_squashed_0002"),
-            recorder.applied_migrations(),
-        )
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"})
-    def test_migrate_marks_replacement_applied_even_if_it_did_nothing(self):
-        """
-        A new squash migration will be marked as applied even if all its
-        replaced migrations were previously already applied (#24628).
-        """
-        recorder = MigrationRecorder(connection)
-        # Record all replaced migrations as applied
-        recorder.record_applied("migrations", "0001_initial")
-        recorder.record_applied("migrations", "0002_second")
-        executor = MigrationExecutor(connection)
-        executor.migrate([("migrations", "0001_squashed_0002")])
-
-        # Because 0001 and 0002 are both applied, even though this migrate run
-        # didn't apply anything new, their squashed replacement should be
-        # marked as applied.
-        self.assertIn(
-            ("migrations", "0001_squashed_0002"),
-            recorder.applied_migrations(),
-        )
-
-    # When the feature is False, the operation and the record won't be
-    # performed in a transaction and the test will systematically pass.
-    @skipUnlessDBFeature('can_rollback_ddl')
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations'})
-    def test_migrations_applied_and_recorded_atomically(self):
-        """Migrations are applied and recorded atomically."""
-        executor = MigrationExecutor(connection)
-        with mock.patch('django.db.migrations.executor.MigrationExecutor.record_migration') as record_migration:
-            record_migration.side_effect = RuntimeError('Recording migration failed.')
-            with self.assertRaisesMessage(RuntimeError, 'Recording migration failed.'):
-                executor.migrate([('migrations', '0001_initial')])
-        # The migration isn't recorded as applied since it failed.
-        migration_recorder = MigrationRecorder(connection)
-        self.assertFalse(migration_recorder.migration_qs.filter(app='migrations', name='0001_initial').exists())
-        self.assertTableNotExists('migrations_author')
-
-
-class FakeLoader:
-    def __init__(self, graph, applied):
-        self.graph = graph
-        self.applied_migrations = applied
-
-
-class FakeMigration:
-    """Really all we need is any object with a debug-useful repr."""
-    def __init__(self, name):
-        self.name = name
-
-    def __repr__(self):
-        return 'M<%s>' % self.name
-
-
-class ExecutorUnitTests(SimpleTestCase):
-    """(More) isolated unit tests for executor methods."""
-    def test_minimize_rollbacks(self):
-        """
-        Minimize unnecessary rollbacks in connected apps.
-
-        When you say "./manage.py migrate appA 0001", rather than migrating to
-        just after appA-0001 in the linearized migration plan (which could roll
-        back migrations in other apps that depend on appA 0001, but don't need
-        to be rolled back since we're not rolling back appA 0001), we migrate
-        to just before appA-0002.
-        """
-        a1_impl = FakeMigration('a1')
-        a1 = ('a', '1')
-        a2_impl = FakeMigration('a2')
-        a2 = ('a', '2')
-        b1_impl = FakeMigration('b1')
-        b1 = ('b', '1')
-        graph = MigrationGraph()
-        graph.add_node(a1, a1_impl)
-        graph.add_node(a2, a2_impl)
-        graph.add_node(b1, b1_impl)
-        graph.add_dependency(None, b1, a1)
-        graph.add_dependency(None, a2, a1)
-
-        executor = MigrationExecutor(None)
-        executor.loader = FakeLoader(graph, {
-            a1: a1_impl,
-            b1: b1_impl,
-            a2: a2_impl,
-        })
-
-        plan = executor.migration_plan({a1})
-
-        self.assertEqual(plan, [(a2_impl, True)])
-
-    def test_minimize_rollbacks_branchy(self):
-        r"""
-        Minimize rollbacks when target has multiple in-app children.
-
-        a: 1 <---- 3 <--\
-              \ \- 2 <--- 4
-               \       \
-        b:      \- 1 <--- 2
-        """
-        a1_impl = FakeMigration('a1')
-        a1 = ('a', '1')
-        a2_impl = FakeMigration('a2')
-        a2 = ('a', '2')
-        a3_impl = FakeMigration('a3')
-        a3 = ('a', '3')
-        a4_impl = FakeMigration('a4')
-        a4 = ('a', '4')
-        b1_impl = FakeMigration('b1')
-        b1 = ('b', '1')
-        b2_impl = FakeMigration('b2')
-        b2 = ('b', '2')
-        graph = MigrationGraph()
-        graph.add_node(a1, a1_impl)
-        graph.add_node(a2, a2_impl)
-        graph.add_node(a3, a3_impl)
-        graph.add_node(a4, a4_impl)
-        graph.add_node(b1, b1_impl)
-        graph.add_node(b2, b2_impl)
-        graph.add_dependency(None, a2, a1)
-        graph.add_dependency(None, a3, a1)
-        graph.add_dependency(None, a4, a2)
-        graph.add_dependency(None, a4, a3)
-        graph.add_dependency(None, b2, b1)
-        graph.add_dependency(None, b1, a1)
-        graph.add_dependency(None, b2, a2)
-
-        executor = MigrationExecutor(None)
-        executor.loader = FakeLoader(graph, {
-            a1: a1_impl,
-            b1: b1_impl,
-            a2: a2_impl,
-            b2: b2_impl,
-            a3: a3_impl,
-            a4: a4_impl,
-        })
-
-        plan = executor.migration_plan({a1})
-
-        should_be_rolled_back = [b2_impl, a4_impl, a2_impl, a3_impl]
-        exp = [(m, True) for m in should_be_rolled_back]
-        self.assertEqual(plan, exp)
-
-    def test_backwards_nothing_to_do(self):
-        r"""
-        If the current state satisfies the given target, do nothing.
-
-        a: 1 <--- 2
-        b:    \- 1
-        c:     \- 1
-
-        If a1 is applied already and a2 is not, and we're asked to migrate to
-        a1, don't apply or unapply b1 or c1, regardless of their current state.
-        """
-        a1_impl = FakeMigration('a1')
-        a1 = ('a', '1')
-        a2_impl = FakeMigration('a2')
-        a2 = ('a', '2')
-        b1_impl = FakeMigration('b1')
-        b1 = ('b', '1')
-        c1_impl = FakeMigration('c1')
-        c1 = ('c', '1')
-        graph = MigrationGraph()
-        graph.add_node(a1, a1_impl)
-        graph.add_node(a2, a2_impl)
-        graph.add_node(b1, b1_impl)
-        graph.add_node(c1, c1_impl)
-        graph.add_dependency(None, a2, a1)
-        graph.add_dependency(None, b1, a1)
-        graph.add_dependency(None, c1, a1)
-
-        executor = MigrationExecutor(None)
-        executor.loader = FakeLoader(graph, {
-            a1: a1_impl,
-            b1: b1_impl,
-        })
-
-        plan = executor.migration_plan({a1})
-
-        self.assertEqual(plan, [])
diff --git a/tests/migrations/test_fake_initial_case_insensitive/fake_initial/0001_initial.py b/tests/migrations/test_fake_initial_case_insensitive/fake_initial/0001_initial.py
deleted file mode 100644
index dc492b3486..0000000000
--- a/tests/migrations/test_fake_initial_case_insensitive/fake_initial/0001_initial.py
+++ /dev/null
@@ -1,28 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-    initial = True
-
-    operations = [
-        migrations.CreateModel(
-            'fakeinitialmodel',
-            [
-                ('id', models.AutoField(primary_key=True)),
-                ('field', models.CharField(max_length=20)),
-            ],
-            options={
-                'db_table': 'migrations_mIxEd_cAsE_mOdEl',
-            },
-        ),
-        migrations.AddField(
-            model_name='fakeinitialmodel',
-            name='field_mixed_case',
-            field=models.CharField(max_length=20, db_column='fIeLd_mIxEd_cAsE'),
-        ),
-        migrations.AddField(
-            model_name='fakeinitialmodel',
-            name='fake_initial_model',
-            field=models.ManyToManyField(to='migrations.fakeinitialmodel', db_table='m2m_mIxEd_cAsE'),
-        ),
-    ]
diff --git a/tests/migrations/test_fake_initial_case_insensitive/fake_initial/__init__.py b/tests/migrations/test_fake_initial_case_insensitive/fake_initial/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_fake_initial_case_insensitive/initial/0001_initial.py b/tests/migrations/test_fake_initial_case_insensitive/initial/0001_initial.py
deleted file mode 100644
index 339d57d21c..0000000000
--- a/tests/migrations/test_fake_initial_case_insensitive/initial/0001_initial.py
+++ /dev/null
@@ -1,23 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-    initial = True
-
-    operations = [
-        migrations.CreateModel(
-            name='fakeinitialmodel',
-            fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('field', models.CharField(max_length=20)),
-                ('field_mixed_case', models.CharField(max_length=20, db_column='FiEld_MiXeD_CaSe')),
-                (
-                    'fake_initial_mode',
-                    models.ManyToManyField('migrations.FakeInitialModel', db_table='m2m_MiXeD_CaSe'),
-                ),
-            ],
-            options={
-                'db_table': 'migrations_MiXeD_CaSe_MoDel',
-            },
-        ),
-    ]
diff --git a/tests/migrations/test_fake_initial_case_insensitive/initial/__init__.py b/tests/migrations/test_fake_initial_case_insensitive/initial/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_graph.py b/tests/migrations/test_graph.py
deleted file mode 100644
index 10a5696f57..0000000000
--- a/tests/migrations/test_graph.py
+++ /dev/null
@@ -1,419 +0,0 @@
-from django.db.migrations.exceptions import (
-    CircularDependencyError, NodeNotFoundError,
-)
-from django.db.migrations.graph import DummyNode, MigrationGraph, Node
-from django.test import SimpleTestCase
-
-
-class GraphTests(SimpleTestCase):
-    """
-    Tests the digraph structure.
-    """
-
-    def test_simple_graph(self):
-        """
-        Tests a basic dependency graph:
-
-        app_a:  0001 <-- 0002 <--- 0003 <-- 0004
-                                 /
-        app_b:  0001 <-- 0002 <-/
-        """
-        # Build graph
-        graph = MigrationGraph()
-        graph.add_node(("app_a", "0001"), None)
-        graph.add_node(("app_a", "0002"), None)
-        graph.add_node(("app_a", "0003"), None)
-        graph.add_node(("app_a", "0004"), None)
-        graph.add_node(("app_b", "0001"), None)
-        graph.add_node(("app_b", "0002"), None)
-        graph.add_dependency("app_a.0004", ("app_a", "0004"), ("app_a", "0003"))
-        graph.add_dependency("app_a.0003", ("app_a", "0003"), ("app_a", "0002"))
-        graph.add_dependency("app_a.0002", ("app_a", "0002"), ("app_a", "0001"))
-        graph.add_dependency("app_a.0003", ("app_a", "0003"), ("app_b", "0002"))
-        graph.add_dependency("app_b.0002", ("app_b", "0002"), ("app_b", "0001"))
-        # Test root migration case
-        self.assertEqual(
-            graph.forwards_plan(("app_a", "0001")),
-            [('app_a', '0001')],
-        )
-        # Test branch B only
-        self.assertEqual(
-            graph.forwards_plan(("app_b", "0002")),
-            [("app_b", "0001"), ("app_b", "0002")],
-        )
-        # Test whole graph
-        self.assertEqual(
-            graph.forwards_plan(("app_a", "0004")),
-            [
-                ('app_b', '0001'), ('app_b', '0002'), ('app_a', '0001'),
-                ('app_a', '0002'), ('app_a', '0003'), ('app_a', '0004'),
-            ],
-        )
-        # Test reverse to b:0002
-        self.assertEqual(
-            graph.backwards_plan(("app_b", "0002")),
-            [('app_a', '0004'), ('app_a', '0003'), ('app_b', '0002')],
-        )
-        # Test roots and leaves
-        self.assertEqual(
-            graph.root_nodes(),
-            [('app_a', '0001'), ('app_b', '0001')],
-        )
-        self.assertEqual(
-            graph.leaf_nodes(),
-            [('app_a', '0004'), ('app_b', '0002')],
-        )
-
-    def test_complex_graph(self):
-        r"""
-        Tests a complex dependency graph:
-
-        app_a:  0001 <-- 0002 <--- 0003 <-- 0004
-                      \        \ /         /
-        app_b:  0001 <-\ 0002 <-X         /
-                      \          \       /
-        app_c:         \ 0001 <-- 0002 <-
-        """
-        # Build graph
-        graph = MigrationGraph()
-        graph.add_node(("app_a", "0001"), None)
-        graph.add_node(("app_a", "0002"), None)
-        graph.add_node(("app_a", "0003"), None)
-        graph.add_node(("app_a", "0004"), None)
-        graph.add_node(("app_b", "0001"), None)
-        graph.add_node(("app_b", "0002"), None)
-        graph.add_node(("app_c", "0001"), None)
-        graph.add_node(("app_c", "0002"), None)
-        graph.add_dependency("app_a.0004", ("app_a", "0004"), ("app_a", "0003"))
-        graph.add_dependency("app_a.0003", ("app_a", "0003"), ("app_a", "0002"))
-        graph.add_dependency("app_a.0002", ("app_a", "0002"), ("app_a", "0001"))
-        graph.add_dependency("app_a.0003", ("app_a", "0003"), ("app_b", "0002"))
-        graph.add_dependency("app_b.0002", ("app_b", "0002"), ("app_b", "0001"))
-        graph.add_dependency("app_a.0004", ("app_a", "0004"), ("app_c", "0002"))
-        graph.add_dependency("app_c.0002", ("app_c", "0002"), ("app_c", "0001"))
-        graph.add_dependency("app_c.0001", ("app_c", "0001"), ("app_b", "0001"))
-        graph.add_dependency("app_c.0002", ("app_c", "0002"), ("app_a", "0002"))
-        # Test branch C only
-        self.assertEqual(
-            graph.forwards_plan(("app_c", "0002")),
-            [('app_b', '0001'), ('app_c', '0001'), ('app_a', '0001'), ('app_a', '0002'), ('app_c', '0002')],
-        )
-        # Test whole graph
-        self.assertEqual(
-            graph.forwards_plan(("app_a", "0004")),
-            [
-                ('app_b', '0001'), ('app_c', '0001'), ('app_a', '0001'),
-                ('app_a', '0002'), ('app_c', '0002'), ('app_b', '0002'),
-                ('app_a', '0003'), ('app_a', '0004'),
-            ],
-        )
-        # Test reverse to b:0001
-        self.assertEqual(
-            graph.backwards_plan(("app_b", "0001")),
-            [
-                ('app_a', '0004'), ('app_c', '0002'), ('app_c', '0001'),
-                ('app_a', '0003'), ('app_b', '0002'), ('app_b', '0001'),
-            ],
-        )
-        # Test roots and leaves
-        self.assertEqual(
-            graph.root_nodes(),
-            [('app_a', '0001'), ('app_b', '0001'), ('app_c', '0001')],
-        )
-        self.assertEqual(
-            graph.leaf_nodes(),
-            [('app_a', '0004'), ('app_b', '0002'), ('app_c', '0002')],
-        )
-
-    def test_circular_graph(self):
-        """
-        Tests a circular dependency graph.
-        """
-        # Build graph
-        graph = MigrationGraph()
-        graph.add_node(("app_a", "0001"), None)
-        graph.add_node(("app_a", "0002"), None)
-        graph.add_node(("app_a", "0003"), None)
-        graph.add_node(("app_b", "0001"), None)
-        graph.add_node(("app_b", "0002"), None)
-        graph.add_dependency("app_a.0003", ("app_a", "0003"), ("app_a", "0002"))
-        graph.add_dependency("app_a.0002", ("app_a", "0002"), ("app_a", "0001"))
-        graph.add_dependency("app_a.0001", ("app_a", "0001"), ("app_b", "0002"))
-        graph.add_dependency("app_b.0002", ("app_b", "0002"), ("app_b", "0001"))
-        graph.add_dependency("app_b.0001", ("app_b", "0001"), ("app_a", "0003"))
-        # Test whole graph
-        with self.assertRaises(CircularDependencyError):
-            graph.ensure_not_cyclic()
-
-    def test_circular_graph_2(self):
-        graph = MigrationGraph()
-        graph.add_node(('A', '0001'), None)
-        graph.add_node(('C', '0001'), None)
-        graph.add_node(('B', '0001'), None)
-        graph.add_dependency('A.0001', ('A', '0001'), ('B', '0001'))
-        graph.add_dependency('B.0001', ('B', '0001'), ('A', '0001'))
-        graph.add_dependency('C.0001', ('C', '0001'), ('B', '0001'))
-
-        with self.assertRaises(CircularDependencyError):
-            graph.ensure_not_cyclic()
-
-    def test_iterative_dfs(self):
-        graph = MigrationGraph()
-        root = ("app_a", "1")
-        graph.add_node(root, None)
-        expected = [root]
-        for i in range(2, 750):
-            parent = ("app_a", str(i - 1))
-            child = ("app_a", str(i))
-            graph.add_node(child, None)
-            graph.add_dependency(str(i), child, parent)
-            expected.append(child)
-        leaf = expected[-1]
-
-        forwards_plan = graph.forwards_plan(leaf)
-        self.assertEqual(expected, forwards_plan)
-
-        backwards_plan = graph.backwards_plan(root)
-        self.assertEqual(expected[::-1], backwards_plan)
-
-    def test_iterative_dfs_complexity(self):
-        """
-        In a graph with merge migrations, iterative_dfs() traverses each node
-        only once even if there are multiple paths leading to it.
-        """
-        n = 50
-        graph = MigrationGraph()
-        for i in range(1, n + 1):
-            graph.add_node(('app_a', str(i)), None)
-            graph.add_node(('app_b', str(i)), None)
-            graph.add_node(('app_c', str(i)), None)
-        for i in range(1, n):
-            graph.add_dependency(None, ('app_b', str(i)), ('app_a', str(i)))
-            graph.add_dependency(None, ('app_c', str(i)), ('app_a', str(i)))
-            graph.add_dependency(None, ('app_a', str(i + 1)), ('app_b', str(i)))
-            graph.add_dependency(None, ('app_a', str(i + 1)), ('app_c', str(i)))
-        plan = graph.forwards_plan(('app_a', str(n)))
-        expected = [
-            (app, str(i))
-            for i in range(1, n)
-            for app in ['app_a', 'app_c', 'app_b']
-        ] + [('app_a', str(n))]
-        self.assertEqual(plan, expected)
-
-    def test_plan_invalid_node(self):
-        """
-        Tests for forwards/backwards_plan of nonexistent node.
-        """
-        graph = MigrationGraph()
-        message = "Node ('app_b', '0001') not a valid node"
-
-        with self.assertRaisesMessage(NodeNotFoundError, message):
-            graph.forwards_plan(("app_b", "0001"))
-
-        with self.assertRaisesMessage(NodeNotFoundError, message):
-            graph.backwards_plan(("app_b", "0001"))
-
-    def test_missing_parent_nodes(self):
-        """
-        Tests for missing parent nodes.
-        """
-        # Build graph
-        graph = MigrationGraph()
-        graph.add_node(("app_a", "0001"), None)
-        graph.add_node(("app_a", "0002"), None)
-        graph.add_node(("app_a", "0003"), None)
-        graph.add_node(("app_b", "0001"), None)
-        graph.add_dependency("app_a.0003", ("app_a", "0003"), ("app_a", "0002"))
-        graph.add_dependency("app_a.0002", ("app_a", "0002"), ("app_a", "0001"))
-        msg = "Migration app_a.0001 dependencies reference nonexistent parent node ('app_b', '0002')"
-        with self.assertRaisesMessage(NodeNotFoundError, msg):
-            graph.add_dependency("app_a.0001", ("app_a", "0001"), ("app_b", "0002"))
-
-    def test_missing_child_nodes(self):
-        """
-        Tests for missing child nodes.
-        """
-        # Build graph
-        graph = MigrationGraph()
-        graph.add_node(("app_a", "0001"), None)
-        msg = "Migration app_a.0002 dependencies reference nonexistent child node ('app_a', '0002')"
-        with self.assertRaisesMessage(NodeNotFoundError, msg):
-            graph.add_dependency("app_a.0002", ("app_a", "0002"), ("app_a", "0001"))
-
-    def test_validate_consistency_missing_parent(self):
-        graph = MigrationGraph()
-        graph.add_node(("app_a", "0001"), None)
-        graph.add_dependency("app_a.0001", ("app_a", "0001"), ("app_b", "0002"), skip_validation=True)
-        msg = "Migration app_a.0001 dependencies reference nonexistent parent node ('app_b', '0002')"
-        with self.assertRaisesMessage(NodeNotFoundError, msg):
-            graph.validate_consistency()
-
-    def test_validate_consistency_missing_child(self):
-        graph = MigrationGraph()
-        graph.add_node(("app_b", "0002"), None)
-        graph.add_dependency("app_b.0002", ("app_a", "0001"), ("app_b", "0002"), skip_validation=True)
-        msg = "Migration app_b.0002 dependencies reference nonexistent child node ('app_a', '0001')"
-        with self.assertRaisesMessage(NodeNotFoundError, msg):
-            graph.validate_consistency()
-
-    def test_validate_consistency_no_error(self):
-        graph = MigrationGraph()
-        graph.add_node(("app_a", "0001"), None)
-        graph.add_node(("app_b", "0002"), None)
-        graph.add_dependency("app_a.0001", ("app_a", "0001"), ("app_b", "0002"), skip_validation=True)
-        graph.validate_consistency()
-
-    def test_validate_consistency_dummy(self):
-        """
-        validate_consistency() raises an error if there's an isolated dummy
-        node.
-        """
-        msg = "app_a.0001 (req'd by app_b.0002) is missing!"
-        graph = MigrationGraph()
-        graph.add_dummy_node(
-            key=("app_a", "0001"),
-            origin="app_b.0002",
-            error_message=msg
-        )
-        with self.assertRaisesMessage(NodeNotFoundError, msg):
-            graph.validate_consistency()
-
-    def test_remove_replaced_nodes(self):
-        """
-        Replaced nodes are properly removed and dependencies remapped.
-        """
-        # Add some dummy nodes to be replaced.
-        graph = MigrationGraph()
-        graph.add_dummy_node(key=("app_a", "0001"), origin="app_a.0002", error_message="BAD!")
-        graph.add_dummy_node(key=("app_a", "0002"), origin="app_b.0001", error_message="BAD!")
-        graph.add_dependency("app_a.0002", ("app_a", "0002"), ("app_a", "0001"), skip_validation=True)
-        # Add some normal parent and child nodes to test dependency remapping.
-        graph.add_node(("app_c", "0001"), None)
-        graph.add_node(("app_b", "0001"), None)
-        graph.add_dependency("app_a.0001", ("app_a", "0001"), ("app_c", "0001"), skip_validation=True)
-        graph.add_dependency("app_b.0001", ("app_b", "0001"), ("app_a", "0002"), skip_validation=True)
-        # Try replacing before replacement node exists.
-        msg = (
-            "Unable to find replacement node ('app_a', '0001_squashed_0002'). It was either"
-            " never added to the migration graph, or has been removed."
-        )
-        with self.assertRaisesMessage(NodeNotFoundError, msg):
-            graph.remove_replaced_nodes(
-                replacement=("app_a", "0001_squashed_0002"),
-                replaced=[("app_a", "0001"), ("app_a", "0002")]
-            )
-        graph.add_node(("app_a", "0001_squashed_0002"), None)
-        # Ensure `validate_consistency()` still raises an error at this stage.
-        with self.assertRaisesMessage(NodeNotFoundError, "BAD!"):
-            graph.validate_consistency()
-        # Remove the dummy nodes.
-        graph.remove_replaced_nodes(
-            replacement=("app_a", "0001_squashed_0002"),
-            replaced=[("app_a", "0001"), ("app_a", "0002")]
-        )
-        # Ensure graph is now consistent and dependencies have been remapped
-        graph.validate_consistency()
-        parent_node = graph.node_map[("app_c", "0001")]
-        replacement_node = graph.node_map[("app_a", "0001_squashed_0002")]
-        child_node = graph.node_map[("app_b", "0001")]
-        self.assertIn(parent_node, replacement_node.parents)
-        self.assertIn(replacement_node, parent_node.children)
-        self.assertIn(child_node, replacement_node.children)
-        self.assertIn(replacement_node, child_node.parents)
-
-    def test_remove_replacement_node(self):
-        """
-        A replacement node is properly removed and child dependencies remapped.
-        We assume parent dependencies are already correct.
-        """
-        # Add some dummy nodes to be replaced.
-        graph = MigrationGraph()
-        graph.add_node(("app_a", "0001"), None)
-        graph.add_node(("app_a", "0002"), None)
-        graph.add_dependency("app_a.0002", ("app_a", "0002"), ("app_a", "0001"))
-        # Try removing replacement node before replacement node exists.
-        msg = (
-            "Unable to remove replacement node ('app_a', '0001_squashed_0002'). It was"
-            " either never added to the migration graph, or has been removed already."
-        )
-        with self.assertRaisesMessage(NodeNotFoundError, msg):
-            graph.remove_replacement_node(
-                replacement=("app_a", "0001_squashed_0002"),
-                replaced=[("app_a", "0001"), ("app_a", "0002")]
-            )
-        graph.add_node(("app_a", "0001_squashed_0002"), None)
-        # Add a child node to test dependency remapping.
-        graph.add_node(("app_b", "0001"), None)
-        graph.add_dependency("app_b.0001", ("app_b", "0001"), ("app_a", "0001_squashed_0002"))
-        # Remove the replacement node.
-        graph.remove_replacement_node(
-            replacement=("app_a", "0001_squashed_0002"),
-            replaced=[("app_a", "0001"), ("app_a", "0002")]
-        )
-        # Ensure graph is consistent and child dependency has been remapped
-        graph.validate_consistency()
-        replaced_node = graph.node_map[("app_a", "0002")]
-        child_node = graph.node_map[("app_b", "0001")]
-        self.assertIn(child_node, replaced_node.children)
-        self.assertIn(replaced_node, child_node.parents)
-        # Ensure child dependency hasn't also gotten remapped to the other replaced node.
-        other_replaced_node = graph.node_map[("app_a", "0001")]
-        self.assertNotIn(child_node, other_replaced_node.children)
-        self.assertNotIn(other_replaced_node, child_node.parents)
-
-    def test_infinite_loop(self):
-        """
-        Tests a complex dependency graph:
-
-        app_a:        0001 <-
-                             \
-        app_b:        0001 <- x 0002 <-
-                       /               \
-        app_c:   0001<-  <------------- x 0002
-
-        And apply squashing on app_c.
-        """
-        graph = MigrationGraph()
-
-        graph.add_node(("app_a", "0001"), None)
-        graph.add_node(("app_b", "0001"), None)
-        graph.add_node(("app_b", "0002"), None)
-        graph.add_node(("app_c", "0001_squashed_0002"), None)
-
-        graph.add_dependency("app_b.0001", ("app_b", "0001"), ("app_c", "0001_squashed_0002"))
-        graph.add_dependency("app_b.0002", ("app_b", "0002"), ("app_a", "0001"))
-        graph.add_dependency("app_b.0002", ("app_b", "0002"), ("app_b", "0001"))
-        graph.add_dependency("app_c.0001_squashed_0002", ("app_c", "0001_squashed_0002"), ("app_b", "0002"))
-
-        with self.assertRaises(CircularDependencyError):
-            graph.ensure_not_cyclic()
-
-    def test_stringify(self):
-        graph = MigrationGraph()
-        self.assertEqual(str(graph), "Graph: 0 nodes, 0 edges")
-
-        graph.add_node(("app_a", "0001"), None)
-        graph.add_node(("app_a", "0002"), None)
-        graph.add_node(("app_a", "0003"), None)
-        graph.add_node(("app_b", "0001"), None)
-        graph.add_node(("app_b", "0002"), None)
-        graph.add_dependency("app_a.0002", ("app_a", "0002"), ("app_a", "0001"))
-        graph.add_dependency("app_a.0003", ("app_a", "0003"), ("app_a", "0002"))
-        graph.add_dependency("app_a.0003", ("app_a", "0003"), ("app_b", "0002"))
-
-        self.assertEqual(str(graph), "Graph: 5 nodes, 3 edges")
-        self.assertEqual(repr(graph), "<MigrationGraph: nodes=5, edges=3>")
-
-
-class NodeTests(SimpleTestCase):
-    def test_node_repr(self):
-        node = Node(('app_a', '0001'))
-        self.assertEqual(repr(node), "<Node: ('app_a', '0001')>")
-
-    def test_dummynode_repr(self):
-        node = DummyNode(
-            key=('app_a', '0001'),
-            origin='app_a.0001',
-            error_message='x is missing',
-        )
-        self.assertEqual(repr(node), "<DummyNode: ('app_a', '0001')>")
diff --git a/tests/migrations/test_loader.py b/tests/migrations/test_loader.py
deleted file mode 100644
index ce2f209188..0000000000
--- a/tests/migrations/test_loader.py
+++ /dev/null
@@ -1,548 +0,0 @@
-import compileall
-import os
-
-from django.db import connection, connections
-from django.db.migrations.exceptions import (
-    AmbiguityError, InconsistentMigrationHistory, NodeNotFoundError,
-)
-from django.db.migrations.loader import MigrationLoader
-from django.db.migrations.recorder import MigrationRecorder
-from django.test import TestCase, modify_settings, override_settings
-
-from .test_base import MigrationTestBase
-
-
-class RecorderTests(TestCase):
-    """
-    Tests recording migrations as applied or not.
-    """
-    databases = {'default', 'other'}
-
-    def test_apply(self):
-        """
-        Tests marking migrations as applied/unapplied.
-        """
-        recorder = MigrationRecorder(connection)
-        self.assertEqual(
-            {(x, y) for (x, y) in recorder.applied_migrations() if x == "myapp"},
-            set(),
-        )
-        recorder.record_applied("myapp", "0432_ponies")
-        self.assertEqual(
-            {(x, y) for (x, y) in recorder.applied_migrations() if x == "myapp"},
-            {("myapp", "0432_ponies")},
-        )
-        # That should not affect records of another database
-        recorder_other = MigrationRecorder(connections['other'])
-        self.assertEqual(
-            {(x, y) for (x, y) in recorder_other.applied_migrations() if x == "myapp"},
-            set(),
-        )
-        recorder.record_unapplied("myapp", "0432_ponies")
-        self.assertEqual(
-            {(x, y) for (x, y) in recorder.applied_migrations() if x == "myapp"},
-            set(),
-        )
-
-
-class LoaderTests(TestCase):
-    """
-    Tests the disk and database loader, and running through migrations
-    in memory.
-    """
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
-    @modify_settings(INSTALLED_APPS={'append': 'basic'})
-    def test_load(self):
-        """
-        Makes sure the loader can load the migrations for the test apps,
-        and then render them out to a new Apps.
-        """
-        # Load and test the plan
-        migration_loader = MigrationLoader(connection)
-        self.assertEqual(
-            migration_loader.graph.forwards_plan(("migrations", "0002_second")),
-            [
-                ("migrations", "0001_initial"),
-                ("migrations", "0002_second"),
-            ],
-        )
-        # Now render it out!
-        project_state = migration_loader.project_state(("migrations", "0002_second"))
-        self.assertEqual(len(project_state.models), 2)
-
-        author_state = project_state.models["migrations", "author"]
-        self.assertEqual(
-            list(author_state.fields),
-            ["id", "name", "slug", "age", "rating"]
-        )
-
-        book_state = project_state.models["migrations", "book"]
-        self.assertEqual(list(book_state.fields), ['id', 'author'])
-
-        # Ensure we've included unmigrated apps in there too
-        self.assertIn("basic", project_state.real_apps)
-
-    @override_settings(MIGRATION_MODULES={
-        'migrations': 'migrations.test_migrations',
-        'migrations2': 'migrations2.test_migrations_2',
-    })
-    @modify_settings(INSTALLED_APPS={'append': 'migrations2'})
-    def test_plan_handles_repeated_migrations(self):
-        """
-        _generate_plan() doesn't readd migrations already in the plan (#29180).
-        """
-        migration_loader = MigrationLoader(connection)
-        nodes = [('migrations', '0002_second'), ('migrations2', '0001_initial')]
-        self.assertEqual(
-            migration_loader.graph._generate_plan(nodes, at_end=True),
-            [('migrations', '0001_initial'), ('migrations', '0002_second'), ('migrations2', '0001_initial')]
-        )
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_unmigdep"})
-    def test_load_unmigrated_dependency(self):
-        """
-        Makes sure the loader can load migrations with a dependency on an unmigrated app.
-        """
-        # Load and test the plan
-        migration_loader = MigrationLoader(connection)
-        self.assertEqual(
-            migration_loader.graph.forwards_plan(("migrations", "0001_initial")),
-            [
-                ('contenttypes', '0001_initial'),
-                ('auth', '0001_initial'),
-                ("migrations", "0001_initial"),
-            ],
-        )
-        # Now render it out!
-        project_state = migration_loader.project_state(("migrations", "0001_initial"))
-        self.assertEqual(len([m for a, m in project_state.models if a == "migrations"]), 1)
-
-        book_state = project_state.models["migrations", "book"]
-        self.assertEqual(list(book_state.fields), ['id', 'user'])
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_run_before"})
-    def test_run_before(self):
-        """
-        Makes sure the loader uses Migration.run_before.
-        """
-        # Load and test the plan
-        migration_loader = MigrationLoader(connection)
-        self.assertEqual(
-            migration_loader.graph.forwards_plan(("migrations", "0002_second")),
-            [
-                ("migrations", "0001_initial"),
-                ("migrations", "0003_third"),
-                ("migrations", "0002_second"),
-            ],
-        )
-
-    @override_settings(MIGRATION_MODULES={
-        "migrations": "migrations.test_migrations_first",
-        "migrations2": "migrations2.test_migrations_2_first",
-    })
-    @modify_settings(INSTALLED_APPS={'append': 'migrations2'})
-    def test_first(self):
-        """
-        Makes sure the '__first__' migrations build correctly.
-        """
-        migration_loader = MigrationLoader(connection)
-        self.assertEqual(
-            migration_loader.graph.forwards_plan(("migrations", "second")),
-            [
-                ("migrations", "thefirst"),
-                ("migrations2", "0001_initial"),
-                ("migrations2", "0002_second"),
-                ("migrations", "second"),
-            ],
-        )
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations"})
-    def test_name_match(self):
-        "Tests prefix name matching"
-        migration_loader = MigrationLoader(connection)
-        self.assertEqual(
-            migration_loader.get_migration_by_prefix("migrations", "0001").name,
-            "0001_initial",
-        )
-        with self.assertRaises(AmbiguityError):
-            migration_loader.get_migration_by_prefix("migrations", "0")
-        with self.assertRaises(KeyError):
-            migration_loader.get_migration_by_prefix("migrations", "blarg")
-
-    def test_load_import_error(self):
-        with override_settings(MIGRATION_MODULES={"migrations": "import_error_package"}):
-            with self.assertRaises(ImportError):
-                MigrationLoader(connection)
-
-    def test_load_module_file(self):
-        with override_settings(MIGRATION_MODULES={"migrations": "migrations.faulty_migrations.file"}):
-            loader = MigrationLoader(connection)
-            self.assertIn(
-                "migrations", loader.unmigrated_apps,
-                "App with migrations module file not in unmigrated apps."
-            )
-
-    def test_load_empty_dir(self):
-        with override_settings(MIGRATION_MODULES={"migrations": "migrations.faulty_migrations.namespace"}):
-            loader = MigrationLoader(connection)
-            self.assertIn(
-                "migrations", loader.unmigrated_apps,
-                "App missing __init__.py in migrations module not in unmigrated apps."
-            )
-
-    @override_settings(
-        INSTALLED_APPS=['migrations.migrations_test_apps.migrated_app'],
-    )
-    def test_marked_as_migrated(self):
-        """
-        Undefined MIGRATION_MODULES implies default migration module.
-        """
-        migration_loader = MigrationLoader(connection)
-        self.assertEqual(migration_loader.migrated_apps, {'migrated_app'})
-        self.assertEqual(migration_loader.unmigrated_apps, set())
-
-    @override_settings(
-        INSTALLED_APPS=['migrations.migrations_test_apps.migrated_app'],
-        MIGRATION_MODULES={"migrated_app": None},
-    )
-    def test_marked_as_unmigrated(self):
-        """
-        MIGRATION_MODULES allows disabling of migrations for a particular app.
-        """
-        migration_loader = MigrationLoader(connection)
-        self.assertEqual(migration_loader.migrated_apps, set())
-        self.assertEqual(migration_loader.unmigrated_apps, {'migrated_app'})
-
-    @override_settings(
-        INSTALLED_APPS=['migrations.migrations_test_apps.migrated_app'],
-        MIGRATION_MODULES={'migrated_app': 'missing-module'},
-    )
-    def test_explicit_missing_module(self):
-        """
-        If a MIGRATION_MODULES override points to a missing module, the error
-        raised during the importation attempt should be propagated unless
-        `ignore_no_migrations=True`.
-        """
-        with self.assertRaisesMessage(ImportError, 'missing-module'):
-            migration_loader = MigrationLoader(connection)
-        migration_loader = MigrationLoader(connection, ignore_no_migrations=True)
-        self.assertEqual(migration_loader.migrated_apps, set())
-        self.assertEqual(migration_loader.unmigrated_apps, {'migrated_app'})
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed"})
-    def test_loading_squashed(self):
-        "Tests loading a squashed migration"
-        migration_loader = MigrationLoader(connection)
-        recorder = MigrationRecorder(connection)
-        self.addCleanup(recorder.flush)
-        # Loading with nothing applied should just give us the one node
-        self.assertEqual(
-            len([x for x in migration_loader.graph.nodes if x[0] == "migrations"]),
-            1,
-        )
-        # However, fake-apply one migration and it should now use the old two
-        recorder.record_applied("migrations", "0001_initial")
-        migration_loader.build_graph()
-        self.assertEqual(
-            len([x for x in migration_loader.graph.nodes if x[0] == "migrations"]),
-            2,
-        )
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed_complex"})
-    def test_loading_squashed_complex(self):
-        "Tests loading a complex set of squashed migrations"
-
-        loader = MigrationLoader(connection)
-        recorder = MigrationRecorder(connection)
-        self.addCleanup(recorder.flush)
-
-        def num_nodes():
-            plan = set(loader.graph.forwards_plan(('migrations', '7_auto')))
-            return len(plan - loader.applied_migrations.keys())
-
-        # Empty database: use squashed migration
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 5)
-
-        # Starting at 1 or 2 should use the squashed migration too
-        recorder.record_applied("migrations", "1_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 4)
-
-        recorder.record_applied("migrations", "2_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 3)
-
-        # However, starting at 3 to 5 cannot use the squashed migration
-        recorder.record_applied("migrations", "3_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 4)
-
-        recorder.record_applied("migrations", "4_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 3)
-
-        # Starting at 5 to 7 we are passed the squashed migrations
-        recorder.record_applied("migrations", "5_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 2)
-
-        recorder.record_applied("migrations", "6_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 1)
-
-        recorder.record_applied("migrations", "7_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 0)
-
-    @override_settings(MIGRATION_MODULES={
-        "app1": "migrations.test_migrations_squashed_complex_multi_apps.app1",
-        "app2": "migrations.test_migrations_squashed_complex_multi_apps.app2",
-    })
-    @modify_settings(INSTALLED_APPS={'append': [
-        "migrations.test_migrations_squashed_complex_multi_apps.app1",
-        "migrations.test_migrations_squashed_complex_multi_apps.app2",
-    ]})
-    def test_loading_squashed_complex_multi_apps(self):
-        loader = MigrationLoader(connection)
-        loader.build_graph()
-
-        plan = set(loader.graph.forwards_plan(('app1', '4_auto')))
-        expected_plan = {
-            ('app1', '1_auto'),
-            ('app2', '1_squashed_2'),
-            ('app1', '2_squashed_3'),
-            ('app1', '4_auto'),
-        }
-        self.assertEqual(plan, expected_plan)
-
-    @override_settings(MIGRATION_MODULES={
-        "app1": "migrations.test_migrations_squashed_complex_multi_apps.app1",
-        "app2": "migrations.test_migrations_squashed_complex_multi_apps.app2",
-    })
-    @modify_settings(INSTALLED_APPS={'append': [
-        "migrations.test_migrations_squashed_complex_multi_apps.app1",
-        "migrations.test_migrations_squashed_complex_multi_apps.app2",
-    ]})
-    def test_loading_squashed_complex_multi_apps_partially_applied(self):
-        loader = MigrationLoader(connection)
-        recorder = MigrationRecorder(connection)
-        recorder.record_applied('app1', '1_auto')
-        recorder.record_applied('app1', '2_auto')
-        loader.build_graph()
-
-        plan = set(loader.graph.forwards_plan(('app1', '4_auto')))
-        plan = plan - loader.applied_migrations.keys()
-        expected_plan = {
-            ('app2', '1_squashed_2'),
-            ('app1', '3_auto'),
-            ('app1', '4_auto'),
-        }
-
-        self.assertEqual(plan, expected_plan)
-
-    @override_settings(MIGRATION_MODULES={"migrations": "migrations.test_migrations_squashed_erroneous"})
-    def test_loading_squashed_erroneous(self):
-        "Tests loading a complex but erroneous set of squashed migrations"
-
-        loader = MigrationLoader(connection)
-        recorder = MigrationRecorder(connection)
-        self.addCleanup(recorder.flush)
-
-        def num_nodes():
-            plan = set(loader.graph.forwards_plan(('migrations', '7_auto')))
-            return len(plan - loader.applied_migrations.keys())
-
-        # Empty database: use squashed migration
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 5)
-
-        # Starting at 1 or 2 should use the squashed migration too
-        recorder.record_applied("migrations", "1_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 4)
-
-        recorder.record_applied("migrations", "2_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 3)
-
-        # However, starting at 3 or 4, nonexistent migrations would be needed.
-        msg = ("Migration migrations.6_auto depends on nonexistent node ('migrations', '5_auto'). "
-               "Django tried to replace migration migrations.5_auto with any of "
-               "[migrations.3_squashed_5] but wasn't able to because some of the replaced "
-               "migrations are already applied.")
-
-        recorder.record_applied("migrations", "3_auto")
-        with self.assertRaisesMessage(NodeNotFoundError, msg):
-            loader.build_graph()
-
-        recorder.record_applied("migrations", "4_auto")
-        with self.assertRaisesMessage(NodeNotFoundError, msg):
-            loader.build_graph()
-
-        # Starting at 5 to 7 we are passed the squashed migrations
-        recorder.record_applied("migrations", "5_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 2)
-
-        recorder.record_applied("migrations", "6_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 1)
-
-        recorder.record_applied("migrations", "7_auto")
-        loader.build_graph()
-        self.assertEqual(num_nodes(), 0)
-
-    @override_settings(
-        MIGRATION_MODULES={'migrations': 'migrations.test_migrations'},
-        INSTALLED_APPS=['migrations'],
-    )
-    def test_check_consistent_history(self):
-        loader = MigrationLoader(connection=None)
-        loader.check_consistent_history(connection)
-        recorder = MigrationRecorder(connection)
-        recorder.record_applied('migrations', '0002_second')
-        msg = (
-            "Migration migrations.0002_second is applied before its dependency "
-            "migrations.0001_initial on database 'default'."
-        )
-        with self.assertRaisesMessage(InconsistentMigrationHistory, msg):
-            loader.check_consistent_history(connection)
-
-    @override_settings(
-        MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed_extra'},
-        INSTALLED_APPS=['migrations'],
-    )
-    def test_check_consistent_history_squashed(self):
-        """
-        MigrationLoader.check_consistent_history() should ignore unapplied
-        squashed migrations that have all of their `replaces` applied.
-        """
-        loader = MigrationLoader(connection=None)
-        recorder = MigrationRecorder(connection)
-        recorder.record_applied('migrations', '0001_initial')
-        recorder.record_applied('migrations', '0002_second')
-        loader.check_consistent_history(connection)
-        recorder.record_applied('migrations', '0003_third')
-        loader.check_consistent_history(connection)
-
-    @override_settings(MIGRATION_MODULES={
-        "app1": "migrations.test_migrations_squashed_ref_squashed.app1",
-        "app2": "migrations.test_migrations_squashed_ref_squashed.app2",
-    })
-    @modify_settings(INSTALLED_APPS={'append': [
-        "migrations.test_migrations_squashed_ref_squashed.app1",
-        "migrations.test_migrations_squashed_ref_squashed.app2",
-    ]})
-    def test_loading_squashed_ref_squashed(self):
-        "Tests loading a squashed migration with a new migration referencing it"
-        r"""
-        The sample migrations are structured like this:
-
-        app_1       1 --> 2 ---------------------*--> 3        *--> 4
-                     \                          /             /
-                      *-------------------*----/--> 2_sq_3 --*
-                       \                 /    /
-        =============== \ ============= / == / ======================
-        app_2            *--> 1_sq_2 --*    /
-                          \                /
-                           *--> 1 --> 2 --*
-
-        Where 2_sq_3 is a replacing migration for 2 and 3 in app_1,
-        as 1_sq_2 is a replacing migration for 1 and 2 in app_2.
-        """
-
-        loader = MigrationLoader(connection)
-        recorder = MigrationRecorder(connection)
-        self.addCleanup(recorder.flush)
-
-        # Load with nothing applied: both migrations squashed.
-        loader.build_graph()
-        plan = set(loader.graph.forwards_plan(('app1', '4_auto')))
-        plan = plan - loader.applied_migrations.keys()
-        expected_plan = {
-            ('app1', '1_auto'),
-            ('app2', '1_squashed_2'),
-            ('app1', '2_squashed_3'),
-            ('app1', '4_auto'),
-        }
-        self.assertEqual(plan, expected_plan)
-
-        # Fake-apply a few from app1: unsquashes migration in app1.
-        recorder.record_applied('app1', '1_auto')
-        recorder.record_applied('app1', '2_auto')
-        loader.build_graph()
-        plan = set(loader.graph.forwards_plan(('app1', '4_auto')))
-        plan = plan - loader.applied_migrations.keys()
-        expected_plan = {
-            ('app2', '1_squashed_2'),
-            ('app1', '3_auto'),
-            ('app1', '4_auto'),
-        }
-        self.assertEqual(plan, expected_plan)
-
-        # Fake-apply one from app2: unsquashes migration in app2 too.
-        recorder.record_applied('app2', '1_auto')
-        loader.build_graph()
-        plan = set(loader.graph.forwards_plan(('app1', '4_auto')))
-        plan = plan - loader.applied_migrations.keys()
-        expected_plan = {
-            ('app2', '2_auto'),
-            ('app1', '3_auto'),
-            ('app1', '4_auto'),
-        }
-        self.assertEqual(plan, expected_plan)
-
-    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_private'})
-    def test_ignore_files(self):
-        """Files prefixed with underscore, tilde, or dot aren't loaded."""
-        loader = MigrationLoader(connection)
-        loader.load_disk()
-        migrations = [name for app, name in loader.disk_migrations if app == 'migrations']
-        self.assertEqual(migrations, ['0001_initial'])
-
-    @override_settings(
-        MIGRATION_MODULES={'migrations': 'migrations.test_migrations_namespace_package'},
-    )
-    def test_loading_namespace_package(self):
-        """Migration directories without an __init__.py file are loaded."""
-        migration_loader = MigrationLoader(connection)
-        self.assertEqual(
-            migration_loader.graph.forwards_plan(('migrations', '0001_initial')),
-            [('migrations', '0001_initial')],
-        )
-
-
-class PycLoaderTests(MigrationTestBase):
-
-    def test_valid(self):
-        """
-        To support frozen environments, MigrationLoader loads .pyc migrations.
-        """
-        with self.temporary_migration_module(module='migrations.test_migrations') as migration_dir:
-            # Compile .py files to .pyc files and delete .py files.
-            compileall.compile_dir(migration_dir, force=True, quiet=1, legacy=True)
-            for name in os.listdir(migration_dir):
-                if name.endswith('.py'):
-                    os.remove(os.path.join(migration_dir, name))
-            loader = MigrationLoader(connection)
-            self.assertIn(('migrations', '0001_initial'), loader.disk_migrations)
-
-    def test_invalid(self):
-        """
-        MigrationLoader reraises ImportErrors caused by "bad magic number" pyc
-        files with a more helpful message.
-        """
-        with self.temporary_migration_module(module='migrations.test_migrations_bad_pyc') as migration_dir:
-            # The -tpl suffix is to avoid the pyc exclusion in MANIFEST.in.
-            os.rename(
-                os.path.join(migration_dir, '0001_initial.pyc-tpl'),
-                os.path.join(migration_dir, '0001_initial.pyc'),
-            )
-            msg = (
-                r"Couldn't import '\w+.migrations.0001_initial' as it appears "
-                "to be a stale .pyc file."
-            )
-            with self.assertRaisesRegex(ImportError, msg):
-                MigrationLoader(connection)
diff --git a/tests/migrations/test_migrations/0001_initial.py b/tests/migrations/test_migrations/0001_initial.py
deleted file mode 100644
index 259568e8d4..0000000000
--- a/tests/migrations/test_migrations/0001_initial.py
+++ /dev/null
@@ -1,35 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    initial = True
-
-    operations = [
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        ),
-        migrations.AddField(
-            model_name='tribble',
-            name='bool',
-            field=models.BooleanField(default=False),
-        ),
-        migrations.AlterUniqueTogether(
-            name='author',
-            unique_together={('name', 'slug')},
-        ),
-    ]
diff --git a/tests/migrations/test_migrations/0002_second.py b/tests/migrations/test_migrations/0002_second.py
deleted file mode 100644
index 71c300cead..0000000000
--- a/tests/migrations/test_migrations/0002_second.py
+++ /dev/null
@@ -1,26 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ("migrations", "0001_initial"),
-    ]
-
-    operations = [
-
-        migrations.DeleteModel("Tribble"),
-
-        migrations.RemoveField("Author", "silly_field"),
-
-        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations/__init__.py b/tests/migrations/test_migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_atomic_operation/0001_initial.py b/tests/migrations/test_migrations_atomic_operation/0001_initial.py
deleted file mode 100644
index 47ae3df5e9..0000000000
--- a/tests/migrations/test_migrations_atomic_operation/0001_initial.py
+++ /dev/null
@@ -1,22 +0,0 @@
-from django.db import migrations, models
-
-
-def raise_error(apps, schema_editor):
-    # Test atomic operation in non-atomic migration is wrapped in transaction
-    Editor = apps.get_model('migrations', 'Editor')
-    Editor.objects.create(name='Test Editor')
-    raise RuntimeError('Abort migration')
-
-
-class Migration(migrations.Migration):
-    atomic = False
-
-    operations = [
-        migrations.CreateModel(
-            "Editor",
-            [
-                ("name", models.CharField(primary_key=True, max_length=255)),
-            ],
-        ),
-        migrations.RunPython(raise_error, reverse_code=raise_error, atomic=True),
-    ]
diff --git a/tests/migrations/test_migrations_atomic_operation/__init__.py b/tests/migrations/test_migrations_atomic_operation/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_backwards_deps_1/0001_initial.py b/tests/migrations/test_migrations_backwards_deps_1/0001_initial.py
deleted file mode 100644
index de3ea27173..0000000000
--- a/tests/migrations/test_migrations_backwards_deps_1/0001_initial.py
+++ /dev/null
@@ -1,5 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    operations = []
diff --git a/tests/migrations/test_migrations_backwards_deps_1/0002_second.py b/tests/migrations/test_migrations_backwards_deps_1/0002_second.py
deleted file mode 100644
index 6eb831e061..0000000000
--- a/tests/migrations/test_migrations_backwards_deps_1/0002_second.py
+++ /dev/null
@@ -1,6 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    dependencies = [('migrations', '0001_initial')]
-    operations = []
diff --git a/tests/migrations/test_migrations_bad_pyc/0001_initial.pyc-tpl b/tests/migrations/test_migrations_bad_pyc/0001_initial.pyc-tpl
deleted file mode 100644
index 07854f4aeb..0000000000
Binary files a/tests/migrations/test_migrations_bad_pyc/0001_initial.pyc-tpl and /dev/null differ
diff --git a/tests/migrations/test_migrations_bad_pyc/__init__.py b/tests/migrations/test_migrations_bad_pyc/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_clashing_prefix/__init__.py b/tests/migrations/test_migrations_clashing_prefix/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_clashing_prefix/a.py b/tests/migrations/test_migrations_clashing_prefix/a.py
deleted file mode 100644
index bd613aa95e..0000000000
--- a/tests/migrations/test_migrations_clashing_prefix/a.py
+++ /dev/null
@@ -1,5 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    pass
diff --git a/tests/migrations/test_migrations_clashing_prefix/ab.py b/tests/migrations/test_migrations_clashing_prefix/ab.py
deleted file mode 100644
index 54f8924bac..0000000000
--- a/tests/migrations/test_migrations_clashing_prefix/ab.py
+++ /dev/null
@@ -1,5 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    dependencies = [('migrations', 'a')]
diff --git a/tests/migrations/test_migrations_conflict/0001_initial.py b/tests/migrations/test_migrations_conflict/0001_initial.py
deleted file mode 100644
index 344bebdfe3..0000000000
--- a/tests/migrations/test_migrations_conflict/0001_initial.py
+++ /dev/null
@@ -1,27 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_conflict/0002_conflicting_second.py b/tests/migrations/test_migrations_conflict/0002_conflicting_second.py
deleted file mode 100644
index 15ea1f063a..0000000000
--- a/tests/migrations/test_migrations_conflict/0002_conflicting_second.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "0001_initial")]
-
-    operations = [
-
-        migrations.CreateModel(
-            "Something",
-            [
-                ("id", models.AutoField(primary_key=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_conflict/0002_second.py b/tests/migrations/test_migrations_conflict/0002_second.py
deleted file mode 100644
index 60a6999ee4..0000000000
--- a/tests/migrations/test_migrations_conflict/0002_second.py
+++ /dev/null
@@ -1,24 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "0001_initial")]
-
-    operations = [
-
-        migrations.DeleteModel("Tribble"),
-
-        migrations.RemoveField("Author", "silly_field"),
-
-        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_conflict/__init__.py b/tests/migrations/test_migrations_conflict/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_custom_user/0001_initial.py b/tests/migrations/test_migrations_custom_user/0001_initial.py
deleted file mode 100644
index 250aa9f51b..0000000000
--- a/tests/migrations/test_migrations_custom_user/0001_initial.py
+++ /dev/null
@@ -1,28 +0,0 @@
-from django.conf import settings
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-    dependencies = [
-        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
-    ]
-
-    operations = [
-
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-            ],
-        ),
-
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey(settings.AUTH_USER_MODEL, models.CASCADE, to_field="id")),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_custom_user/__init__.py b/tests/migrations/test_migrations_custom_user/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_empty/__init__.py b/tests/migrations/test_migrations_empty/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_fake_split_initial/0001_initial.py b/tests/migrations/test_migrations_fake_split_initial/0001_initial.py
deleted file mode 100644
index ef17e329ce..0000000000
--- a/tests/migrations/test_migrations_fake_split_initial/0001_initial.py
+++ /dev/null
@@ -1,30 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    initial = True
-
-    operations = [
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        ),
-        migrations.AlterUniqueTogether(
-            name='author',
-            unique_together={('name', 'slug')},
-        ),
-    ]
diff --git a/tests/migrations/test_migrations_fake_split_initial/0002_second.py b/tests/migrations/test_migrations_fake_split_initial/0002_second.py
deleted file mode 100644
index 6e9b28efb4..0000000000
--- a/tests/migrations/test_migrations_fake_split_initial/0002_second.py
+++ /dev/null
@@ -1,21 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    initial = True
-
-    dependencies = [
-        ("migrations", "0001_initial"),
-    ]
-
-    operations = [
-        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/test_migrations_fake_split_initial/__init__.py b/tests/migrations/test_migrations_fake_split_initial/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_first/__init__.py b/tests/migrations/test_migrations_first/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_first/second.py b/tests/migrations/test_migrations_first/second.py
deleted file mode 100644
index e4cf995dcc..0000000000
--- a/tests/migrations/test_migrations_first/second.py
+++ /dev/null
@@ -1,27 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ("migrations", "thefirst"),
-        ("migrations2", "0002_second"),
-    ]
-
-    operations = [
-
-        migrations.DeleteModel("Tribble"),
-
-        migrations.RemoveField("Author", "silly_field"),
-
-        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_first/thefirst.py b/tests/migrations/test_migrations_first/thefirst.py
deleted file mode 100644
index 344bebdfe3..0000000000
--- a/tests/migrations/test_migrations_first/thefirst.py
+++ /dev/null
@@ -1,27 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_initial_false/0001_not_initial.py b/tests/migrations/test_migrations_initial_false/0001_not_initial.py
deleted file mode 100644
index 388c3b61e4..0000000000
--- a/tests/migrations/test_migrations_initial_false/0001_not_initial.py
+++ /dev/null
@@ -1,30 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    initial = False
-
-    operations = [
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        ),
-        migrations.AlterUniqueTogether(
-            name='author',
-            unique_together={('name', 'slug')},
-        ),
-    ]
diff --git a/tests/migrations/test_migrations_initial_false/__init__.py b/tests/migrations/test_migrations_initial_false/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_namespace_package/0001_initial.py b/tests/migrations/test_migrations_namespace_package/0001_initial.py
deleted file mode 100644
index 34c73ea086..0000000000
--- a/tests/migrations/test_migrations_namespace_package/0001_initial.py
+++ /dev/null
@@ -1,15 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-    initial = True
-
-    operations = [
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/test_migrations_no_ancestor/0001_initial.py b/tests/migrations/test_migrations_no_ancestor/0001_initial.py
deleted file mode 100644
index 344bebdfe3..0000000000
--- a/tests/migrations/test_migrations_no_ancestor/0001_initial.py
+++ /dev/null
@@ -1,27 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_no_ancestor/0002_conflicting_second.py b/tests/migrations/test_migrations_no_ancestor/0002_conflicting_second.py
deleted file mode 100644
index 71625a7116..0000000000
--- a/tests/migrations/test_migrations_no_ancestor/0002_conflicting_second.py
+++ /dev/null
@@ -1,25 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-    ]
-
-    operations = [
-
-        migrations.DeleteModel("Tribble"),
-
-        migrations.RemoveField("Author", "silly_field"),
-
-        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_no_ancestor/0002_second.py b/tests/migrations/test_migrations_no_ancestor/0002_second.py
deleted file mode 100644
index 71c300cead..0000000000
--- a/tests/migrations/test_migrations_no_ancestor/0002_second.py
+++ /dev/null
@@ -1,26 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ("migrations", "0001_initial"),
-    ]
-
-    operations = [
-
-        migrations.DeleteModel("Tribble"),
-
-        migrations.RemoveField("Author", "silly_field"),
-
-        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_no_ancestor/__init__.py b/tests/migrations/test_migrations_no_ancestor/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_no_changes/0001_initial.py b/tests/migrations/test_migrations_no_changes/0001_initial.py
deleted file mode 100644
index 344bebdfe3..0000000000
--- a/tests/migrations/test_migrations_no_changes/0001_initial.py
+++ /dev/null
@@ -1,27 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_no_changes/0002_second.py b/tests/migrations/test_migrations_no_changes/0002_second.py
deleted file mode 100644
index 71c300cead..0000000000
--- a/tests/migrations/test_migrations_no_changes/0002_second.py
+++ /dev/null
@@ -1,26 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ("migrations", "0001_initial"),
-    ]
-
-    operations = [
-
-        migrations.DeleteModel("Tribble"),
-
-        migrations.RemoveField("Author", "silly_field"),
-
-        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_no_changes/0003_third.py b/tests/migrations/test_migrations_no_changes/0003_third.py
deleted file mode 100644
index 89b3bc030c..0000000000
--- a/tests/migrations/test_migrations_no_changes/0003_third.py
+++ /dev/null
@@ -1,33 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('migrations', '0002_second'),
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='ModelWithCustomBase',
-            fields=[
-                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
-            ],
-            options={},
-            bases=(models.Model,),
-        ),
-        migrations.CreateModel(
-            name='UnmigratedModel',
-            fields=[
-                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
-            ],
-            options={},
-            bases=(models.Model,),
-        ),
-        migrations.DeleteModel(
-            name='Author',
-        ),
-        migrations.DeleteModel(
-            name='Book',
-        ),
-    ]
diff --git a/tests/migrations/test_migrations_no_changes/__init__.py b/tests/migrations/test_migrations_no_changes/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_no_default/0001_initial.py b/tests/migrations/test_migrations_no_default/0001_initial.py
deleted file mode 100644
index e9176c4958..0000000000
--- a/tests/migrations/test_migrations_no_default/0001_initial.py
+++ /dev/null
@@ -1,20 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-    ]
-
-    operations = [
-        migrations.CreateModel(
-            name='SillyModel',
-            fields=[
-                ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
-                ('silly_field', models.BooleanField(default=False)),
-            ],
-            options={
-            },
-            bases=(models.Model,),
-        ),
-    ]
diff --git a/tests/migrations/test_migrations_no_default/__init__.py b/tests/migrations/test_migrations_no_default/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_no_init/.gitkeep b/tests/migrations/test_migrations_no_init/.gitkeep
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_no_operations/0001_initial.py b/tests/migrations/test_migrations_no_operations/0001_initial.py
deleted file mode 100644
index a07dd888da..0000000000
--- a/tests/migrations/test_migrations_no_operations/0001_initial.py
+++ /dev/null
@@ -1,6 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    dependencies = []
-    operations = []
diff --git a/tests/migrations/test_migrations_no_operations/__init__.py b/tests/migrations/test_migrations_no_operations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_non_atomic/0001_initial.py b/tests/migrations/test_migrations_non_atomic/0001_initial.py
deleted file mode 100644
index f1aa1ae371..0000000000
--- a/tests/migrations/test_migrations_non_atomic/0001_initial.py
+++ /dev/null
@@ -1,29 +0,0 @@
-from django.db import migrations, models
-
-
-def raise_error(apps, schema_editor):
-    # Test operation in non-atomic migration is not wrapped in transaction
-    Publisher = apps.get_model('migrations', 'Publisher')
-    Publisher.objects.create(name='Test Publisher')
-    raise RuntimeError('Abort migration')
-
-
-class Migration(migrations.Migration):
-    atomic = False
-
-    operations = [
-        migrations.CreateModel(
-            "Publisher",
-            [
-                ("name", models.CharField(primary_key=True, max_length=255)),
-            ],
-        ),
-        migrations.RunPython(raise_error),
-        migrations.CreateModel(
-            "Book",
-            [
-                ("title", models.CharField(primary_key=True, max_length=255)),
-                ("publisher", models.ForeignKey("migrations.Publisher", models.SET_NULL, null=True)),
-            ],
-        ),
-    ]
diff --git a/tests/migrations/test_migrations_non_atomic/__init__.py b/tests/migrations/test_migrations_non_atomic/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_order/0001.py b/tests/migrations/test_migrations_order/0001.py
deleted file mode 100644
index 2ef88e957d..0000000000
--- a/tests/migrations/test_migrations_order/0001.py
+++ /dev/null
@@ -1,9 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    initial = True
-
-    operations = [
-    ]
diff --git a/tests/migrations/test_migrations_order/__init__.py b/tests/migrations/test_migrations_order/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_plan/0001_initial.py b/tests/migrations/test_migrations_plan/0001_initial.py
deleted file mode 100644
index 0a4001d52a..0000000000
--- a/tests/migrations/test_migrations_plan/0001_initial.py
+++ /dev/null
@@ -1,28 +0,0 @@
-from django.db import migrations, models
-
-
-def grow_tail(x, y):
-    """Grow salamander tail."""
-    pass
-
-
-def shrink_tail(x, y):
-    """Shrink salamander tail."""
-    pass
-
-
-class Migration(migrations.Migration):
-
-    initial = True
-
-    operations = [
-        migrations.CreateModel(
-            'Salamander',
-            [
-                ('id', models.AutoField(primary_key=True)),
-                ('tail', models.IntegerField(default=0)),
-                ('silly_field', models.BooleanField(default=False)),
-            ],
-        ),
-        migrations.RunPython(grow_tail, shrink_tail),
-    ]
diff --git a/tests/migrations/test_migrations_plan/0002_second.py b/tests/migrations/test_migrations_plan/0002_second.py
deleted file mode 100644
index 2fc9ea6933..0000000000
--- a/tests/migrations/test_migrations_plan/0002_second.py
+++ /dev/null
@@ -1,20 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('migrations', '0001_initial'),
-    ]
-
-    operations = [
-
-        migrations.CreateModel(
-            'Book',
-            [
-                ('id', models.AutoField(primary_key=True)),
-            ],
-        ),
-        migrations.RunSQL(['SELECT * FROM migrations_book'], ['SELECT * FROM migrations_salamander'])
-
-    ]
diff --git a/tests/migrations/test_migrations_plan/0003_third.py b/tests/migrations/test_migrations_plan/0003_third.py
deleted file mode 100644
index 6d17e217ec..0000000000
--- a/tests/migrations/test_migrations_plan/0003_third.py
+++ /dev/null
@@ -1,19 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ('migrations', '0002_second'),
-    ]
-
-    operations = [
-
-        migrations.CreateModel(
-            'Author',
-            [
-                ('id', models.AutoField(primary_key=True)),
-            ],
-        ),
-        migrations.RunSQL(['SELECT * FROM migrations_author'], ['SELECT * FROM migrations_book'])
-    ]
diff --git a/tests/migrations/test_migrations_plan/0004_fourth.py b/tests/migrations/test_migrations_plan/0004_fourth.py
deleted file mode 100644
index d3e1a54b4d..0000000000
--- a/tests/migrations/test_migrations_plan/0004_fourth.py
+++ /dev/null
@@ -1,12 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ("migrations", "0003_third"),
-    ]
-
-    operations = [
-        migrations.RunSQL('SELECT * FROM migrations_author WHERE id = 1')
-    ]
diff --git a/tests/migrations/test_migrations_plan/0005_fifth.py b/tests/migrations/test_migrations_plan/0005_fifth.py
deleted file mode 100644
index 3c569ffded..0000000000
--- a/tests/migrations/test_migrations_plan/0005_fifth.py
+++ /dev/null
@@ -1,22 +0,0 @@
-from django.db import migrations
-
-
-def grow_tail(x, y):
-    pass
-
-
-def feed(x, y):
-    """Feed salamander."""
-    pass
-
-
-class Migration(migrations.Migration):
-    dependencies = [
-        ('migrations', '0004_fourth'),
-    ]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop),
-        migrations.RunPython(grow_tail),
-        migrations.RunPython(feed, migrations.RunPython.noop),
-    ]
diff --git a/tests/migrations/test_migrations_plan/__init__.py b/tests/migrations/test_migrations_plan/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_private/.util.py b/tests/migrations/test_migrations_private/.util.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_private/0001_initial.py b/tests/migrations/test_migrations_private/0001_initial.py
deleted file mode 100644
index bd613aa95e..0000000000
--- a/tests/migrations/test_migrations_private/0001_initial.py
+++ /dev/null
@@ -1,5 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    pass
diff --git a/tests/migrations/test_migrations_private/__init__.py b/tests/migrations/test_migrations_private/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_private/_util.py b/tests/migrations/test_migrations_private/_util.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_private/~util.py b/tests/migrations/test_migrations_private/~util.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_run_before/0001_initial.py b/tests/migrations/test_migrations_run_before/0001_initial.py
deleted file mode 100644
index 186c7fbec9..0000000000
--- a/tests/migrations/test_migrations_run_before/0001_initial.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-
-        migrations.CreateModel(
-            "Salamander",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("size", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-
-    ]
diff --git a/tests/migrations/test_migrations_run_before/0002_second.py b/tests/migrations/test_migrations_run_before/0002_second.py
deleted file mode 100644
index 2be86bb439..0000000000
--- a/tests/migrations/test_migrations_run_before/0002_second.py
+++ /dev/null
@@ -1,20 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ("migrations", "0001_initial"),
-    ]
-
-    operations = [
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_run_before/0003_third.py b/tests/migrations/test_migrations_run_before/0003_third.py
deleted file mode 100644
index d24d28ca1c..0000000000
--- a/tests/migrations/test_migrations_run_before/0003_third.py
+++ /dev/null
@@ -1,29 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-    """
-    This is a wee bit crazy, but it's just to show that run_before works.
-    """
-
-    dependencies = [
-        ("migrations", "0001_initial"),
-    ]
-
-    run_before = [
-        ("migrations", "0002_second"),
-    ]
-
-    operations = [
-
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_run_before/__init__.py b/tests/migrations/test_migrations_run_before/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_squashed/0001_initial.py b/tests/migrations/test_migrations_squashed/0001_initial.py
deleted file mode 100644
index 344bebdfe3..0000000000
--- a/tests/migrations/test_migrations_squashed/0001_initial.py
+++ /dev/null
@@ -1,27 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("silly_field", models.BooleanField(default=False)),
-            ],
-        ),
-
-        migrations.CreateModel(
-            "Tribble",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("fluffy", models.BooleanField(default=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_squashed/0001_squashed_0002.py b/tests/migrations/test_migrations_squashed/0001_squashed_0002.py
deleted file mode 100644
index 1ba7f45e41..0000000000
--- a/tests/migrations/test_migrations_squashed/0001_squashed_0002.py
+++ /dev/null
@@ -1,32 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    replaces = [
-        ("migrations", "0001_initial"),
-        ("migrations", "0002_second"),
-    ]
-
-    operations = [
-
-        migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=255)),
-                ("slug", models.SlugField(null=True)),
-                ("age", models.IntegerField(default=0)),
-                ("rating", models.IntegerField(default=0)),
-            ],
-        ),
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
-            ],
-        ),
-
-    ]
diff --git a/tests/migrations/test_migrations_squashed/0002_second.py b/tests/migrations/test_migrations_squashed/0002_second.py
deleted file mode 100644
index 60a6999ee4..0000000000
--- a/tests/migrations/test_migrations_squashed/0002_second.py
+++ /dev/null
@@ -1,24 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "0001_initial")]
-
-    operations = [
-
-        migrations.DeleteModel("Tribble"),
-
-        migrations.RemoveField("Author", "silly_field"),
-
-        migrations.AddField("Author", "rating", models.IntegerField(default=0)),
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("author", models.ForeignKey("migrations.Author", models.SET_NULL, null=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_squashed/__init__.py b/tests/migrations/test_migrations_squashed/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_squashed_complex/1_auto.py b/tests/migrations/test_migrations_squashed_complex/1_auto.py
deleted file mode 100644
index 46fc1242c9..0000000000
--- a/tests/migrations/test_migrations_squashed_complex/1_auto.py
+++ /dev/null
@@ -1,8 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex/2_auto.py b/tests/migrations/test_migrations_squashed_complex/2_auto.py
deleted file mode 100644
index 1964bf8167..0000000000
--- a/tests/migrations/test_migrations_squashed_complex/2_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "1_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex/3_auto.py b/tests/migrations/test_migrations_squashed_complex/3_auto.py
deleted file mode 100644
index 994ddf3619..0000000000
--- a/tests/migrations/test_migrations_squashed_complex/3_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "2_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex/3_squashed_5.py b/tests/migrations/test_migrations_squashed_complex/3_squashed_5.py
deleted file mode 100644
index e8f1eb527e..0000000000
--- a/tests/migrations/test_migrations_squashed_complex/3_squashed_5.py
+++ /dev/null
@@ -1,16 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    replaces = [
-        ("migrations", "3_auto"),
-        ("migrations", "4_auto"),
-        ("migrations", "5_auto"),
-    ]
-
-    dependencies = [("migrations", "2_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex/4_auto.py b/tests/migrations/test_migrations_squashed_complex/4_auto.py
deleted file mode 100644
index e7d0f09b55..0000000000
--- a/tests/migrations/test_migrations_squashed_complex/4_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "3_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex/5_auto.py b/tests/migrations/test_migrations_squashed_complex/5_auto.py
deleted file mode 100644
index e7e25d9a71..0000000000
--- a/tests/migrations/test_migrations_squashed_complex/5_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "4_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex/6_auto.py b/tests/migrations/test_migrations_squashed_complex/6_auto.py
deleted file mode 100644
index 4438bb4196..0000000000
--- a/tests/migrations/test_migrations_squashed_complex/6_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "5_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex/7_auto.py b/tests/migrations/test_migrations_squashed_complex/7_auto.py
deleted file mode 100644
index f231edfed1..0000000000
--- a/tests/migrations/test_migrations_squashed_complex/7_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "6_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex/__init__.py b/tests/migrations/test_migrations_squashed_complex/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/__init__.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/1_auto.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/1_auto.py
deleted file mode 100644
index 46fc1242c9..0000000000
--- a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/1_auto.py
+++ /dev/null
@@ -1,8 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/2_auto.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/2_auto.py
deleted file mode 100644
index 83d6e0bedc..0000000000
--- a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/2_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("app1", "1_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/2_squashed_3.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/2_squashed_3.py
deleted file mode 100644
index 838f68f99f..0000000000
--- a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/2_squashed_3.py
+++ /dev/null
@@ -1,15 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    replaces = [
-        ("app1", "2_auto"),
-        ("app1", "3_auto"),
-    ]
-
-    dependencies = [("app1", "1_auto"), ("app2", "2_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/3_auto.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/3_auto.py
deleted file mode 100644
index 8abccb5bed..0000000000
--- a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/3_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("app1", "2_auto"), ("app2", "2_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/4_auto.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/4_auto.py
deleted file mode 100644
index 3b44a1d0ab..0000000000
--- a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/4_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("app1", "3_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/__init__.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/app1/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/1_auto.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/1_auto.py
deleted file mode 100644
index 83d6e0bedc..0000000000
--- a/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/1_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("app1", "1_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/1_squashed_2.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/1_squashed_2.py
deleted file mode 100644
index e12b5754ad..0000000000
--- a/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/1_squashed_2.py
+++ /dev/null
@@ -1,15 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    replaces = [
-        ("app2", "1_auto"),
-        ("app2", "2_auto"),
-    ]
-
-    dependencies = [("app1", "1_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/2_auto.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/2_auto.py
deleted file mode 100644
index 6726beb9d5..0000000000
--- a/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/2_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("app2", "1_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/__init__.py b/tests/migrations/test_migrations_squashed_complex_multi_apps/app2/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_squashed_erroneous/1_auto.py b/tests/migrations/test_migrations_squashed_erroneous/1_auto.py
deleted file mode 100644
index 46fc1242c9..0000000000
--- a/tests/migrations/test_migrations_squashed_erroneous/1_auto.py
+++ /dev/null
@@ -1,8 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_erroneous/2_auto.py b/tests/migrations/test_migrations_squashed_erroneous/2_auto.py
deleted file mode 100644
index 1964bf8167..0000000000
--- a/tests/migrations/test_migrations_squashed_erroneous/2_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "1_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_erroneous/3_squashed_5.py b/tests/migrations/test_migrations_squashed_erroneous/3_squashed_5.py
deleted file mode 100644
index e8f1eb527e..0000000000
--- a/tests/migrations/test_migrations_squashed_erroneous/3_squashed_5.py
+++ /dev/null
@@ -1,16 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    replaces = [
-        ("migrations", "3_auto"),
-        ("migrations", "4_auto"),
-        ("migrations", "5_auto"),
-    ]
-
-    dependencies = [("migrations", "2_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_erroneous/6_auto.py b/tests/migrations/test_migrations_squashed_erroneous/6_auto.py
deleted file mode 100644
index 4438bb4196..0000000000
--- a/tests/migrations/test_migrations_squashed_erroneous/6_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "5_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_erroneous/7_auto.py b/tests/migrations/test_migrations_squashed_erroneous/7_auto.py
deleted file mode 100644
index f231edfed1..0000000000
--- a/tests/migrations/test_migrations_squashed_erroneous/7_auto.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("migrations", "6_auto")]
-
-    operations = [
-        migrations.RunPython(migrations.RunPython.noop)
-    ]
diff --git a/tests/migrations/test_migrations_squashed_erroneous/__init__.py b/tests/migrations/test_migrations_squashed_erroneous/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_squashed_extra/0001_initial.py b/tests/migrations/test_migrations_squashed_extra/0001_initial.py
deleted file mode 100644
index bd613aa95e..0000000000
--- a/tests/migrations/test_migrations_squashed_extra/0001_initial.py
+++ /dev/null
@@ -1,5 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    pass
diff --git a/tests/migrations/test_migrations_squashed_extra/0001_squashed_0002.py b/tests/migrations/test_migrations_squashed_extra/0001_squashed_0002.py
deleted file mode 100644
index 9d5581cc59..0000000000
--- a/tests/migrations/test_migrations_squashed_extra/0001_squashed_0002.py
+++ /dev/null
@@ -1,8 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    replaces = [
-        ("migrations", "0001_initial"),
-        ("migrations", "0002_second"),
-    ]
diff --git a/tests/migrations/test_migrations_squashed_extra/0002_second.py b/tests/migrations/test_migrations_squashed_extra/0002_second.py
deleted file mode 100644
index 5ca710feb6..0000000000
--- a/tests/migrations/test_migrations_squashed_extra/0002_second.py
+++ /dev/null
@@ -1,5 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    dependencies = [("migrations", "0001_initial")]
diff --git a/tests/migrations/test_migrations_squashed_extra/0003_third.py b/tests/migrations/test_migrations_squashed_extra/0003_third.py
deleted file mode 100644
index cf27aa2990..0000000000
--- a/tests/migrations/test_migrations_squashed_extra/0003_third.py
+++ /dev/null
@@ -1,5 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    dependencies = [("migrations", "0002_second")]
diff --git a/tests/migrations/test_migrations_squashed_extra/__init__.py b/tests/migrations/test_migrations_squashed_extra/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/__init__.py b/tests/migrations/test_migrations_squashed_ref_squashed/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/app1/1_auto.py b/tests/migrations/test_migrations_squashed_ref_squashed/app1/1_auto.py
deleted file mode 100644
index bd613aa95e..0000000000
--- a/tests/migrations/test_migrations_squashed_ref_squashed/app1/1_auto.py
+++ /dev/null
@@ -1,5 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-    pass
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/app1/2_auto.py b/tests/migrations/test_migrations_squashed_ref_squashed/app1/2_auto.py
deleted file mode 100644
index 27d00f0cba..0000000000
--- a/tests/migrations/test_migrations_squashed_ref_squashed/app1/2_auto.py
+++ /dev/null
@@ -1,6 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("app1", "1_auto")]
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/app1/2_squashed_3.py b/tests/migrations/test_migrations_squashed_ref_squashed/app1/2_squashed_3.py
deleted file mode 100644
index c036174132..0000000000
--- a/tests/migrations/test_migrations_squashed_ref_squashed/app1/2_squashed_3.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    replaces = [
-        ("app1", "2_auto"),
-        ("app1", "3_auto"),
-    ]
-
-    dependencies = [("app1", "1_auto"), ("app2", "1_squashed_2")]
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/app1/3_auto.py b/tests/migrations/test_migrations_squashed_ref_squashed/app1/3_auto.py
deleted file mode 100644
index 2203e4fdee..0000000000
--- a/tests/migrations/test_migrations_squashed_ref_squashed/app1/3_auto.py
+++ /dev/null
@@ -1,6 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("app1", "2_auto"), ("app2", "2_auto")]
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/app1/4_auto.py b/tests/migrations/test_migrations_squashed_ref_squashed/app1/4_auto.py
deleted file mode 100644
index e9eddb1664..0000000000
--- a/tests/migrations/test_migrations_squashed_ref_squashed/app1/4_auto.py
+++ /dev/null
@@ -1,6 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("app1", "2_squashed_3")]
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/app1/__init__.py b/tests/migrations/test_migrations_squashed_ref_squashed/app1/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/app2/1_auto.py b/tests/migrations/test_migrations_squashed_ref_squashed/app2/1_auto.py
deleted file mode 100644
index 27d00f0cba..0000000000
--- a/tests/migrations/test_migrations_squashed_ref_squashed/app2/1_auto.py
+++ /dev/null
@@ -1,6 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("app1", "1_auto")]
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/app2/1_squashed_2.py b/tests/migrations/test_migrations_squashed_ref_squashed/app2/1_squashed_2.py
deleted file mode 100644
index ac24a30c85..0000000000
--- a/tests/migrations/test_migrations_squashed_ref_squashed/app2/1_squashed_2.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    replaces = [
-        ("app2", "1_auto"),
-        ("app2", "2_auto"),
-    ]
-
-    dependencies = [("app1", "1_auto")]
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/app2/2_auto.py b/tests/migrations/test_migrations_squashed_ref_squashed/app2/2_auto.py
deleted file mode 100644
index 0b01988bbd..0000000000
--- a/tests/migrations/test_migrations_squashed_ref_squashed/app2/2_auto.py
+++ /dev/null
@@ -1,6 +0,0 @@
-from django.db import migrations
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [("app2", "1_auto")]
diff --git a/tests/migrations/test_migrations_squashed_ref_squashed/app2/__init__.py b/tests/migrations/test_migrations_squashed_ref_squashed/app2/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_migrations_unmigdep/0001_initial.py b/tests/migrations/test_migrations_unmigdep/0001_initial.py
deleted file mode 100644
index 91b58c3dad..0000000000
--- a/tests/migrations/test_migrations_unmigdep/0001_initial.py
+++ /dev/null
@@ -1,20 +0,0 @@
-from django.db import migrations, models
-
-
-class Migration(migrations.Migration):
-
-    dependencies = [
-        ("auth", "__first__"),
-    ]
-
-    operations = [
-
-        migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("user", models.ForeignKey("auth.User", models.SET_NULL, null=True)),
-            ],
-        )
-
-    ]
diff --git a/tests/migrations/test_migrations_unmigdep/__init__.py b/tests/migrations/test_migrations_unmigdep/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/migrations/test_multidb.py b/tests/migrations/test_multidb.py
deleted file mode 100644
index d8986deb81..0000000000
--- a/tests/migrations/test_multidb.py
+++ /dev/null
@@ -1,171 +0,0 @@
-from django.db import connection, migrations, models
-from django.db.migrations.state import ProjectState
-from django.test import override_settings
-
-from .test_base import OperationTestBase
-
-
-class AgnosticRouter:
-    """
-    A router that doesn't have an opinion regarding migrating.
-    """
-    def allow_migrate(self, db, app_label, **hints):
-        return None
-
-
-class MigrateNothingRouter:
-    """
-    A router that doesn't allow migrating.
-    """
-    def allow_migrate(self, db, app_label, **hints):
-        return False
-
-
-class MigrateEverythingRouter:
-    """
-    A router that always allows migrating.
-    """
-    def allow_migrate(self, db, app_label, **hints):
-        return True
-
-
-class MigrateWhenFooRouter:
-    """
-    A router that allows migrating depending on a hint.
-    """
-    def allow_migrate(self, db, app_label, **hints):
-        return hints.get('foo', False)
-
-
-class MultiDBOperationTests(OperationTestBase):
-    databases = {'default', 'other'}
-
-    def _test_create_model(self, app_label, should_run):
-        """
-        CreateModel honors multi-db settings.
-        """
-        operation = migrations.CreateModel(
-            "Pony",
-            [("id", models.AutoField(primary_key=True))],
-        )
-        # Test the state alteration
-        project_state = ProjectState()
-        new_state = project_state.clone()
-        operation.state_forwards(app_label, new_state)
-        # Test the database alteration
-        self.assertTableNotExists("%s_pony" % app_label)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, project_state, new_state)
-        if should_run:
-            self.assertTableExists("%s_pony" % app_label)
-        else:
-            self.assertTableNotExists("%s_pony" % app_label)
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards(app_label, editor, new_state, project_state)
-        self.assertTableNotExists("%s_pony" % app_label)
-
-    @override_settings(DATABASE_ROUTERS=[AgnosticRouter()])
-    def test_create_model(self):
-        """
-        Test when router doesn't have an opinion (i.e. CreateModel should run).
-        """
-        self._test_create_model("test_mltdb_crmo", should_run=True)
-
-    @override_settings(DATABASE_ROUTERS=[MigrateNothingRouter()])
-    def test_create_model2(self):
-        """
-        Test when router returns False (i.e. CreateModel shouldn't run).
-        """
-        self._test_create_model("test_mltdb_crmo2", should_run=False)
-
-    @override_settings(DATABASE_ROUTERS=[MigrateEverythingRouter()])
-    def test_create_model3(self):
-        """
-        Test when router returns True (i.e. CreateModel should run).
-        """
-        self._test_create_model("test_mltdb_crmo3", should_run=True)
-
-    def test_create_model4(self):
-        """
-        Test multiple routers.
-        """
-        with override_settings(DATABASE_ROUTERS=[AgnosticRouter(), AgnosticRouter()]):
-            self._test_create_model("test_mltdb_crmo4", should_run=True)
-        with override_settings(DATABASE_ROUTERS=[MigrateNothingRouter(), MigrateEverythingRouter()]):
-            self._test_create_model("test_mltdb_crmo4", should_run=False)
-        with override_settings(DATABASE_ROUTERS=[MigrateEverythingRouter(), MigrateNothingRouter()]):
-            self._test_create_model("test_mltdb_crmo4", should_run=True)
-
-    def _test_run_sql(self, app_label, should_run, hints=None):
-        with override_settings(DATABASE_ROUTERS=[MigrateEverythingRouter()]):
-            project_state = self.set_up_test_model(app_label)
-
-        sql = """
-        INSERT INTO {0}_pony (pink, weight) VALUES (1, 3.55);
-        INSERT INTO {0}_pony (pink, weight) VALUES (3, 5.0);
-        """.format(app_label)
-
-        operation = migrations.RunSQL(sql, hints=hints or {})
-        # Test the state alteration does nothing
-        new_state = project_state.clone()
-        operation.state_forwards(app_label, new_state)
-        self.assertEqual(new_state, project_state)
-        # Test the database alteration
-        self.assertEqual(project_state.apps.get_model(app_label, "Pony").objects.count(), 0)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, project_state, new_state)
-        Pony = project_state.apps.get_model(app_label, "Pony")
-        if should_run:
-            self.assertEqual(Pony.objects.count(), 2)
-        else:
-            self.assertEqual(Pony.objects.count(), 0)
-
-    @override_settings(DATABASE_ROUTERS=[MigrateNothingRouter()])
-    def test_run_sql_migrate_nothing_router(self):
-        self._test_run_sql("test_mltdb_runsql", should_run=False)
-
-    @override_settings(DATABASE_ROUTERS=[MigrateWhenFooRouter()])
-    def test_run_sql_migrate_foo_router_without_hints(self):
-        self._test_run_sql("test_mltdb_runsql2", should_run=False)
-
-    @override_settings(DATABASE_ROUTERS=[MigrateWhenFooRouter()])
-    def test_run_sql_migrate_foo_router_with_hints(self):
-        self._test_run_sql('test_mltdb_runsql3', should_run=True, hints={'foo': True})
-
-    def _test_run_python(self, app_label, should_run, hints=None):
-        with override_settings(DATABASE_ROUTERS=[MigrateEverythingRouter()]):
-            project_state = self.set_up_test_model(app_label)
-
-        # Create the operation
-        def inner_method(models, schema_editor):
-            Pony = models.get_model(app_label, "Pony")
-            Pony.objects.create(pink=1, weight=3.55)
-            Pony.objects.create(weight=5)
-
-        operation = migrations.RunPython(inner_method, hints=hints or {})
-        # Test the state alteration does nothing
-        new_state = project_state.clone()
-        operation.state_forwards(app_label, new_state)
-        self.assertEqual(new_state, project_state)
-        # Test the database alteration
-        self.assertEqual(project_state.apps.get_model(app_label, "Pony").objects.count(), 0)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, project_state, new_state)
-        Pony = project_state.apps.get_model(app_label, "Pony")
-        if should_run:
-            self.assertEqual(Pony.objects.count(), 2)
-        else:
-            self.assertEqual(Pony.objects.count(), 0)
-
-    @override_settings(DATABASE_ROUTERS=[MigrateNothingRouter()])
-    def test_run_python_migrate_nothing_router(self):
-        self._test_run_python("test_mltdb_runpython", should_run=False)
-
-    @override_settings(DATABASE_ROUTERS=[MigrateWhenFooRouter()])
-    def test_run_python_migrate_foo_router_without_hints(self):
-        self._test_run_python("test_mltdb_runpython2", should_run=False)
-
-    @override_settings(DATABASE_ROUTERS=[MigrateWhenFooRouter()])
-    def test_run_python_migrate_foo_router_with_hints(self):
-        self._test_run_python('test_mltdb_runpython3', should_run=True, hints={'foo': True})
diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py
deleted file mode 100644
index 855a052058..0000000000
--- a/tests/migrations/test_operations.py
+++ /dev/null
@@ -1,3244 +0,0 @@
-from django.core.exceptions import FieldDoesNotExist
-from django.db import (
-    IntegrityError, connection, migrations, models, transaction,
-)
-from django.db.migrations.migration import Migration
-from django.db.migrations.operations.fields import FieldOperation
-from django.db.migrations.state import ModelState, ProjectState
-from django.db.transaction import atomic
-from django.test import SimpleTestCase, override_settings, skipUnlessDBFeature
-
-from .models import FoodManager, FoodQuerySet, UnicodeModel
-from .test_base import OperationTestBase
-
-
-class Mixin:
-    pass
-
-
-class OperationTests(OperationTestBase):
-    """
-    Tests running the operations and making sure they do what they say they do.
-    Each test looks at their state changing, and then their database operation -
-    both forwards and backwards.
-    """
-
-    def test_create_model(self):
-        """
-        Tests the CreateModel operation.
-        Most other tests use this operation as part of setup, so check failures here first.
-        """
-        operation = migrations.CreateModel(
-            "Pony",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("pink", models.IntegerField(default=1)),
-            ],
-        )
-        self.assertEqual(operation.describe(), "Create model Pony")
-        self.assertEqual(operation.migration_name_fragment, 'pony')
-        # Test the state alteration
-        project_state = ProjectState()
-        new_state = project_state.clone()
-        operation.state_forwards("test_crmo", new_state)
-        self.assertEqual(new_state.models["test_crmo", "pony"].name, "Pony")
-        self.assertEqual(len(new_state.models["test_crmo", "pony"].fields), 2)
-        # Test the database alteration
-        self.assertTableNotExists("test_crmo_pony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_crmo", editor, project_state, new_state)
-        self.assertTableExists("test_crmo_pony")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_crmo", editor, new_state, project_state)
-        self.assertTableNotExists("test_crmo_pony")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "CreateModel")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(sorted(definition[2]), ["fields", "name"])
-        # And default manager not in set
-        operation = migrations.CreateModel("Foo", fields=[], managers=[("objects", models.Manager())])
-        definition = operation.deconstruct()
-        self.assertNotIn('managers', definition[2])
-
-    def test_create_model_with_duplicate_field_name(self):
-        with self.assertRaisesMessage(ValueError, 'Found duplicate value pink in CreateModel fields argument.'):
-            migrations.CreateModel(
-                "Pony",
-                [
-                    ("id", models.AutoField(primary_key=True)),
-                    ("pink", models.TextField()),
-                    ("pink", models.IntegerField(default=1)),
-                ],
-            )
-
-    def test_create_model_with_duplicate_base(self):
-        message = 'Found duplicate value test_crmo.pony in CreateModel bases argument.'
-        with self.assertRaisesMessage(ValueError, message):
-            migrations.CreateModel(
-                "Pony",
-                fields=[],
-                bases=("test_crmo.Pony", "test_crmo.Pony",),
-            )
-        with self.assertRaisesMessage(ValueError, message):
-            migrations.CreateModel(
-                "Pony",
-                fields=[],
-                bases=("test_crmo.Pony", "test_crmo.pony",),
-            )
-        message = 'Found duplicate value migrations.unicodemodel in CreateModel bases argument.'
-        with self.assertRaisesMessage(ValueError, message):
-            migrations.CreateModel(
-                "Pony",
-                fields=[],
-                bases=(UnicodeModel, UnicodeModel,),
-            )
-        with self.assertRaisesMessage(ValueError, message):
-            migrations.CreateModel(
-                "Pony",
-                fields=[],
-                bases=(UnicodeModel, 'migrations.unicodemodel',),
-            )
-        with self.assertRaisesMessage(ValueError, message):
-            migrations.CreateModel(
-                "Pony",
-                fields=[],
-                bases=(UnicodeModel, 'migrations.UnicodeModel',),
-            )
-        message = "Found duplicate value <class 'django.db.models.base.Model'> in CreateModel bases argument."
-        with self.assertRaisesMessage(ValueError, message):
-            migrations.CreateModel(
-                "Pony",
-                fields=[],
-                bases=(models.Model, models.Model,),
-            )
-        message = "Found duplicate value <class 'migrations.test_operations.Mixin'> in CreateModel bases argument."
-        with self.assertRaisesMessage(ValueError, message):
-            migrations.CreateModel(
-                "Pony",
-                fields=[],
-                bases=(Mixin, Mixin,),
-            )
-
-    def test_create_model_with_duplicate_manager_name(self):
-        with self.assertRaisesMessage(ValueError, 'Found duplicate value objects in CreateModel managers argument.'):
-            migrations.CreateModel(
-                "Pony",
-                fields=[],
-                managers=[
-                    ("objects", models.Manager()),
-                    ("objects", models.Manager()),
-                ],
-            )
-
-    def test_create_model_with_unique_after(self):
-        """
-        Tests the CreateModel operation directly followed by an
-        AlterUniqueTogether (bug #22844 - sqlite remake issues)
-        """
-        operation1 = migrations.CreateModel(
-            "Pony",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("pink", models.IntegerField(default=1)),
-            ],
-        )
-        operation2 = migrations.CreateModel(
-            "Rider",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("number", models.IntegerField(default=1)),
-                ("pony", models.ForeignKey("test_crmoua.Pony", models.CASCADE)),
-            ],
-        )
-        operation3 = migrations.AlterUniqueTogether(
-            "Rider",
-            [
-                ("number", "pony"),
-            ],
-        )
-        # Test the database alteration
-        project_state = ProjectState()
-        self.assertTableNotExists("test_crmoua_pony")
-        self.assertTableNotExists("test_crmoua_rider")
-        with connection.schema_editor() as editor:
-            new_state = project_state.clone()
-            operation1.state_forwards("test_crmoua", new_state)
-            operation1.database_forwards("test_crmoua", editor, project_state, new_state)
-            project_state, new_state = new_state, new_state.clone()
-            operation2.state_forwards("test_crmoua", new_state)
-            operation2.database_forwards("test_crmoua", editor, project_state, new_state)
-            project_state, new_state = new_state, new_state.clone()
-            operation3.state_forwards("test_crmoua", new_state)
-            operation3.database_forwards("test_crmoua", editor, project_state, new_state)
-        self.assertTableExists("test_crmoua_pony")
-        self.assertTableExists("test_crmoua_rider")
-
-    def test_create_model_m2m(self):
-        """
-        Test the creation of a model with a ManyToMany field and the
-        auto-created "through" model.
-        """
-        project_state = self.set_up_test_model("test_crmomm")
-        operation = migrations.CreateModel(
-            "Stable",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("ponies", models.ManyToManyField("Pony", related_name="stables"))
-            ]
-        )
-        # Test the state alteration
-        new_state = project_state.clone()
-        operation.state_forwards("test_crmomm", new_state)
-        # Test the database alteration
-        self.assertTableNotExists("test_crmomm_stable_ponies")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_crmomm", editor, project_state, new_state)
-        self.assertTableExists("test_crmomm_stable")
-        self.assertTableExists("test_crmomm_stable_ponies")
-        self.assertColumnNotExists("test_crmomm_stable", "ponies")
-        # Make sure the M2M field actually works
-        with atomic():
-            Pony = new_state.apps.get_model("test_crmomm", "Pony")
-            Stable = new_state.apps.get_model("test_crmomm", "Stable")
-            stable = Stable.objects.create()
-            p1 = Pony.objects.create(pink=False, weight=4.55)
-            p2 = Pony.objects.create(pink=True, weight=5.43)
-            stable.ponies.add(p1, p2)
-            self.assertEqual(stable.ponies.count(), 2)
-            stable.ponies.all().delete()
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_crmomm", editor, new_state, project_state)
-        self.assertTableNotExists("test_crmomm_stable")
-        self.assertTableNotExists("test_crmomm_stable_ponies")
-
-    def test_create_model_inheritance(self):
-        """
-        Tests the CreateModel operation on a multi-table inheritance setup.
-        """
-        project_state = self.set_up_test_model("test_crmoih")
-        # Test the state alteration
-        operation = migrations.CreateModel(
-            "ShetlandPony",
-            [
-                ('pony_ptr', models.OneToOneField(
-                    'test_crmoih.Pony',
-                    models.CASCADE,
-                    auto_created=True,
-                    primary_key=True,
-                    to_field='id',
-                    serialize=False,
-                )),
-                ("cuteness", models.IntegerField(default=1)),
-            ],
-        )
-        new_state = project_state.clone()
-        operation.state_forwards("test_crmoih", new_state)
-        self.assertIn(("test_crmoih", "shetlandpony"), new_state.models)
-        # Test the database alteration
-        self.assertTableNotExists("test_crmoih_shetlandpony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_crmoih", editor, project_state, new_state)
-        self.assertTableExists("test_crmoih_shetlandpony")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_crmoih", editor, new_state, project_state)
-        self.assertTableNotExists("test_crmoih_shetlandpony")
-
-    def test_create_proxy_model(self):
-        """
-        CreateModel ignores proxy models.
-        """
-        project_state = self.set_up_test_model("test_crprmo")
-        # Test the state alteration
-        operation = migrations.CreateModel(
-            "ProxyPony",
-            [],
-            options={"proxy": True},
-            bases=("test_crprmo.Pony",),
-        )
-        self.assertEqual(operation.describe(), "Create proxy model ProxyPony")
-        new_state = project_state.clone()
-        operation.state_forwards("test_crprmo", new_state)
-        self.assertIn(("test_crprmo", "proxypony"), new_state.models)
-        # Test the database alteration
-        self.assertTableNotExists("test_crprmo_proxypony")
-        self.assertTableExists("test_crprmo_pony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_crprmo", editor, project_state, new_state)
-        self.assertTableNotExists("test_crprmo_proxypony")
-        self.assertTableExists("test_crprmo_pony")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_crprmo", editor, new_state, project_state)
-        self.assertTableNotExists("test_crprmo_proxypony")
-        self.assertTableExists("test_crprmo_pony")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "CreateModel")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(sorted(definition[2]), ["bases", "fields", "name", "options"])
-
-    def test_create_unmanaged_model(self):
-        """
-        CreateModel ignores unmanaged models.
-        """
-        project_state = self.set_up_test_model("test_crummo")
-        # Test the state alteration
-        operation = migrations.CreateModel(
-            "UnmanagedPony",
-            [],
-            options={"proxy": True},
-            bases=("test_crummo.Pony",),
-        )
-        self.assertEqual(operation.describe(), "Create proxy model UnmanagedPony")
-        new_state = project_state.clone()
-        operation.state_forwards("test_crummo", new_state)
-        self.assertIn(("test_crummo", "unmanagedpony"), new_state.models)
-        # Test the database alteration
-        self.assertTableNotExists("test_crummo_unmanagedpony")
-        self.assertTableExists("test_crummo_pony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_crummo", editor, project_state, new_state)
-        self.assertTableNotExists("test_crummo_unmanagedpony")
-        self.assertTableExists("test_crummo_pony")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_crummo", editor, new_state, project_state)
-        self.assertTableNotExists("test_crummo_unmanagedpony")
-        self.assertTableExists("test_crummo_pony")
-
-    @skipUnlessDBFeature('supports_table_check_constraints')
-    def test_create_model_with_constraint(self):
-        where = models.Q(pink__gt=2)
-        check_constraint = models.CheckConstraint(check=where, name='test_constraint_pony_pink_gt_2')
-        operation = migrations.CreateModel(
-            "Pony",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("pink", models.IntegerField(default=3)),
-            ],
-            options={'constraints': [check_constraint]},
-        )
-
-        # Test the state alteration
-        project_state = ProjectState()
-        new_state = project_state.clone()
-        operation.state_forwards("test_crmo", new_state)
-        self.assertEqual(len(new_state.models['test_crmo', 'pony'].options['constraints']), 1)
-
-        # Test database alteration
-        self.assertTableNotExists("test_crmo_pony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_crmo", editor, project_state, new_state)
-        self.assertTableExists("test_crmo_pony")
-        with connection.cursor() as cursor:
-            with self.assertRaises(IntegrityError):
-                cursor.execute("INSERT INTO test_crmo_pony (id, pink) VALUES (1, 1)")
-
-        # Test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_crmo", editor, new_state, project_state)
-        self.assertTableNotExists("test_crmo_pony")
-
-        # Test deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "CreateModel")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2]['options']['constraints'], [check_constraint])
-
-    def test_create_model_with_partial_unique_constraint(self):
-        partial_unique_constraint = models.UniqueConstraint(
-            fields=['pink'],
-            condition=models.Q(weight__gt=5),
-            name='test_constraint_pony_pink_for_weight_gt_5_uniq',
-        )
-        operation = migrations.CreateModel(
-            'Pony',
-            [
-                ('id', models.AutoField(primary_key=True)),
-                ('pink', models.IntegerField(default=3)),
-                ('weight', models.FloatField()),
-            ],
-            options={'constraints': [partial_unique_constraint]},
-        )
-        # Test the state alteration
-        project_state = ProjectState()
-        new_state = project_state.clone()
-        operation.state_forwards('test_crmo', new_state)
-        self.assertEqual(len(new_state.models['test_crmo', 'pony'].options['constraints']), 1)
-        # Test database alteration
-        self.assertTableNotExists('test_crmo_pony')
-        with connection.schema_editor() as editor:
-            operation.database_forwards('test_crmo', editor, project_state, new_state)
-        self.assertTableExists('test_crmo_pony')
-        # Test constraint works
-        Pony = new_state.apps.get_model('test_crmo', 'Pony')
-        Pony.objects.create(pink=1, weight=4.0)
-        Pony.objects.create(pink=1, weight=4.0)
-        Pony.objects.create(pink=1, weight=6.0)
-        if connection.features.supports_partial_indexes:
-            with self.assertRaises(IntegrityError):
-                Pony.objects.create(pink=1, weight=7.0)
-        else:
-            Pony.objects.create(pink=1, weight=7.0)
-        # Test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards('test_crmo', editor, new_state, project_state)
-        self.assertTableNotExists('test_crmo_pony')
-        # Test deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], 'CreateModel')
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2]['options']['constraints'], [partial_unique_constraint])
-
-    def test_create_model_with_deferred_unique_constraint(self):
-        deferred_unique_constraint = models.UniqueConstraint(
-            fields=['pink'],
-            name='deferrable_pink_constraint',
-            deferrable=models.Deferrable.DEFERRED,
-        )
-        operation = migrations.CreateModel(
-            'Pony',
-            [
-                ('id', models.AutoField(primary_key=True)),
-                ('pink', models.IntegerField(default=3)),
-            ],
-            options={'constraints': [deferred_unique_constraint]},
-        )
-        project_state = ProjectState()
-        new_state = project_state.clone()
-        operation.state_forwards('test_crmo', new_state)
-        self.assertEqual(len(new_state.models['test_crmo', 'pony'].options['constraints']), 1)
-        self.assertTableNotExists('test_crmo_pony')
-        # Create table.
-        with connection.schema_editor() as editor:
-            operation.database_forwards('test_crmo', editor, project_state, new_state)
-        self.assertTableExists('test_crmo_pony')
-        Pony = new_state.apps.get_model('test_crmo', 'Pony')
-        Pony.objects.create(pink=1)
-        if connection.features.supports_deferrable_unique_constraints:
-            # Unique constraint is deferred.
-            with transaction.atomic():
-                obj = Pony.objects.create(pink=1)
-                obj.pink = 2
-                obj.save()
-            # Constraint behavior can be changed with SET CONSTRAINTS.
-            with self.assertRaises(IntegrityError):
-                with transaction.atomic(), connection.cursor() as cursor:
-                    quoted_name = connection.ops.quote_name(deferred_unique_constraint.name)
-                    cursor.execute('SET CONSTRAINTS %s IMMEDIATE' % quoted_name)
-                    obj = Pony.objects.create(pink=1)
-                    obj.pink = 3
-                    obj.save()
-        else:
-            Pony.objects.create(pink=1)
-        # Reversal.
-        with connection.schema_editor() as editor:
-            operation.database_backwards('test_crmo', editor, new_state, project_state)
-        self.assertTableNotExists('test_crmo_pony')
-        # Deconstruction.
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], 'CreateModel')
-        self.assertEqual(definition[1], [])
-        self.assertEqual(
-            definition[2]['options']['constraints'],
-            [deferred_unique_constraint],
-        )
-
-    def test_create_model_managers(self):
-        """
-        The managers on a model are set.
-        """
-        project_state = self.set_up_test_model("test_cmoma")
-        # Test the state alteration
-        operation = migrations.CreateModel(
-            "Food",
-            fields=[
-                ("id", models.AutoField(primary_key=True)),
-            ],
-            managers=[
-                ("food_qs", FoodQuerySet.as_manager()),
-                ("food_mgr", FoodManager("a", "b")),
-                ("food_mgr_kwargs", FoodManager("x", "y", 3, 4)),
-            ]
-        )
-        self.assertEqual(operation.describe(), "Create model Food")
-        new_state = project_state.clone()
-        operation.state_forwards("test_cmoma", new_state)
-        self.assertIn(("test_cmoma", "food"), new_state.models)
-        managers = new_state.models["test_cmoma", "food"].managers
-        self.assertEqual(managers[0][0], "food_qs")
-        self.assertIsInstance(managers[0][1], models.Manager)
-        self.assertEqual(managers[1][0], "food_mgr")
-        self.assertIsInstance(managers[1][1], FoodManager)
-        self.assertEqual(managers[1][1].args, ("a", "b", 1, 2))
-        self.assertEqual(managers[2][0], "food_mgr_kwargs")
-        self.assertIsInstance(managers[2][1], FoodManager)
-        self.assertEqual(managers[2][1].args, ("x", "y", 3, 4))
-
-    def test_delete_model(self):
-        """
-        Tests the DeleteModel operation.
-        """
-        project_state = self.set_up_test_model("test_dlmo")
-        # Test the state alteration
-        operation = migrations.DeleteModel("Pony")
-        self.assertEqual(operation.describe(), "Delete model Pony")
-        self.assertEqual(operation.migration_name_fragment, 'delete_pony')
-        new_state = project_state.clone()
-        operation.state_forwards("test_dlmo", new_state)
-        self.assertNotIn(("test_dlmo", "pony"), new_state.models)
-        # Test the database alteration
-        self.assertTableExists("test_dlmo_pony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_dlmo", editor, project_state, new_state)
-        self.assertTableNotExists("test_dlmo_pony")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_dlmo", editor, new_state, project_state)
-        self.assertTableExists("test_dlmo_pony")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "DeleteModel")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(list(definition[2]), ["name"])
-
-    def test_delete_proxy_model(self):
-        """
-        Tests the DeleteModel operation ignores proxy models.
-        """
-        project_state = self.set_up_test_model("test_dlprmo", proxy_model=True)
-        # Test the state alteration
-        operation = migrations.DeleteModel("ProxyPony")
-        new_state = project_state.clone()
-        operation.state_forwards("test_dlprmo", new_state)
-        self.assertIn(("test_dlprmo", "proxypony"), project_state.models)
-        self.assertNotIn(("test_dlprmo", "proxypony"), new_state.models)
-        # Test the database alteration
-        self.assertTableExists("test_dlprmo_pony")
-        self.assertTableNotExists("test_dlprmo_proxypony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_dlprmo", editor, project_state, new_state)
-        self.assertTableExists("test_dlprmo_pony")
-        self.assertTableNotExists("test_dlprmo_proxypony")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_dlprmo", editor, new_state, project_state)
-        self.assertTableExists("test_dlprmo_pony")
-        self.assertTableNotExists("test_dlprmo_proxypony")
-
-    def test_delete_mti_model(self):
-        project_state = self.set_up_test_model('test_dlmtimo', mti_model=True)
-        # Test the state alteration
-        operation = migrations.DeleteModel('ShetlandPony')
-        new_state = project_state.clone()
-        operation.state_forwards('test_dlmtimo', new_state)
-        self.assertIn(('test_dlmtimo', 'shetlandpony'), project_state.models)
-        self.assertNotIn(('test_dlmtimo', 'shetlandpony'), new_state.models)
-        # Test the database alteration
-        self.assertTableExists('test_dlmtimo_pony')
-        self.assertTableExists('test_dlmtimo_shetlandpony')
-        self.assertColumnExists('test_dlmtimo_shetlandpony', 'pony_ptr_id')
-        with connection.schema_editor() as editor:
-            operation.database_forwards('test_dlmtimo', editor, project_state, new_state)
-        self.assertTableExists('test_dlmtimo_pony')
-        self.assertTableNotExists('test_dlmtimo_shetlandpony')
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards('test_dlmtimo', editor, new_state, project_state)
-        self.assertTableExists('test_dlmtimo_pony')
-        self.assertTableExists('test_dlmtimo_shetlandpony')
-        self.assertColumnExists('test_dlmtimo_shetlandpony', 'pony_ptr_id')
-
-    def test_rename_model(self):
-        """
-        Tests the RenameModel operation.
-        """
-        project_state = self.set_up_test_model("test_rnmo", related_model=True)
-        # Test the state alteration
-        operation = migrations.RenameModel("Pony", "Horse")
-        self.assertEqual(operation.describe(), "Rename model Pony to Horse")
-        self.assertEqual(operation.migration_name_fragment, 'rename_pony_horse')
-        # Test initial state and database
-        self.assertIn(("test_rnmo", "pony"), project_state.models)
-        self.assertNotIn(("test_rnmo", "horse"), project_state.models)
-        self.assertTableExists("test_rnmo_pony")
-        self.assertTableNotExists("test_rnmo_horse")
-        if connection.features.supports_foreign_keys:
-            self.assertFKExists("test_rnmo_rider", ["pony_id"], ("test_rnmo_pony", "id"))
-            self.assertFKNotExists("test_rnmo_rider", ["pony_id"], ("test_rnmo_horse", "id"))
-        # Migrate forwards
-        new_state = project_state.clone()
-        atomic_rename = connection.features.supports_atomic_references_rename
-        new_state = self.apply_operations("test_rnmo", new_state, [operation], atomic=atomic_rename)
-        # Test new state and database
-        self.assertNotIn(("test_rnmo", "pony"), new_state.models)
-        self.assertIn(("test_rnmo", "horse"), new_state.models)
-        # RenameModel also repoints all incoming FKs and M2Ms
-        self.assertEqual(
-            new_state.models['test_rnmo', 'rider'].fields['pony'].remote_field.model,
-            'test_rnmo.Horse',
-        )
-        self.assertTableNotExists("test_rnmo_pony")
-        self.assertTableExists("test_rnmo_horse")
-        if connection.features.supports_foreign_keys:
-            self.assertFKNotExists("test_rnmo_rider", ["pony_id"], ("test_rnmo_pony", "id"))
-            self.assertFKExists("test_rnmo_rider", ["pony_id"], ("test_rnmo_horse", "id"))
-        # Migrate backwards
-        original_state = self.unapply_operations("test_rnmo", project_state, [operation], atomic=atomic_rename)
-        # Test original state and database
-        self.assertIn(("test_rnmo", "pony"), original_state.models)
-        self.assertNotIn(("test_rnmo", "horse"), original_state.models)
-        self.assertEqual(
-            original_state.models['test_rnmo', 'rider'].fields['pony'].remote_field.model,
-            'Pony',
-        )
-        self.assertTableExists("test_rnmo_pony")
-        self.assertTableNotExists("test_rnmo_horse")
-        if connection.features.supports_foreign_keys:
-            self.assertFKExists("test_rnmo_rider", ["pony_id"], ("test_rnmo_pony", "id"))
-            self.assertFKNotExists("test_rnmo_rider", ["pony_id"], ("test_rnmo_horse", "id"))
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "RenameModel")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'old_name': "Pony", 'new_name': "Horse"})
-
-    def test_rename_model_state_forwards(self):
-        """
-        RenameModel operations shouldn't trigger the caching of rendered apps
-        on state without prior apps.
-        """
-        state = ProjectState()
-        state.add_model(ModelState('migrations', 'Foo', []))
-        operation = migrations.RenameModel('Foo', 'Bar')
-        operation.state_forwards('migrations', state)
-        self.assertNotIn('apps', state.__dict__)
-        self.assertNotIn(('migrations', 'foo'), state.models)
-        self.assertIn(('migrations', 'bar'), state.models)
-        # Now with apps cached.
-        apps = state.apps
-        operation = migrations.RenameModel('Bar', 'Foo')
-        operation.state_forwards('migrations', state)
-        self.assertIs(state.apps, apps)
-        self.assertNotIn(('migrations', 'bar'), state.models)
-        self.assertIn(('migrations', 'foo'), state.models)
-
-    def test_rename_model_with_self_referential_fk(self):
-        """
-        Tests the RenameModel operation on model with self referential FK.
-        """
-        project_state = self.set_up_test_model("test_rmwsrf", related_model=True)
-        # Test the state alteration
-        operation = migrations.RenameModel("Rider", "HorseRider")
-        self.assertEqual(operation.describe(), "Rename model Rider to HorseRider")
-        new_state = project_state.clone()
-        operation.state_forwards("test_rmwsrf", new_state)
-        self.assertNotIn(("test_rmwsrf", "rider"), new_state.models)
-        self.assertIn(("test_rmwsrf", "horserider"), new_state.models)
-        # Remember, RenameModel also repoints all incoming FKs and M2Ms
-        self.assertEqual(
-            'self',
-            new_state.models["test_rmwsrf", "horserider"].fields['friend'].remote_field.model
-        )
-        HorseRider = new_state.apps.get_model('test_rmwsrf', 'horserider')
-        self.assertIs(HorseRider._meta.get_field('horserider').remote_field.model, HorseRider)
-        # Test the database alteration
-        self.assertTableExists("test_rmwsrf_rider")
-        self.assertTableNotExists("test_rmwsrf_horserider")
-        if connection.features.supports_foreign_keys:
-            self.assertFKExists("test_rmwsrf_rider", ["friend_id"], ("test_rmwsrf_rider", "id"))
-            self.assertFKNotExists("test_rmwsrf_rider", ["friend_id"], ("test_rmwsrf_horserider", "id"))
-        atomic_rename = connection.features.supports_atomic_references_rename
-        with connection.schema_editor(atomic=atomic_rename) as editor:
-            operation.database_forwards("test_rmwsrf", editor, project_state, new_state)
-        self.assertTableNotExists("test_rmwsrf_rider")
-        self.assertTableExists("test_rmwsrf_horserider")
-        if connection.features.supports_foreign_keys:
-            self.assertFKNotExists("test_rmwsrf_horserider", ["friend_id"], ("test_rmwsrf_rider", "id"))
-            self.assertFKExists("test_rmwsrf_horserider", ["friend_id"], ("test_rmwsrf_horserider", "id"))
-        # And test reversal
-        with connection.schema_editor(atomic=atomic_rename) as editor:
-            operation.database_backwards("test_rmwsrf", editor, new_state, project_state)
-        self.assertTableExists("test_rmwsrf_rider")
-        self.assertTableNotExists("test_rmwsrf_horserider")
-        if connection.features.supports_foreign_keys:
-            self.assertFKExists("test_rmwsrf_rider", ["friend_id"], ("test_rmwsrf_rider", "id"))
-            self.assertFKNotExists("test_rmwsrf_rider", ["friend_id"], ("test_rmwsrf_horserider", "id"))
-
-    def test_rename_model_with_superclass_fk(self):
-        """
-        Tests the RenameModel operation on a model which has a superclass that
-        has a foreign key.
-        """
-        project_state = self.set_up_test_model("test_rmwsc", related_model=True, mti_model=True)
-        # Test the state alteration
-        operation = migrations.RenameModel("ShetlandPony", "LittleHorse")
-        self.assertEqual(operation.describe(), "Rename model ShetlandPony to LittleHorse")
-        new_state = project_state.clone()
-        operation.state_forwards("test_rmwsc", new_state)
-        self.assertNotIn(("test_rmwsc", "shetlandpony"), new_state.models)
-        self.assertIn(("test_rmwsc", "littlehorse"), new_state.models)
-        # RenameModel shouldn't repoint the superclass's relations, only local ones
-        self.assertEqual(
-            project_state.models['test_rmwsc', 'rider'].fields['pony'].remote_field.model,
-            new_state.models['test_rmwsc', 'rider'].fields['pony'].remote_field.model,
-        )
-        # Before running the migration we have a table for Shetland Pony, not Little Horse
-        self.assertTableExists("test_rmwsc_shetlandpony")
-        self.assertTableNotExists("test_rmwsc_littlehorse")
-        if connection.features.supports_foreign_keys:
-            # and the foreign key on rider points to pony, not shetland pony
-            self.assertFKExists("test_rmwsc_rider", ["pony_id"], ("test_rmwsc_pony", "id"))
-            self.assertFKNotExists("test_rmwsc_rider", ["pony_id"], ("test_rmwsc_shetlandpony", "id"))
-        with connection.schema_editor(atomic=connection.features.supports_atomic_references_rename) as editor:
-            operation.database_forwards("test_rmwsc", editor, project_state, new_state)
-        # Now we have a little horse table, not shetland pony
-        self.assertTableNotExists("test_rmwsc_shetlandpony")
-        self.assertTableExists("test_rmwsc_littlehorse")
-        if connection.features.supports_foreign_keys:
-            # but the Foreign keys still point at pony, not little horse
-            self.assertFKExists("test_rmwsc_rider", ["pony_id"], ("test_rmwsc_pony", "id"))
-            self.assertFKNotExists("test_rmwsc_rider", ["pony_id"], ("test_rmwsc_littlehorse", "id"))
-
-    def test_rename_model_with_self_referential_m2m(self):
-        app_label = "test_rename_model_with_self_referential_m2m"
-
-        project_state = self.apply_operations(app_label, ProjectState(), operations=[
-            migrations.CreateModel("ReflexivePony", fields=[
-                ("id", models.AutoField(primary_key=True)),
-                ("ponies", models.ManyToManyField("self")),
-            ]),
-        ])
-        project_state = self.apply_operations(app_label, project_state, operations=[
-            migrations.RenameModel("ReflexivePony", "ReflexivePony2"),
-        ], atomic=connection.features.supports_atomic_references_rename)
-        Pony = project_state.apps.get_model(app_label, "ReflexivePony2")
-        pony = Pony.objects.create()
-        pony.ponies.add(pony)
-
-    def test_rename_model_with_m2m(self):
-        app_label = "test_rename_model_with_m2m"
-        project_state = self.apply_operations(app_label, ProjectState(), operations=[
-            migrations.CreateModel("Rider", fields=[
-                ("id", models.AutoField(primary_key=True)),
-            ]),
-            migrations.CreateModel("Pony", fields=[
-                ("id", models.AutoField(primary_key=True)),
-                ("riders", models.ManyToManyField("Rider")),
-            ]),
-        ])
-        Pony = project_state.apps.get_model(app_label, "Pony")
-        Rider = project_state.apps.get_model(app_label, "Rider")
-        pony = Pony.objects.create()
-        rider = Rider.objects.create()
-        pony.riders.add(rider)
-
-        project_state = self.apply_operations(app_label, project_state, operations=[
-            migrations.RenameModel("Pony", "Pony2"),
-        ], atomic=connection.features.supports_atomic_references_rename)
-        Pony = project_state.apps.get_model(app_label, "Pony2")
-        Rider = project_state.apps.get_model(app_label, "Rider")
-        pony = Pony.objects.create()
-        rider = Rider.objects.create()
-        pony.riders.add(rider)
-        self.assertEqual(Pony.objects.count(), 2)
-        self.assertEqual(Rider.objects.count(), 2)
-        self.assertEqual(Pony._meta.get_field('riders').remote_field.through.objects.count(), 2)
-
-    def test_rename_m2m_target_model(self):
-        app_label = "test_rename_m2m_target_model"
-        project_state = self.apply_operations(app_label, ProjectState(), operations=[
-            migrations.CreateModel("Rider", fields=[
-                ("id", models.AutoField(primary_key=True)),
-            ]),
-            migrations.CreateModel("Pony", fields=[
-                ("id", models.AutoField(primary_key=True)),
-                ("riders", models.ManyToManyField("Rider")),
-            ]),
-        ])
-        Pony = project_state.apps.get_model(app_label, "Pony")
-        Rider = project_state.apps.get_model(app_label, "Rider")
-        pony = Pony.objects.create()
-        rider = Rider.objects.create()
-        pony.riders.add(rider)
-
-        project_state = self.apply_operations(app_label, project_state, operations=[
-            migrations.RenameModel("Rider", "Rider2"),
-        ], atomic=connection.features.supports_atomic_references_rename)
-        Pony = project_state.apps.get_model(app_label, "Pony")
-        Rider = project_state.apps.get_model(app_label, "Rider2")
-        pony = Pony.objects.create()
-        rider = Rider.objects.create()
-        pony.riders.add(rider)
-        self.assertEqual(Pony.objects.count(), 2)
-        self.assertEqual(Rider.objects.count(), 2)
-        self.assertEqual(Pony._meta.get_field('riders').remote_field.through.objects.count(), 2)
-
-    def test_rename_m2m_through_model(self):
-        app_label = "test_rename_through"
-        project_state = self.apply_operations(app_label, ProjectState(), operations=[
-            migrations.CreateModel("Rider", fields=[
-                ("id", models.AutoField(primary_key=True)),
-            ]),
-            migrations.CreateModel("Pony", fields=[
-                ("id", models.AutoField(primary_key=True)),
-            ]),
-            migrations.CreateModel("PonyRider", fields=[
-                ("id", models.AutoField(primary_key=True)),
-                ("rider", models.ForeignKey("test_rename_through.Rider", models.CASCADE)),
-                ("pony", models.ForeignKey("test_rename_through.Pony", models.CASCADE)),
-            ]),
-            migrations.AddField(
-                "Pony",
-                "riders",
-                models.ManyToManyField("test_rename_through.Rider", through="test_rename_through.PonyRider"),
-            ),
-        ])
-        Pony = project_state.apps.get_model(app_label, "Pony")
-        Rider = project_state.apps.get_model(app_label, "Rider")
-        PonyRider = project_state.apps.get_model(app_label, "PonyRider")
-        pony = Pony.objects.create()
-        rider = Rider.objects.create()
-        PonyRider.objects.create(pony=pony, rider=rider)
-
-        project_state = self.apply_operations(app_label, project_state, operations=[
-            migrations.RenameModel("PonyRider", "PonyRider2"),
-        ])
-        Pony = project_state.apps.get_model(app_label, "Pony")
-        Rider = project_state.apps.get_model(app_label, "Rider")
-        PonyRider = project_state.apps.get_model(app_label, "PonyRider2")
-        pony = Pony.objects.first()
-        rider = Rider.objects.create()
-        PonyRider.objects.create(pony=pony, rider=rider)
-        self.assertEqual(Pony.objects.count(), 1)
-        self.assertEqual(Rider.objects.count(), 2)
-        self.assertEqual(PonyRider.objects.count(), 2)
-        self.assertEqual(pony.riders.count(), 2)
-
-    def test_rename_m2m_model_after_rename_field(self):
-        """RenameModel renames a many-to-many column after a RenameField."""
-        app_label = 'test_rename_multiple'
-        project_state = self.apply_operations(app_label, ProjectState(), operations=[
-            migrations.CreateModel('Pony', fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('name', models.CharField(max_length=20)),
-            ]),
-            migrations.CreateModel('Rider', fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('pony', models.ForeignKey('test_rename_multiple.Pony', models.CASCADE)),
-            ]),
-            migrations.CreateModel('PonyRider', fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('riders', models.ManyToManyField('Rider')),
-            ]),
-            migrations.RenameField(model_name='pony', old_name='name', new_name='fancy_name'),
-            migrations.RenameModel(old_name='Rider', new_name='Jockey'),
-        ], atomic=connection.features.supports_atomic_references_rename)
-        Pony = project_state.apps.get_model(app_label, 'Pony')
-        Jockey = project_state.apps.get_model(app_label, 'Jockey')
-        PonyRider = project_state.apps.get_model(app_label, 'PonyRider')
-        # No "no such column" error means the column was renamed correctly.
-        pony = Pony.objects.create(fancy_name='a good name')
-        jockey = Jockey.objects.create(pony=pony)
-        ponyrider = PonyRider.objects.create()
-        ponyrider.riders.add(jockey)
-
-    def test_add_field(self):
-        """
-        Tests the AddField operation.
-        """
-        # Test the state alteration
-        operation = migrations.AddField(
-            "Pony",
-            "height",
-            models.FloatField(null=True, default=5),
-        )
-        self.assertEqual(operation.describe(), "Add field height to Pony")
-        self.assertEqual(operation.migration_name_fragment, 'pony_height')
-        project_state, new_state = self.make_test_state("test_adfl", operation)
-        self.assertEqual(len(new_state.models["test_adfl", "pony"].fields), 4)
-        field = new_state.models['test_adfl', 'pony'].fields['height']
-        self.assertEqual(field.default, 5)
-        # Test the database alteration
-        self.assertColumnNotExists("test_adfl_pony", "height")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_adfl", editor, project_state, new_state)
-        self.assertColumnExists("test_adfl_pony", "height")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_adfl", editor, new_state, project_state)
-        self.assertColumnNotExists("test_adfl_pony", "height")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "AddField")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(sorted(definition[2]), ["field", "model_name", "name"])
-
-    def test_add_charfield(self):
-        """
-        Tests the AddField operation on TextField.
-        """
-        project_state = self.set_up_test_model("test_adchfl")
-
-        Pony = project_state.apps.get_model("test_adchfl", "Pony")
-        pony = Pony.objects.create(weight=42)
-
-        new_state = self.apply_operations("test_adchfl", project_state, [
-            migrations.AddField(
-                "Pony",
-                "text",
-                models.CharField(max_length=10, default="some text"),
-            ),
-            migrations.AddField(
-                "Pony",
-                "empty",
-                models.CharField(max_length=10, default=""),
-            ),
-            # If not properly quoted digits would be interpreted as an int.
-            migrations.AddField(
-                "Pony",
-                "digits",
-                models.CharField(max_length=10, default="42"),
-            ),
-            # Manual quoting is fragile and could trip on quotes. Refs #xyz.
-            migrations.AddField(
-                "Pony",
-                "quotes",
-                models.CharField(max_length=10, default='"\'"'),
-            ),
-        ])
-
-        Pony = new_state.apps.get_model("test_adchfl", "Pony")
-        pony = Pony.objects.get(pk=pony.pk)
-        self.assertEqual(pony.text, "some text")
-        self.assertEqual(pony.empty, "")
-        self.assertEqual(pony.digits, "42")
-        self.assertEqual(pony.quotes, '"\'"')
-
-    def test_add_textfield(self):
-        """
-        Tests the AddField operation on TextField.
-        """
-        project_state = self.set_up_test_model("test_adtxtfl")
-
-        Pony = project_state.apps.get_model("test_adtxtfl", "Pony")
-        pony = Pony.objects.create(weight=42)
-
-        new_state = self.apply_operations("test_adtxtfl", project_state, [
-            migrations.AddField(
-                "Pony",
-                "text",
-                models.TextField(default="some text"),
-            ),
-            migrations.AddField(
-                "Pony",
-                "empty",
-                models.TextField(default=""),
-            ),
-            # If not properly quoted digits would be interpreted as an int.
-            migrations.AddField(
-                "Pony",
-                "digits",
-                models.TextField(default="42"),
-            ),
-            # Manual quoting is fragile and could trip on quotes. Refs #xyz.
-            migrations.AddField(
-                "Pony",
-                "quotes",
-                models.TextField(default='"\'"'),
-            ),
-        ])
-
-        Pony = new_state.apps.get_model("test_adtxtfl", "Pony")
-        pony = Pony.objects.get(pk=pony.pk)
-        self.assertEqual(pony.text, "some text")
-        self.assertEqual(pony.empty, "")
-        self.assertEqual(pony.digits, "42")
-        self.assertEqual(pony.quotes, '"\'"')
-
-    def test_add_binaryfield(self):
-        """
-        Tests the AddField operation on TextField/BinaryField.
-        """
-        project_state = self.set_up_test_model("test_adbinfl")
-
-        Pony = project_state.apps.get_model("test_adbinfl", "Pony")
-        pony = Pony.objects.create(weight=42)
-
-        new_state = self.apply_operations("test_adbinfl", project_state, [
-            migrations.AddField(
-                "Pony",
-                "blob",
-                models.BinaryField(default=b"some text"),
-            ),
-            migrations.AddField(
-                "Pony",
-                "empty",
-                models.BinaryField(default=b""),
-            ),
-            # If not properly quoted digits would be interpreted as an int.
-            migrations.AddField(
-                "Pony",
-                "digits",
-                models.BinaryField(default=b"42"),
-            ),
-            # Manual quoting is fragile and could trip on quotes. Refs #xyz.
-            migrations.AddField(
-                "Pony",
-                "quotes",
-                models.BinaryField(default=b'"\'"'),
-            ),
-        ])
-
-        Pony = new_state.apps.get_model("test_adbinfl", "Pony")
-        pony = Pony.objects.get(pk=pony.pk)
-        # SQLite returns buffer/memoryview, cast to bytes for checking.
-        self.assertEqual(bytes(pony.blob), b"some text")
-        self.assertEqual(bytes(pony.empty), b"")
-        self.assertEqual(bytes(pony.digits), b"42")
-        self.assertEqual(bytes(pony.quotes), b'"\'"')
-
-    def test_column_name_quoting(self):
-        """
-        Column names that are SQL keywords shouldn't cause problems when used
-        in migrations (#22168).
-        """
-        project_state = self.set_up_test_model("test_regr22168")
-        operation = migrations.AddField(
-            "Pony",
-            "order",
-            models.IntegerField(default=0),
-        )
-        new_state = project_state.clone()
-        operation.state_forwards("test_regr22168", new_state)
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_regr22168", editor, project_state, new_state)
-        self.assertColumnExists("test_regr22168_pony", "order")
-
-    def test_add_field_preserve_default(self):
-        """
-        Tests the AddField operation's state alteration
-        when preserve_default = False.
-        """
-        project_state = self.set_up_test_model("test_adflpd")
-        # Test the state alteration
-        operation = migrations.AddField(
-            "Pony",
-            "height",
-            models.FloatField(null=True, default=4),
-            preserve_default=False,
-        )
-        new_state = project_state.clone()
-        operation.state_forwards("test_adflpd", new_state)
-        self.assertEqual(len(new_state.models["test_adflpd", "pony"].fields), 4)
-        field = new_state.models['test_adflpd', 'pony'].fields['height']
-        self.assertEqual(field.default, models.NOT_PROVIDED)
-        # Test the database alteration
-        project_state.apps.get_model("test_adflpd", "pony").objects.create(
-            weight=4,
-        )
-        self.assertColumnNotExists("test_adflpd_pony", "height")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_adflpd", editor, project_state, new_state)
-        self.assertColumnExists("test_adflpd_pony", "height")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "AddField")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(sorted(definition[2]), ["field", "model_name", "name", "preserve_default"])
-
-    def test_add_field_m2m(self):
-        """
-        Tests the AddField operation with a ManyToManyField.
-        """
-        project_state = self.set_up_test_model("test_adflmm", second_model=True)
-        # Test the state alteration
-        operation = migrations.AddField("Pony", "stables", models.ManyToManyField("Stable", related_name="ponies"))
-        new_state = project_state.clone()
-        operation.state_forwards("test_adflmm", new_state)
-        self.assertEqual(len(new_state.models["test_adflmm", "pony"].fields), 4)
-        # Test the database alteration
-        self.assertTableNotExists("test_adflmm_pony_stables")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_adflmm", editor, project_state, new_state)
-        self.assertTableExists("test_adflmm_pony_stables")
-        self.assertColumnNotExists("test_adflmm_pony", "stables")
-        # Make sure the M2M field actually works
-        with atomic():
-            Pony = new_state.apps.get_model("test_adflmm", "Pony")
-            p = Pony.objects.create(pink=False, weight=4.55)
-            p.stables.create()
-            self.assertEqual(p.stables.count(), 1)
-            p.stables.all().delete()
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_adflmm", editor, new_state, project_state)
-        self.assertTableNotExists("test_adflmm_pony_stables")
-
-    def test_alter_field_m2m(self):
-        project_state = self.set_up_test_model("test_alflmm", second_model=True)
-
-        project_state = self.apply_operations("test_alflmm", project_state, operations=[
-            migrations.AddField("Pony", "stables", models.ManyToManyField("Stable", related_name="ponies"))
-        ])
-        Pony = project_state.apps.get_model("test_alflmm", "Pony")
-        self.assertFalse(Pony._meta.get_field('stables').blank)
-
-        project_state = self.apply_operations("test_alflmm", project_state, operations=[
-            migrations.AlterField(
-                "Pony", "stables", models.ManyToManyField(to="Stable", related_name="ponies", blank=True)
-            )
-        ])
-        Pony = project_state.apps.get_model("test_alflmm", "Pony")
-        self.assertTrue(Pony._meta.get_field('stables').blank)
-
-    def test_repoint_field_m2m(self):
-        project_state = self.set_up_test_model("test_alflmm", second_model=True, third_model=True)
-
-        project_state = self.apply_operations("test_alflmm", project_state, operations=[
-            migrations.AddField("Pony", "places", models.ManyToManyField("Stable", related_name="ponies"))
-        ])
-        Pony = project_state.apps.get_model("test_alflmm", "Pony")
-
-        project_state = self.apply_operations("test_alflmm", project_state, operations=[
-            migrations.AlterField("Pony", "places", models.ManyToManyField(to="Van", related_name="ponies"))
-        ])
-
-        # Ensure the new field actually works
-        Pony = project_state.apps.get_model("test_alflmm", "Pony")
-        p = Pony.objects.create(pink=False, weight=4.55)
-        p.places.create()
-        self.assertEqual(p.places.count(), 1)
-        p.places.all().delete()
-
-    def test_remove_field_m2m(self):
-        project_state = self.set_up_test_model("test_rmflmm", second_model=True)
-
-        project_state = self.apply_operations("test_rmflmm", project_state, operations=[
-            migrations.AddField("Pony", "stables", models.ManyToManyField("Stable", related_name="ponies"))
-        ])
-        self.assertTableExists("test_rmflmm_pony_stables")
-
-        with_field_state = project_state.clone()
-        operations = [migrations.RemoveField("Pony", "stables")]
-        project_state = self.apply_operations("test_rmflmm", project_state, operations=operations)
-        self.assertTableNotExists("test_rmflmm_pony_stables")
-
-        # And test reversal
-        self.unapply_operations("test_rmflmm", with_field_state, operations=operations)
-        self.assertTableExists("test_rmflmm_pony_stables")
-
-    def test_remove_field_m2m_with_through(self):
-        project_state = self.set_up_test_model("test_rmflmmwt", second_model=True)
-
-        self.assertTableNotExists("test_rmflmmwt_ponystables")
-        project_state = self.apply_operations("test_rmflmmwt", project_state, operations=[
-            migrations.CreateModel("PonyStables", fields=[
-                ("pony", models.ForeignKey('test_rmflmmwt.Pony', models.CASCADE)),
-                ("stable", models.ForeignKey('test_rmflmmwt.Stable', models.CASCADE)),
-            ]),
-            migrations.AddField(
-                "Pony", "stables",
-                models.ManyToManyField("Stable", related_name="ponies", through='test_rmflmmwt.PonyStables')
-            )
-        ])
-        self.assertTableExists("test_rmflmmwt_ponystables")
-
-        operations = [migrations.RemoveField("Pony", "stables"), migrations.DeleteModel("PonyStables")]
-        self.apply_operations("test_rmflmmwt", project_state, operations=operations)
-
-    def test_remove_field(self):
-        """
-        Tests the RemoveField operation.
-        """
-        project_state = self.set_up_test_model("test_rmfl")
-        # Test the state alteration
-        operation = migrations.RemoveField("Pony", "pink")
-        self.assertEqual(operation.describe(), "Remove field pink from Pony")
-        self.assertEqual(operation.migration_name_fragment, 'remove_pony_pink')
-        new_state = project_state.clone()
-        operation.state_forwards("test_rmfl", new_state)
-        self.assertEqual(len(new_state.models["test_rmfl", "pony"].fields), 2)
-        # Test the database alteration
-        self.assertColumnExists("test_rmfl_pony", "pink")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_rmfl", editor, project_state, new_state)
-        self.assertColumnNotExists("test_rmfl_pony", "pink")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_rmfl", editor, new_state, project_state)
-        self.assertColumnExists("test_rmfl_pony", "pink")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "RemoveField")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'model_name': "Pony", 'name': 'pink'})
-
-    def test_remove_fk(self):
-        """
-        Tests the RemoveField operation on a foreign key.
-        """
-        project_state = self.set_up_test_model("test_rfk", related_model=True)
-        self.assertColumnExists("test_rfk_rider", "pony_id")
-        operation = migrations.RemoveField("Rider", "pony")
-
-        new_state = project_state.clone()
-        operation.state_forwards("test_rfk", new_state)
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_rfk", editor, project_state, new_state)
-        self.assertColumnNotExists("test_rfk_rider", "pony_id")
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_rfk", editor, new_state, project_state)
-        self.assertColumnExists("test_rfk_rider", "pony_id")
-
-    def test_alter_model_table(self):
-        """
-        Tests the AlterModelTable operation.
-        """
-        project_state = self.set_up_test_model("test_almota")
-        # Test the state alteration
-        operation = migrations.AlterModelTable("Pony", "test_almota_pony_2")
-        self.assertEqual(operation.describe(), "Rename table for Pony to test_almota_pony_2")
-        self.assertEqual(operation.migration_name_fragment, 'alter_pony_table')
-        new_state = project_state.clone()
-        operation.state_forwards("test_almota", new_state)
-        self.assertEqual(new_state.models["test_almota", "pony"].options["db_table"], "test_almota_pony_2")
-        # Test the database alteration
-        self.assertTableExists("test_almota_pony")
-        self.assertTableNotExists("test_almota_pony_2")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_almota", editor, project_state, new_state)
-        self.assertTableNotExists("test_almota_pony")
-        self.assertTableExists("test_almota_pony_2")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_almota", editor, new_state, project_state)
-        self.assertTableExists("test_almota_pony")
-        self.assertTableNotExists("test_almota_pony_2")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "AlterModelTable")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'name': "Pony", 'table': "test_almota_pony_2"})
-
-    def test_alter_model_table_none(self):
-        """
-        Tests the AlterModelTable operation if the table name is set to None.
-        """
-        operation = migrations.AlterModelTable("Pony", None)
-        self.assertEqual(operation.describe(), "Rename table for Pony to (default)")
-
-    def test_alter_model_table_noop(self):
-        """
-        Tests the AlterModelTable operation if the table name is not changed.
-        """
-        project_state = self.set_up_test_model("test_almota")
-        # Test the state alteration
-        operation = migrations.AlterModelTable("Pony", "test_almota_pony")
-        new_state = project_state.clone()
-        operation.state_forwards("test_almota", new_state)
-        self.assertEqual(new_state.models["test_almota", "pony"].options["db_table"], "test_almota_pony")
-        # Test the database alteration
-        self.assertTableExists("test_almota_pony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_almota", editor, project_state, new_state)
-        self.assertTableExists("test_almota_pony")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_almota", editor, new_state, project_state)
-        self.assertTableExists("test_almota_pony")
-
-    def test_alter_model_table_m2m(self):
-        """
-        AlterModelTable should rename auto-generated M2M tables.
-        """
-        app_label = "test_talflmltlm2m"
-        pony_db_table = 'pony_foo'
-        project_state = self.set_up_test_model(app_label, second_model=True, db_table=pony_db_table)
-        # Add the M2M field
-        first_state = project_state.clone()
-        operation = migrations.AddField("Pony", "stables", models.ManyToManyField("Stable"))
-        operation.state_forwards(app_label, first_state)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, project_state, first_state)
-        original_m2m_table = "%s_%s" % (pony_db_table, "stables")
-        new_m2m_table = "%s_%s" % (app_label, "pony_stables")
-        self.assertTableExists(original_m2m_table)
-        self.assertTableNotExists(new_m2m_table)
-        # Rename the Pony db_table which should also rename the m2m table.
-        second_state = first_state.clone()
-        operation = migrations.AlterModelTable(name='pony', table=None)
-        operation.state_forwards(app_label, second_state)
-        atomic_rename = connection.features.supports_atomic_references_rename
-        with connection.schema_editor(atomic=atomic_rename) as editor:
-            operation.database_forwards(app_label, editor, first_state, second_state)
-        self.assertTableExists(new_m2m_table)
-        self.assertTableNotExists(original_m2m_table)
-        # And test reversal
-        with connection.schema_editor(atomic=atomic_rename) as editor:
-            operation.database_backwards(app_label, editor, second_state, first_state)
-        self.assertTableExists(original_m2m_table)
-        self.assertTableNotExists(new_m2m_table)
-
-    def test_alter_field(self):
-        """
-        Tests the AlterField operation.
-        """
-        project_state = self.set_up_test_model("test_alfl")
-        # Test the state alteration
-        operation = migrations.AlterField("Pony", "pink", models.IntegerField(null=True))
-        self.assertEqual(operation.describe(), "Alter field pink on Pony")
-        self.assertEqual(operation.migration_name_fragment, 'alter_pony_pink')
-        new_state = project_state.clone()
-        operation.state_forwards("test_alfl", new_state)
-        self.assertIs(project_state.models['test_alfl', 'pony'].fields['pink'].null, False)
-        self.assertIs(new_state.models['test_alfl', 'pony'].fields['pink'].null, True)
-        # Test the database alteration
-        self.assertColumnNotNull("test_alfl_pony", "pink")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_alfl", editor, project_state, new_state)
-        self.assertColumnNull("test_alfl_pony", "pink")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_alfl", editor, new_state, project_state)
-        self.assertColumnNotNull("test_alfl_pony", "pink")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "AlterField")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(sorted(definition[2]), ["field", "model_name", "name"])
-
-    def test_alter_field_pk(self):
-        """
-        Tests the AlterField operation on primary keys (for things like PostgreSQL's SERIAL weirdness)
-        """
-        project_state = self.set_up_test_model("test_alflpk")
-        # Test the state alteration
-        operation = migrations.AlterField("Pony", "id", models.IntegerField(primary_key=True))
-        new_state = project_state.clone()
-        operation.state_forwards("test_alflpk", new_state)
-        self.assertIsInstance(
-            project_state.models['test_alflpk', 'pony'].fields['id'],
-            models.AutoField,
-        )
-        self.assertIsInstance(
-            new_state.models['test_alflpk', 'pony'].fields['id'],
-            models.IntegerField,
-        )
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_alflpk", editor, project_state, new_state)
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_alflpk", editor, new_state, project_state)
-
-    @skipUnlessDBFeature('supports_foreign_keys')
-    def test_alter_field_pk_fk(self):
-        """
-        Tests the AlterField operation on primary keys changes any FKs pointing to it.
-        """
-        project_state = self.set_up_test_model("test_alflpkfk", related_model=True)
-        project_state = self.apply_operations('test_alflpkfk', project_state, [
-            migrations.CreateModel('Stable', fields=[
-                ('ponies', models.ManyToManyField('Pony')),
-            ]),
-            migrations.AddField(
-                'Pony',
-                'stables',
-                models.ManyToManyField('Stable'),
-            ),
-        ])
-        # Test the state alteration
-        operation = migrations.AlterField("Pony", "id", models.FloatField(primary_key=True))
-        new_state = project_state.clone()
-        operation.state_forwards("test_alflpkfk", new_state)
-        self.assertIsInstance(
-            project_state.models['test_alflpkfk', 'pony'].fields['id'],
-            models.AutoField,
-        )
-        self.assertIsInstance(
-            new_state.models['test_alflpkfk', 'pony'].fields['id'],
-            models.FloatField,
-        )
-
-        def assertIdTypeEqualsFkType():
-            with connection.cursor() as cursor:
-                id_type, id_null = [
-                    (c.type_code, c.null_ok)
-                    for c in connection.introspection.get_table_description(cursor, "test_alflpkfk_pony")
-                    if c.name == "id"
-                ][0]
-                fk_type, fk_null = [
-                    (c.type_code, c.null_ok)
-                    for c in connection.introspection.get_table_description(cursor, "test_alflpkfk_rider")
-                    if c.name == "pony_id"
-                ][0]
-                m2m_fk_type, m2m_fk_null = [
-                    (c.type_code, c.null_ok)
-                    for c in connection.introspection.get_table_description(
-                        cursor,
-                        'test_alflpkfk_pony_stables',
-                    ) if c.name == 'pony_id'
-                ][0]
-                remote_m2m_fk_type, remote_m2m_fk_null = [
-                    (c.type_code, c.null_ok)
-                    for c in connection.introspection.get_table_description(
-                        cursor,
-                        'test_alflpkfk_stable_ponies',
-                    ) if c.name == 'pony_id'
-                ][0]
-            self.assertEqual(id_type, fk_type)
-            self.assertEqual(id_type, m2m_fk_type)
-            self.assertEqual(id_type, remote_m2m_fk_type)
-            self.assertEqual(id_null, fk_null)
-            self.assertEqual(id_null, m2m_fk_null)
-            self.assertEqual(id_null, remote_m2m_fk_null)
-
-        assertIdTypeEqualsFkType()
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_alflpkfk", editor, project_state, new_state)
-        assertIdTypeEqualsFkType()
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_alflpkfk", editor, new_state, project_state)
-        assertIdTypeEqualsFkType()
-
-    @skipUnlessDBFeature('supports_foreign_keys')
-    def test_alter_field_reloads_state_on_fk_with_to_field_target_type_change(self):
-        app_label = 'test_alflrsfkwtflttc'
-        project_state = self.apply_operations(app_label, ProjectState(), operations=[
-            migrations.CreateModel('Rider', fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('code', models.IntegerField(unique=True)),
-            ]),
-            migrations.CreateModel('Pony', fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE, to_field='code')),
-            ]),
-        ])
-        operation = migrations.AlterField(
-            'Rider',
-            'code',
-            models.CharField(max_length=100, unique=True),
-        )
-        self.apply_operations(app_label, project_state, operations=[operation])
-        id_type, id_null = [
-            (c.type_code, c.null_ok)
-            for c in self.get_table_description('%s_rider' % app_label)
-            if c.name == 'code'
-        ][0]
-        fk_type, fk_null = [
-            (c.type_code, c.null_ok)
-            for c in self.get_table_description('%s_pony' % app_label)
-            if c.name == 'rider_id'
-        ][0]
-        self.assertEqual(id_type, fk_type)
-        self.assertEqual(id_null, fk_null)
-
-    @skipUnlessDBFeature('supports_foreign_keys')
-    def test_alter_field_reloads_state_on_fk_with_to_field_related_name_target_type_change(self):
-        app_label = 'test_alflrsfkwtflrnttc'
-        project_state = self.apply_operations(app_label, ProjectState(), operations=[
-            migrations.CreateModel('Rider', fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('code', models.PositiveIntegerField(unique=True)),
-            ]),
-            migrations.CreateModel('Pony', fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('rider', models.ForeignKey(
-                    '%s.Rider' % app_label,
-                    models.CASCADE,
-                    to_field='code',
-                    related_name='+',
-                )),
-            ]),
-        ])
-        operation = migrations.AlterField(
-            'Rider',
-            'code',
-            models.CharField(max_length=100, unique=True),
-        )
-        self.apply_operations(app_label, project_state, operations=[operation])
-
-    def test_alter_field_reloads_state_on_fk_target_changes(self):
-        """
-        If AlterField doesn't reload state appropriately, the second AlterField
-        crashes on MySQL due to not dropping the PonyRider.pony foreign key
-        constraint before modifying the column.
-        """
-        app_label = 'alter_alter_field_reloads_state_on_fk_target_changes'
-        project_state = self.apply_operations(app_label, ProjectState(), operations=[
-            migrations.CreateModel('Rider', fields=[
-                ('id', models.CharField(primary_key=True, max_length=100)),
-            ]),
-            migrations.CreateModel('Pony', fields=[
-                ('id', models.CharField(primary_key=True, max_length=100)),
-                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),
-            ]),
-            migrations.CreateModel('PonyRider', fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('pony', models.ForeignKey('%s.Pony' % app_label, models.CASCADE)),
-            ]),
-        ])
-        project_state = self.apply_operations(app_label, project_state, operations=[
-            migrations.AlterField('Rider', 'id', models.CharField(primary_key=True, max_length=99)),
-            migrations.AlterField('Pony', 'id', models.CharField(primary_key=True, max_length=99)),
-        ])
-
-    def test_alter_field_reloads_state_on_fk_with_to_field_target_changes(self):
-        """
-        If AlterField doesn't reload state appropriately, the second AlterField
-        crashes on MySQL due to not dropping the PonyRider.pony foreign key
-        constraint before modifying the column.
-        """
-        app_label = 'alter_alter_field_reloads_state_on_fk_with_to_field_target_changes'
-        project_state = self.apply_operations(app_label, ProjectState(), operations=[
-            migrations.CreateModel('Rider', fields=[
-                ('id', models.CharField(primary_key=True, max_length=100)),
-                ('slug', models.CharField(unique=True, max_length=100)),
-            ]),
-            migrations.CreateModel('Pony', fields=[
-                ('id', models.CharField(primary_key=True, max_length=100)),
-                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE, to_field='slug')),
-                ('slug', models.CharField(unique=True, max_length=100)),
-            ]),
-            migrations.CreateModel('PonyRider', fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('pony', models.ForeignKey('%s.Pony' % app_label, models.CASCADE, to_field='slug')),
-            ]),
-        ])
-        project_state = self.apply_operations(app_label, project_state, operations=[
-            migrations.AlterField('Rider', 'slug', models.CharField(unique=True, max_length=99)),
-            migrations.AlterField('Pony', 'slug', models.CharField(unique=True, max_length=99)),
-        ])
-
-    def test_rename_field_reloads_state_on_fk_target_changes(self):
-        """
-        If RenameField doesn't reload state appropriately, the AlterField
-        crashes on MySQL due to not dropping the PonyRider.pony foreign key
-        constraint before modifying the column.
-        """
-        app_label = 'alter_rename_field_reloads_state_on_fk_target_changes'
-        project_state = self.apply_operations(app_label, ProjectState(), operations=[
-            migrations.CreateModel('Rider', fields=[
-                ('id', models.CharField(primary_key=True, max_length=100)),
-            ]),
-            migrations.CreateModel('Pony', fields=[
-                ('id', models.CharField(primary_key=True, max_length=100)),
-                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),
-            ]),
-            migrations.CreateModel('PonyRider', fields=[
-                ('id', models.AutoField(primary_key=True)),
-                ('pony', models.ForeignKey('%s.Pony' % app_label, models.CASCADE)),
-            ]),
-        ])
-        project_state = self.apply_operations(app_label, project_state, operations=[
-            migrations.RenameField('Rider', 'id', 'id2'),
-            migrations.AlterField('Pony', 'id', models.CharField(primary_key=True, max_length=99)),
-        ], atomic=connection.features.supports_atomic_references_rename)
-
-    def test_rename_field(self):
-        """
-        Tests the RenameField operation.
-        """
-        project_state = self.set_up_test_model("test_rnfl", unique_together=True, index_together=True)
-        # Test the state alteration
-        operation = migrations.RenameField("Pony", "pink", "blue")
-        self.assertEqual(operation.describe(), "Rename field pink on Pony to blue")
-        self.assertEqual(operation.migration_name_fragment, 'rename_pink_pony_blue')
-        new_state = project_state.clone()
-        operation.state_forwards("test_rnfl", new_state)
-        self.assertIn("blue", new_state.models["test_rnfl", "pony"].fields)
-        self.assertNotIn("pink", new_state.models["test_rnfl", "pony"].fields)
-        # Make sure the unique_together has the renamed column too
-        self.assertIn("blue", new_state.models["test_rnfl", "pony"].options['unique_together'][0])
-        self.assertNotIn("pink", new_state.models["test_rnfl", "pony"].options['unique_together'][0])
-        # Make sure the index_together has the renamed column too
-        self.assertIn("blue", new_state.models["test_rnfl", "pony"].options['index_together'][0])
-        self.assertNotIn("pink", new_state.models["test_rnfl", "pony"].options['index_together'][0])
-        # Test the database alteration
-        self.assertColumnExists("test_rnfl_pony", "pink")
-        self.assertColumnNotExists("test_rnfl_pony", "blue")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_rnfl", editor, project_state, new_state)
-        self.assertColumnExists("test_rnfl_pony", "blue")
-        self.assertColumnNotExists("test_rnfl_pony", "pink")
-        # Ensure the unique constraint has been ported over
-        with connection.cursor() as cursor:
-            cursor.execute("INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)")
-            with self.assertRaises(IntegrityError):
-                with atomic():
-                    cursor.execute("INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)")
-            cursor.execute("DELETE FROM test_rnfl_pony")
-        # Ensure the index constraint has been ported over
-        self.assertIndexExists("test_rnfl_pony", ["weight", "blue"])
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_rnfl", editor, new_state, project_state)
-        self.assertColumnExists("test_rnfl_pony", "pink")
-        self.assertColumnNotExists("test_rnfl_pony", "blue")
-        # Ensure the index constraint has been reset
-        self.assertIndexExists("test_rnfl_pony", ["weight", "pink"])
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "RenameField")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'model_name': "Pony", 'old_name': "pink", 'new_name': "blue"})
-
-    def test_rename_missing_field(self):
-        state = ProjectState()
-        state.add_model(ModelState('app', 'model', []))
-        with self.assertRaisesMessage(FieldDoesNotExist, "app.model has no field named 'field'"):
-            migrations.RenameField('model', 'field', 'new_field').state_forwards('app', state)
-
-    def test_rename_referenced_field_state_forward(self):
-        state = ProjectState()
-        state.add_model(ModelState('app', 'Model', [
-            ('id', models.AutoField(primary_key=True)),
-            ('field', models.IntegerField(unique=True)),
-        ]))
-        state.add_model(ModelState('app', 'OtherModel', [
-            ('id', models.AutoField(primary_key=True)),
-            ('fk', models.ForeignKey('Model', models.CASCADE, to_field='field')),
-            ('fo', models.ForeignObject('Model', models.CASCADE, from_fields=('fk',), to_fields=('field',))),
-        ]))
-        operation = migrations.RenameField('Model', 'field', 'renamed')
-        new_state = state.clone()
-        operation.state_forwards('app', new_state)
-        self.assertEqual(new_state.models['app', 'othermodel'].fields['fk'].remote_field.field_name, 'renamed')
-        self.assertEqual(new_state.models['app', 'othermodel'].fields['fk'].from_fields, ['self'])
-        self.assertEqual(new_state.models['app', 'othermodel'].fields['fk'].to_fields, ('renamed',))
-        self.assertEqual(new_state.models['app', 'othermodel'].fields['fo'].from_fields, ('fk',))
-        self.assertEqual(new_state.models['app', 'othermodel'].fields['fo'].to_fields, ('renamed',))
-        operation = migrations.RenameField('OtherModel', 'fk', 'renamed_fk')
-        new_state = state.clone()
-        operation.state_forwards('app', new_state)
-        self.assertEqual(new_state.models['app', 'othermodel'].fields['renamed_fk'].remote_field.field_name, 'renamed')
-        self.assertEqual(new_state.models['app', 'othermodel'].fields['renamed_fk'].from_fields, ('self',))
-        self.assertEqual(new_state.models['app', 'othermodel'].fields['renamed_fk'].to_fields, ('renamed',))
-        self.assertEqual(new_state.models['app', 'othermodel'].fields['fo'].from_fields, ('renamed_fk',))
-        self.assertEqual(new_state.models['app', 'othermodel'].fields['fo'].to_fields, ('renamed',))
-
-    def test_alter_unique_together(self):
-        """
-        Tests the AlterUniqueTogether operation.
-        """
-        project_state = self.set_up_test_model("test_alunto")
-        # Test the state alteration
-        operation = migrations.AlterUniqueTogether("Pony", [("pink", "weight")])
-        self.assertEqual(operation.describe(), "Alter unique_together for Pony (1 constraint(s))")
-        self.assertEqual(
-            operation.migration_name_fragment,
-            'alter_pony_unique_together',
-        )
-        new_state = project_state.clone()
-        operation.state_forwards("test_alunto", new_state)
-        self.assertEqual(len(project_state.models["test_alunto", "pony"].options.get("unique_together", set())), 0)
-        self.assertEqual(len(new_state.models["test_alunto", "pony"].options.get("unique_together", set())), 1)
-        # Make sure we can insert duplicate rows
-        with connection.cursor() as cursor:
-            cursor.execute("INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)")
-            cursor.execute("INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)")
-            cursor.execute("DELETE FROM test_alunto_pony")
-            # Test the database alteration
-            with connection.schema_editor() as editor:
-                operation.database_forwards("test_alunto", editor, project_state, new_state)
-            cursor.execute("INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)")
-            with self.assertRaises(IntegrityError):
-                with atomic():
-                    cursor.execute("INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)")
-            cursor.execute("DELETE FROM test_alunto_pony")
-            # And test reversal
-            with connection.schema_editor() as editor:
-                operation.database_backwards("test_alunto", editor, new_state, project_state)
-            cursor.execute("INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)")
-            cursor.execute("INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)")
-            cursor.execute("DELETE FROM test_alunto_pony")
-        # Test flat unique_together
-        operation = migrations.AlterUniqueTogether("Pony", ("pink", "weight"))
-        operation.state_forwards("test_alunto", new_state)
-        self.assertEqual(len(new_state.models["test_alunto", "pony"].options.get("unique_together", set())), 1)
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "AlterUniqueTogether")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'name': "Pony", 'unique_together': {("pink", "weight")}})
-
-    def test_alter_unique_together_remove(self):
-        operation = migrations.AlterUniqueTogether("Pony", None)
-        self.assertEqual(operation.describe(), "Alter unique_together for Pony (0 constraint(s))")
-
-    def test_add_index(self):
-        """
-        Test the AddIndex operation.
-        """
-        project_state = self.set_up_test_model("test_adin")
-        msg = (
-            "Indexes passed to AddIndex operations require a name argument. "
-            "<Index: fields='pink'> doesn't have one."
-        )
-        with self.assertRaisesMessage(ValueError, msg):
-            migrations.AddIndex("Pony", models.Index(fields=["pink"]))
-        index = models.Index(fields=["pink"], name="test_adin_pony_pink_idx")
-        operation = migrations.AddIndex("Pony", index)
-        self.assertEqual(operation.describe(), "Create index test_adin_pony_pink_idx on field(s) pink of model Pony")
-        self.assertEqual(
-            operation.migration_name_fragment,
-            'pony_test_adin_pony_pink_idx',
-        )
-        new_state = project_state.clone()
-        operation.state_forwards("test_adin", new_state)
-        # Test the database alteration
-        self.assertEqual(len(new_state.models["test_adin", "pony"].options['indexes']), 1)
-        self.assertIndexNotExists("test_adin_pony", ["pink"])
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_adin", editor, project_state, new_state)
-        self.assertIndexExists("test_adin_pony", ["pink"])
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_adin", editor, new_state, project_state)
-        self.assertIndexNotExists("test_adin_pony", ["pink"])
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "AddIndex")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'model_name': "Pony", 'index': index})
-
-    def test_remove_index(self):
-        """
-        Test the RemoveIndex operation.
-        """
-        project_state = self.set_up_test_model("test_rmin", multicol_index=True)
-        self.assertTableExists("test_rmin_pony")
-        self.assertIndexExists("test_rmin_pony", ["pink", "weight"])
-        operation = migrations.RemoveIndex("Pony", "pony_test_idx")
-        self.assertEqual(operation.describe(), "Remove index pony_test_idx from Pony")
-        self.assertEqual(
-            operation.migration_name_fragment,
-            'remove_pony_pony_test_idx',
-        )
-        new_state = project_state.clone()
-        operation.state_forwards("test_rmin", new_state)
-        # Test the state alteration
-        self.assertEqual(len(new_state.models["test_rmin", "pony"].options['indexes']), 0)
-        self.assertIndexExists("test_rmin_pony", ["pink", "weight"])
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_rmin", editor, project_state, new_state)
-        self.assertIndexNotExists("test_rmin_pony", ["pink", "weight"])
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_rmin", editor, new_state, project_state)
-        self.assertIndexExists("test_rmin_pony", ["pink", "weight"])
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "RemoveIndex")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'model_name': "Pony", 'name': "pony_test_idx"})
-
-        # Also test a field dropped with index - sqlite remake issue
-        operations = [
-            migrations.RemoveIndex("Pony", "pony_test_idx"),
-            migrations.RemoveField("Pony", "pink"),
-        ]
-        self.assertColumnExists("test_rmin_pony", "pink")
-        self.assertIndexExists("test_rmin_pony", ["pink", "weight"])
-        # Test database alteration
-        new_state = project_state.clone()
-        self.apply_operations('test_rmin', new_state, operations=operations)
-        self.assertColumnNotExists("test_rmin_pony", "pink")
-        self.assertIndexNotExists("test_rmin_pony", ["pink", "weight"])
-        # And test reversal
-        self.unapply_operations("test_rmin", project_state, operations=operations)
-        self.assertIndexExists("test_rmin_pony", ["pink", "weight"])
-
-    def test_add_index_state_forwards(self):
-        project_state = self.set_up_test_model('test_adinsf')
-        index = models.Index(fields=['pink'], name='test_adinsf_pony_pink_idx')
-        old_model = project_state.apps.get_model('test_adinsf', 'Pony')
-        new_state = project_state.clone()
-
-        operation = migrations.AddIndex('Pony', index)
-        operation.state_forwards('test_adinsf', new_state)
-        new_model = new_state.apps.get_model('test_adinsf', 'Pony')
-        self.assertIsNot(old_model, new_model)
-
-    def test_remove_index_state_forwards(self):
-        project_state = self.set_up_test_model('test_rminsf')
-        index = models.Index(fields=['pink'], name='test_rminsf_pony_pink_idx')
-        migrations.AddIndex('Pony', index).state_forwards('test_rminsf', project_state)
-        old_model = project_state.apps.get_model('test_rminsf', 'Pony')
-        new_state = project_state.clone()
-
-        operation = migrations.RemoveIndex('Pony', 'test_rminsf_pony_pink_idx')
-        operation.state_forwards('test_rminsf', new_state)
-        new_model = new_state.apps.get_model('test_rminsf', 'Pony')
-        self.assertIsNot(old_model, new_model)
-
-    def test_alter_field_with_index(self):
-        """
-        Test AlterField operation with an index to ensure indexes created via
-        Meta.indexes don't get dropped with sqlite3 remake.
-        """
-        project_state = self.set_up_test_model("test_alflin", index=True)
-        operation = migrations.AlterField("Pony", "pink", models.IntegerField(null=True))
-        new_state = project_state.clone()
-        operation.state_forwards("test_alflin", new_state)
-        # Test the database alteration
-        self.assertColumnNotNull("test_alflin_pony", "pink")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_alflin", editor, project_state, new_state)
-        # Index hasn't been dropped
-        self.assertIndexExists("test_alflin_pony", ["pink"])
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_alflin", editor, new_state, project_state)
-        # Ensure the index is still there
-        self.assertIndexExists("test_alflin_pony", ["pink"])
-
-    def test_alter_index_together(self):
-        """
-        Tests the AlterIndexTogether operation.
-        """
-        project_state = self.set_up_test_model("test_alinto")
-        # Test the state alteration
-        operation = migrations.AlterIndexTogether("Pony", [("pink", "weight")])
-        self.assertEqual(operation.describe(), "Alter index_together for Pony (1 constraint(s))")
-        self.assertEqual(
-            operation.migration_name_fragment,
-            'alter_pony_index_together',
-        )
-        new_state = project_state.clone()
-        operation.state_forwards("test_alinto", new_state)
-        self.assertEqual(len(project_state.models["test_alinto", "pony"].options.get("index_together", set())), 0)
-        self.assertEqual(len(new_state.models["test_alinto", "pony"].options.get("index_together", set())), 1)
-        # Make sure there's no matching index
-        self.assertIndexNotExists("test_alinto_pony", ["pink", "weight"])
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_alinto", editor, project_state, new_state)
-        self.assertIndexExists("test_alinto_pony", ["pink", "weight"])
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_alinto", editor, new_state, project_state)
-        self.assertIndexNotExists("test_alinto_pony", ["pink", "weight"])
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "AlterIndexTogether")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'name': "Pony", 'index_together': {("pink", "weight")}})
-
-    def test_alter_index_together_remove(self):
-        operation = migrations.AlterIndexTogether("Pony", None)
-        self.assertEqual(operation.describe(), "Alter index_together for Pony (0 constraint(s))")
-
-    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')
-    def test_alter_index_together_remove_with_unique_together(self):
-        app_label = 'test_alintoremove_wunto'
-        table_name = '%s_pony' % app_label
-        project_state = self.set_up_test_model(app_label, unique_together=True)
-        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])
-        # Add index together.
-        new_state = project_state.clone()
-        operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])
-        operation.state_forwards(app_label, new_state)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, project_state, new_state)
-        self.assertIndexExists(table_name, ['pink', 'weight'])
-        # Remove index together.
-        project_state = new_state
-        new_state = project_state.clone()
-        operation = migrations.AlterIndexTogether('Pony', set())
-        operation.state_forwards(app_label, new_state)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, project_state, new_state)
-        self.assertIndexNotExists(table_name, ['pink', 'weight'])
-        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])
-
-    @skipUnlessDBFeature('supports_table_check_constraints')
-    def test_add_constraint(self):
-        project_state = self.set_up_test_model("test_addconstraint")
-        gt_check = models.Q(pink__gt=2)
-        gt_constraint = models.CheckConstraint(check=gt_check, name="test_add_constraint_pony_pink_gt_2")
-        gt_operation = migrations.AddConstraint("Pony", gt_constraint)
-        self.assertEqual(
-            gt_operation.describe(), "Create constraint test_add_constraint_pony_pink_gt_2 on model Pony"
-        )
-        self.assertEqual(
-            gt_operation.migration_name_fragment,
-            'pony_test_add_constraint_pony_pink_gt_2',
-        )
-        # Test the state alteration
-        new_state = project_state.clone()
-        gt_operation.state_forwards("test_addconstraint", new_state)
-        self.assertEqual(len(new_state.models["test_addconstraint", "pony"].options["constraints"]), 1)
-        Pony = new_state.apps.get_model("test_addconstraint", "Pony")
-        self.assertEqual(len(Pony._meta.constraints), 1)
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            gt_operation.database_forwards("test_addconstraint", editor, project_state, new_state)
-        with self.assertRaises(IntegrityError), transaction.atomic():
-            Pony.objects.create(pink=1, weight=1.0)
-        # Add another one.
-        lt_check = models.Q(pink__lt=100)
-        lt_constraint = models.CheckConstraint(check=lt_check, name="test_add_constraint_pony_pink_lt_100")
-        lt_operation = migrations.AddConstraint("Pony", lt_constraint)
-        lt_operation.state_forwards("test_addconstraint", new_state)
-        self.assertEqual(len(new_state.models["test_addconstraint", "pony"].options["constraints"]), 2)
-        Pony = new_state.apps.get_model("test_addconstraint", "Pony")
-        self.assertEqual(len(Pony._meta.constraints), 2)
-        with connection.schema_editor() as editor:
-            lt_operation.database_forwards("test_addconstraint", editor, project_state, new_state)
-        with self.assertRaises(IntegrityError), transaction.atomic():
-            Pony.objects.create(pink=100, weight=1.0)
-        # Test reversal
-        with connection.schema_editor() as editor:
-            gt_operation.database_backwards("test_addconstraint", editor, new_state, project_state)
-        Pony.objects.create(pink=1, weight=1.0)
-        # Test deconstruction
-        definition = gt_operation.deconstruct()
-        self.assertEqual(definition[0], "AddConstraint")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'model_name': "Pony", 'constraint': gt_constraint})
-
-    @skipUnlessDBFeature('supports_table_check_constraints')
-    def test_add_constraint_percent_escaping(self):
-        app_label = 'add_constraint_string_quoting'
-        operations = [
-            migrations.CreateModel(
-                'Author',
-                fields=[
-                    ('id', models.AutoField(primary_key=True)),
-                    ('name', models.CharField(max_length=100)),
-                    ('rebate', models.CharField(max_length=100)),
-                ],
-            ),
-        ]
-        from_state = self.apply_operations(app_label, ProjectState(), operations)
-        # "%" generated in startswith lookup should be escaped in a way that is
-        # considered a leading wildcard.
-        check = models.Q(name__startswith='Albert')
-        constraint = models.CheckConstraint(check=check, name='name_constraint')
-        operation = migrations.AddConstraint('Author', constraint)
-        to_state = from_state.clone()
-        operation.state_forwards(app_label, to_state)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, from_state, to_state)
-        Author = to_state.apps.get_model(app_label, 'Author')
-        with self.assertRaises(IntegrityError), transaction.atomic():
-            Author.objects.create(name='Artur')
-        # Literal "%" should be escaped in a way that is not a considered a
-        # wildcard.
-        check = models.Q(rebate__endswith='%')
-        constraint = models.CheckConstraint(check=check, name='rebate_constraint')
-        operation = migrations.AddConstraint('Author', constraint)
-        from_state = to_state
-        to_state = from_state.clone()
-        operation.state_forwards(app_label, to_state)
-        Author = to_state.apps.get_model(app_label, 'Author')
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, from_state, to_state)
-        Author = to_state.apps.get_model(app_label, 'Author')
-        with self.assertRaises(IntegrityError), transaction.atomic():
-            Author.objects.create(name='Albert', rebate='10$')
-        author = Author.objects.create(name='Albert', rebate='10%')
-        self.assertEqual(Author.objects.get(), author)
-
-    @skipUnlessDBFeature('supports_table_check_constraints')
-    def test_add_or_constraint(self):
-        app_label = 'test_addorconstraint'
-        constraint_name = 'add_constraint_or'
-        from_state = self.set_up_test_model(app_label)
-        check = models.Q(pink__gt=2, weight__gt=2) | models.Q(weight__lt=0)
-        constraint = models.CheckConstraint(check=check, name=constraint_name)
-        operation = migrations.AddConstraint('Pony', constraint)
-        to_state = from_state.clone()
-        operation.state_forwards(app_label, to_state)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, from_state, to_state)
-        Pony = to_state.apps.get_model(app_label, 'Pony')
-        with self.assertRaises(IntegrityError), transaction.atomic():
-            Pony.objects.create(pink=2, weight=3.0)
-        with self.assertRaises(IntegrityError), transaction.atomic():
-            Pony.objects.create(pink=3, weight=1.0)
-        Pony.objects.bulk_create([
-            Pony(pink=3, weight=-1.0),
-            Pony(pink=1, weight=-1.0),
-            Pony(pink=3, weight=3.0),
-        ])
-
-    @skipUnlessDBFeature('supports_table_check_constraints')
-    def test_add_constraint_combinable(self):
-        app_label = 'test_addconstraint_combinable'
-        operations = [
-            migrations.CreateModel(
-                'Book',
-                fields=[
-                    ('id', models.AutoField(primary_key=True)),
-                    ('read', models.PositiveIntegerField()),
-                    ('unread', models.PositiveIntegerField()),
-                ],
-            ),
-        ]
-        from_state = self.apply_operations(app_label, ProjectState(), operations)
-        constraint = models.CheckConstraint(
-            check=models.Q(read=(100 - models.F('unread'))),
-            name='test_addconstraint_combinable_sum_100',
-        )
-        operation = migrations.AddConstraint('Book', constraint)
-        to_state = from_state.clone()
-        operation.state_forwards(app_label, to_state)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, from_state, to_state)
-        Book = to_state.apps.get_model(app_label, 'Book')
-        with self.assertRaises(IntegrityError), transaction.atomic():
-            Book.objects.create(read=70, unread=10)
-        Book.objects.create(read=70, unread=30)
-
-    @skipUnlessDBFeature('supports_table_check_constraints')
-    def test_remove_constraint(self):
-        project_state = self.set_up_test_model("test_removeconstraint", constraints=[
-            models.CheckConstraint(check=models.Q(pink__gt=2), name="test_remove_constraint_pony_pink_gt_2"),
-            models.CheckConstraint(check=models.Q(pink__lt=100), name="test_remove_constraint_pony_pink_lt_100"),
-        ])
-        gt_operation = migrations.RemoveConstraint("Pony", "test_remove_constraint_pony_pink_gt_2")
-        self.assertEqual(
-            gt_operation.describe(), "Remove constraint test_remove_constraint_pony_pink_gt_2 from model Pony"
-        )
-        self.assertEqual(
-            gt_operation.migration_name_fragment,
-            'remove_pony_test_remove_constraint_pony_pink_gt_2',
-        )
-        # Test state alteration
-        new_state = project_state.clone()
-        gt_operation.state_forwards("test_removeconstraint", new_state)
-        self.assertEqual(len(new_state.models["test_removeconstraint", "pony"].options['constraints']), 1)
-        Pony = new_state.apps.get_model("test_removeconstraint", "Pony")
-        self.assertEqual(len(Pony._meta.constraints), 1)
-        # Test database alteration
-        with connection.schema_editor() as editor:
-            gt_operation.database_forwards("test_removeconstraint", editor, project_state, new_state)
-        Pony.objects.create(pink=1, weight=1.0).delete()
-        with self.assertRaises(IntegrityError), transaction.atomic():
-            Pony.objects.create(pink=100, weight=1.0)
-        # Remove the other one.
-        lt_operation = migrations.RemoveConstraint("Pony", "test_remove_constraint_pony_pink_lt_100")
-        lt_operation.state_forwards("test_removeconstraint", new_state)
-        self.assertEqual(len(new_state.models["test_removeconstraint", "pony"].options['constraints']), 0)
-        Pony = new_state.apps.get_model("test_removeconstraint", "Pony")
-        self.assertEqual(len(Pony._meta.constraints), 0)
-        with connection.schema_editor() as editor:
-            lt_operation.database_forwards("test_removeconstraint", editor, project_state, new_state)
-        Pony.objects.create(pink=100, weight=1.0).delete()
-        # Test reversal
-        with connection.schema_editor() as editor:
-            gt_operation.database_backwards("test_removeconstraint", editor, new_state, project_state)
-        with self.assertRaises(IntegrityError), transaction.atomic():
-            Pony.objects.create(pink=1, weight=1.0)
-        # Test deconstruction
-        definition = gt_operation.deconstruct()
-        self.assertEqual(definition[0], "RemoveConstraint")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'model_name': "Pony", 'name': "test_remove_constraint_pony_pink_gt_2"})
-
-    def test_add_partial_unique_constraint(self):
-        project_state = self.set_up_test_model('test_addpartialuniqueconstraint')
-        partial_unique_constraint = models.UniqueConstraint(
-            fields=['pink'],
-            condition=models.Q(weight__gt=5),
-            name='test_constraint_pony_pink_for_weight_gt_5_uniq',
-        )
-        operation = migrations.AddConstraint('Pony', partial_unique_constraint)
-        self.assertEqual(
-            operation.describe(),
-            'Create constraint test_constraint_pony_pink_for_weight_gt_5_uniq '
-            'on model Pony'
-        )
-        # Test the state alteration
-        new_state = project_state.clone()
-        operation.state_forwards('test_addpartialuniqueconstraint', new_state)
-        self.assertEqual(len(new_state.models['test_addpartialuniqueconstraint', 'pony'].options['constraints']), 1)
-        Pony = new_state.apps.get_model('test_addpartialuniqueconstraint', 'Pony')
-        self.assertEqual(len(Pony._meta.constraints), 1)
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            operation.database_forwards('test_addpartialuniqueconstraint', editor, project_state, new_state)
-        # Test constraint works
-        Pony.objects.create(pink=1, weight=4.0)
-        Pony.objects.create(pink=1, weight=4.0)
-        Pony.objects.create(pink=1, weight=6.0)
-        if connection.features.supports_partial_indexes:
-            with self.assertRaises(IntegrityError), transaction.atomic():
-                Pony.objects.create(pink=1, weight=7.0)
-        else:
-            Pony.objects.create(pink=1, weight=7.0)
-        # Test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards('test_addpartialuniqueconstraint', editor, new_state, project_state)
-        # Test constraint doesn't work
-        Pony.objects.create(pink=1, weight=7.0)
-        # Test deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], 'AddConstraint')
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'model_name': 'Pony', 'constraint': partial_unique_constraint})
-
-    def test_remove_partial_unique_constraint(self):
-        project_state = self.set_up_test_model('test_removepartialuniqueconstraint', constraints=[
-            models.UniqueConstraint(
-                fields=['pink'],
-                condition=models.Q(weight__gt=5),
-                name='test_constraint_pony_pink_for_weight_gt_5_uniq',
-            ),
-        ])
-        gt_operation = migrations.RemoveConstraint('Pony', 'test_constraint_pony_pink_for_weight_gt_5_uniq')
-        self.assertEqual(
-            gt_operation.describe(), 'Remove constraint test_constraint_pony_pink_for_weight_gt_5_uniq from model Pony'
-        )
-        # Test state alteration
-        new_state = project_state.clone()
-        gt_operation.state_forwards('test_removepartialuniqueconstraint', new_state)
-        self.assertEqual(len(new_state.models['test_removepartialuniqueconstraint', 'pony'].options['constraints']), 0)
-        Pony = new_state.apps.get_model('test_removepartialuniqueconstraint', 'Pony')
-        self.assertEqual(len(Pony._meta.constraints), 0)
-        # Test database alteration
-        with connection.schema_editor() as editor:
-            gt_operation.database_forwards('test_removepartialuniqueconstraint', editor, project_state, new_state)
-        # Test constraint doesn't work
-        Pony.objects.create(pink=1, weight=4.0)
-        Pony.objects.create(pink=1, weight=4.0)
-        Pony.objects.create(pink=1, weight=6.0)
-        Pony.objects.create(pink=1, weight=7.0).delete()
-        # Test reversal
-        with connection.schema_editor() as editor:
-            gt_operation.database_backwards('test_removepartialuniqueconstraint', editor, new_state, project_state)
-        # Test constraint works
-        if connection.features.supports_partial_indexes:
-            with self.assertRaises(IntegrityError), transaction.atomic():
-                Pony.objects.create(pink=1, weight=7.0)
-        else:
-            Pony.objects.create(pink=1, weight=7.0)
-        # Test deconstruction
-        definition = gt_operation.deconstruct()
-        self.assertEqual(definition[0], 'RemoveConstraint')
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {
-            'model_name': 'Pony',
-            'name': 'test_constraint_pony_pink_for_weight_gt_5_uniq',
-        })
-
-    def test_add_deferred_unique_constraint(self):
-        app_label = 'test_adddeferred_uc'
-        project_state = self.set_up_test_model(app_label)
-        deferred_unique_constraint = models.UniqueConstraint(
-            fields=['pink'],
-            name='deferred_pink_constraint_add',
-            deferrable=models.Deferrable.DEFERRED,
-        )
-        operation = migrations.AddConstraint('Pony', deferred_unique_constraint)
-        self.assertEqual(
-            operation.describe(),
-            'Create constraint deferred_pink_constraint_add on model Pony',
-        )
-        # Add constraint.
-        new_state = project_state.clone()
-        operation.state_forwards(app_label, new_state)
-        self.assertEqual(len(new_state.models[app_label, 'pony'].options['constraints']), 1)
-        Pony = new_state.apps.get_model(app_label, 'Pony')
-        self.assertEqual(len(Pony._meta.constraints), 1)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, project_state, new_state)
-        Pony.objects.create(pink=1, weight=4.0)
-        if connection.features.supports_deferrable_unique_constraints:
-            # Unique constraint is deferred.
-            with transaction.atomic():
-                obj = Pony.objects.create(pink=1, weight=4.0)
-                obj.pink = 2
-                obj.save()
-            # Constraint behavior can be changed with SET CONSTRAINTS.
-            with self.assertRaises(IntegrityError):
-                with transaction.atomic(), connection.cursor() as cursor:
-                    quoted_name = connection.ops.quote_name(deferred_unique_constraint.name)
-                    cursor.execute('SET CONSTRAINTS %s IMMEDIATE' % quoted_name)
-                    obj = Pony.objects.create(pink=1, weight=4.0)
-                    obj.pink = 3
-                    obj.save()
-        else:
-            Pony.objects.create(pink=1, weight=4.0)
-        # Reversal.
-        with connection.schema_editor() as editor:
-            operation.database_backwards(app_label, editor, new_state, project_state)
-        # Constraint doesn't work.
-        Pony.objects.create(pink=1, weight=4.0)
-        # Deconstruction.
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], 'AddConstraint')
-        self.assertEqual(definition[1], [])
-        self.assertEqual(
-            definition[2],
-            {'model_name': 'Pony', 'constraint': deferred_unique_constraint},
-        )
-
-    def test_remove_deferred_unique_constraint(self):
-        app_label = 'test_removedeferred_uc'
-        deferred_unique_constraint = models.UniqueConstraint(
-            fields=['pink'],
-            name='deferred_pink_constraint_rm',
-            deferrable=models.Deferrable.DEFERRED,
-        )
-        project_state = self.set_up_test_model(app_label, constraints=[deferred_unique_constraint])
-        operation = migrations.RemoveConstraint('Pony', deferred_unique_constraint.name)
-        self.assertEqual(
-            operation.describe(),
-            'Remove constraint deferred_pink_constraint_rm from model Pony',
-        )
-        # Remove constraint.
-        new_state = project_state.clone()
-        operation.state_forwards(app_label, new_state)
-        self.assertEqual(len(new_state.models[app_label, 'pony'].options['constraints']), 0)
-        Pony = new_state.apps.get_model(app_label, 'Pony')
-        self.assertEqual(len(Pony._meta.constraints), 0)
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, project_state, new_state)
-        # Constraint doesn't work.
-        Pony.objects.create(pink=1, weight=4.0)
-        Pony.objects.create(pink=1, weight=4.0).delete()
-        # Reversal.
-        with connection.schema_editor() as editor:
-            operation.database_backwards(app_label, editor, new_state, project_state)
-        if connection.features.supports_deferrable_unique_constraints:
-            # Unique constraint is deferred.
-            with transaction.atomic():
-                obj = Pony.objects.create(pink=1, weight=4.0)
-                obj.pink = 2
-                obj.save()
-            # Constraint behavior can be changed with SET CONSTRAINTS.
-            with self.assertRaises(IntegrityError):
-                with transaction.atomic(), connection.cursor() as cursor:
-                    quoted_name = connection.ops.quote_name(deferred_unique_constraint.name)
-                    cursor.execute('SET CONSTRAINTS %s IMMEDIATE' % quoted_name)
-                    obj = Pony.objects.create(pink=1, weight=4.0)
-                    obj.pink = 3
-                    obj.save()
-        else:
-            Pony.objects.create(pink=1, weight=4.0)
-        # Deconstruction.
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], 'RemoveConstraint')
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {
-            'model_name': 'Pony',
-            'name': 'deferred_pink_constraint_rm',
-        })
-
-    def test_alter_model_options(self):
-        """
-        Tests the AlterModelOptions operation.
-        """
-        project_state = self.set_up_test_model("test_almoop")
-        # Test the state alteration (no DB alteration to test)
-        operation = migrations.AlterModelOptions("Pony", {"permissions": [("can_groom", "Can groom")]})
-        self.assertEqual(operation.describe(), "Change Meta options on Pony")
-        self.assertEqual(operation.migration_name_fragment, 'alter_pony_options')
-        new_state = project_state.clone()
-        operation.state_forwards("test_almoop", new_state)
-        self.assertEqual(len(project_state.models["test_almoop", "pony"].options.get("permissions", [])), 0)
-        self.assertEqual(len(new_state.models["test_almoop", "pony"].options.get("permissions", [])), 1)
-        self.assertEqual(new_state.models["test_almoop", "pony"].options["permissions"][0][0], "can_groom")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "AlterModelOptions")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'name': "Pony", 'options': {"permissions": [("can_groom", "Can groom")]}})
-
-    def test_alter_model_options_emptying(self):
-        """
-        The AlterModelOptions operation removes keys from the dict (#23121)
-        """
-        project_state = self.set_up_test_model("test_almoop", options=True)
-        # Test the state alteration (no DB alteration to test)
-        operation = migrations.AlterModelOptions("Pony", {})
-        self.assertEqual(operation.describe(), "Change Meta options on Pony")
-        new_state = project_state.clone()
-        operation.state_forwards("test_almoop", new_state)
-        self.assertEqual(len(project_state.models["test_almoop", "pony"].options.get("permissions", [])), 1)
-        self.assertEqual(len(new_state.models["test_almoop", "pony"].options.get("permissions", [])), 0)
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "AlterModelOptions")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'name': "Pony", 'options': {}})
-
-    def test_alter_order_with_respect_to(self):
-        """
-        Tests the AlterOrderWithRespectTo operation.
-        """
-        project_state = self.set_up_test_model("test_alorwrtto", related_model=True)
-        # Test the state alteration
-        operation = migrations.AlterOrderWithRespectTo("Rider", "pony")
-        self.assertEqual(operation.describe(), "Set order_with_respect_to on Rider to pony")
-        self.assertEqual(
-            operation.migration_name_fragment,
-            'alter_rider_order_with_respect_to',
-        )
-        new_state = project_state.clone()
-        operation.state_forwards("test_alorwrtto", new_state)
-        self.assertIsNone(
-            project_state.models["test_alorwrtto", "rider"].options.get("order_with_respect_to", None)
-        )
-        self.assertEqual(
-            new_state.models["test_alorwrtto", "rider"].options.get("order_with_respect_to", None),
-            "pony"
-        )
-        # Make sure there's no matching index
-        self.assertColumnNotExists("test_alorwrtto_rider", "_order")
-        # Create some rows before alteration
-        rendered_state = project_state.apps
-        pony = rendered_state.get_model("test_alorwrtto", "Pony").objects.create(weight=50)
-        rendered_state.get_model("test_alorwrtto", "Rider").objects.create(pony=pony, friend_id=1)
-        rendered_state.get_model("test_alorwrtto", "Rider").objects.create(pony=pony, friend_id=2)
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_alorwrtto", editor, project_state, new_state)
-        self.assertColumnExists("test_alorwrtto_rider", "_order")
-        # Check for correct value in rows
-        updated_riders = new_state.apps.get_model("test_alorwrtto", "Rider").objects.all()
-        self.assertEqual(updated_riders[0]._order, 0)
-        self.assertEqual(updated_riders[1]._order, 0)
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_alorwrtto", editor, new_state, project_state)
-        self.assertColumnNotExists("test_alorwrtto_rider", "_order")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "AlterOrderWithRespectTo")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(definition[2], {'name': "Rider", 'order_with_respect_to': "pony"})
-
-    def test_alter_model_managers(self):
-        """
-        The managers on a model are set.
-        """
-        project_state = self.set_up_test_model("test_almoma")
-        # Test the state alteration
-        operation = migrations.AlterModelManagers(
-            "Pony",
-            managers=[
-                ("food_qs", FoodQuerySet.as_manager()),
-                ("food_mgr", FoodManager("a", "b")),
-                ("food_mgr_kwargs", FoodManager("x", "y", 3, 4)),
-            ]
-        )
-        self.assertEqual(operation.describe(), "Change managers on Pony")
-        self.assertEqual(operation.migration_name_fragment, 'alter_pony_managers')
-        managers = project_state.models["test_almoma", "pony"].managers
-        self.assertEqual(managers, [])
-
-        new_state = project_state.clone()
-        operation.state_forwards("test_almoma", new_state)
-        self.assertIn(("test_almoma", "pony"), new_state.models)
-        managers = new_state.models["test_almoma", "pony"].managers
-        self.assertEqual(managers[0][0], "food_qs")
-        self.assertIsInstance(managers[0][1], models.Manager)
-        self.assertEqual(managers[1][0], "food_mgr")
-        self.assertIsInstance(managers[1][1], FoodManager)
-        self.assertEqual(managers[1][1].args, ("a", "b", 1, 2))
-        self.assertEqual(managers[2][0], "food_mgr_kwargs")
-        self.assertIsInstance(managers[2][1], FoodManager)
-        self.assertEqual(managers[2][1].args, ("x", "y", 3, 4))
-        rendered_state = new_state.apps
-        model = rendered_state.get_model('test_almoma', 'pony')
-        self.assertIsInstance(model.food_qs, models.Manager)
-        self.assertIsInstance(model.food_mgr, FoodManager)
-        self.assertIsInstance(model.food_mgr_kwargs, FoodManager)
-
-    def test_alter_model_managers_emptying(self):
-        """
-        The managers on a model are set.
-        """
-        project_state = self.set_up_test_model("test_almomae", manager_model=True)
-        # Test the state alteration
-        operation = migrations.AlterModelManagers("Food", managers=[])
-        self.assertEqual(operation.describe(), "Change managers on Food")
-        self.assertIn(("test_almomae", "food"), project_state.models)
-        managers = project_state.models["test_almomae", "food"].managers
-        self.assertEqual(managers[0][0], "food_qs")
-        self.assertIsInstance(managers[0][1], models.Manager)
-        self.assertEqual(managers[1][0], "food_mgr")
-        self.assertIsInstance(managers[1][1], FoodManager)
-        self.assertEqual(managers[1][1].args, ("a", "b", 1, 2))
-        self.assertEqual(managers[2][0], "food_mgr_kwargs")
-        self.assertIsInstance(managers[2][1], FoodManager)
-        self.assertEqual(managers[2][1].args, ("x", "y", 3, 4))
-
-        new_state = project_state.clone()
-        operation.state_forwards("test_almomae", new_state)
-        managers = new_state.models["test_almomae", "food"].managers
-        self.assertEqual(managers, [])
-
-    def test_alter_fk(self):
-        """
-        Creating and then altering an FK works correctly
-        and deals with the pending SQL (#23091)
-        """
-        project_state = self.set_up_test_model("test_alfk")
-        # Test adding and then altering the FK in one go
-        create_operation = migrations.CreateModel(
-            name="Rider",
-            fields=[
-                ("id", models.AutoField(primary_key=True)),
-                ("pony", models.ForeignKey("Pony", models.CASCADE)),
-            ],
-        )
-        create_state = project_state.clone()
-        create_operation.state_forwards("test_alfk", create_state)
-        alter_operation = migrations.AlterField(
-            model_name='Rider',
-            name='pony',
-            field=models.ForeignKey("Pony", models.CASCADE, editable=False),
-        )
-        alter_state = create_state.clone()
-        alter_operation.state_forwards("test_alfk", alter_state)
-        with connection.schema_editor() as editor:
-            create_operation.database_forwards("test_alfk", editor, project_state, create_state)
-            alter_operation.database_forwards("test_alfk", editor, create_state, alter_state)
-
-    def test_alter_fk_non_fk(self):
-        """
-        Altering an FK to a non-FK works (#23244)
-        """
-        # Test the state alteration
-        operation = migrations.AlterField(
-            model_name="Rider",
-            name="pony",
-            field=models.FloatField(),
-        )
-        project_state, new_state = self.make_test_state("test_afknfk", operation, related_model=True)
-        # Test the database alteration
-        self.assertColumnExists("test_afknfk_rider", "pony_id")
-        self.assertColumnNotExists("test_afknfk_rider", "pony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_afknfk", editor, project_state, new_state)
-        self.assertColumnExists("test_afknfk_rider", "pony")
-        self.assertColumnNotExists("test_afknfk_rider", "pony_id")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_afknfk", editor, new_state, project_state)
-        self.assertColumnExists("test_afknfk_rider", "pony_id")
-        self.assertColumnNotExists("test_afknfk_rider", "pony")
-
-    def test_run_sql(self):
-        """
-        Tests the RunSQL operation.
-        """
-        project_state = self.set_up_test_model("test_runsql")
-        # Create the operation
-        operation = migrations.RunSQL(
-            # Use a multi-line string with a comment to test splitting on SQLite and MySQL respectively
-            "CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\n"
-            "INSERT INTO i_love_ponies (id, special_thing) VALUES (1, 'i love ponies'); -- this is magic!\n"
-            "INSERT INTO i_love_ponies (id, special_thing) VALUES (2, 'i love django');\n"
-            "UPDATE i_love_ponies SET special_thing = 'Ponies' WHERE special_thing LIKE '%%ponies';"
-            "UPDATE i_love_ponies SET special_thing = 'Django' WHERE special_thing LIKE '%django';",
-
-            # Run delete queries to test for parameter substitution failure
-            # reported in #23426
-            "DELETE FROM i_love_ponies WHERE special_thing LIKE '%Django%';"
-            "DELETE FROM i_love_ponies WHERE special_thing LIKE '%%Ponies%%';"
-            "DROP TABLE i_love_ponies",
-
-            state_operations=[migrations.CreateModel("SomethingElse", [("id", models.AutoField(primary_key=True))])],
-        )
-        self.assertEqual(operation.describe(), "Raw SQL operation")
-        # Test the state alteration
-        new_state = project_state.clone()
-        operation.state_forwards("test_runsql", new_state)
-        self.assertEqual(len(new_state.models["test_runsql", "somethingelse"].fields), 1)
-        # Make sure there's no table
-        self.assertTableNotExists("i_love_ponies")
-        # Test SQL collection
-        with connection.schema_editor(collect_sql=True) as editor:
-            operation.database_forwards("test_runsql", editor, project_state, new_state)
-            self.assertIn("LIKE '%%ponies';", "\n".join(editor.collected_sql))
-            operation.database_backwards("test_runsql", editor, project_state, new_state)
-            self.assertIn("LIKE '%%Ponies%%';", "\n".join(editor.collected_sql))
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_runsql", editor, project_state, new_state)
-        self.assertTableExists("i_love_ponies")
-        # Make sure all the SQL was processed
-        with connection.cursor() as cursor:
-            cursor.execute("SELECT COUNT(*) FROM i_love_ponies")
-            self.assertEqual(cursor.fetchall()[0][0], 2)
-            cursor.execute("SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Django'")
-            self.assertEqual(cursor.fetchall()[0][0], 1)
-            cursor.execute("SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Ponies'")
-            self.assertEqual(cursor.fetchall()[0][0], 1)
-        # And test reversal
-        self.assertTrue(operation.reversible)
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_runsql", editor, new_state, project_state)
-        self.assertTableNotExists("i_love_ponies")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "RunSQL")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(sorted(definition[2]), ["reverse_sql", "sql", "state_operations"])
-        # And elidable reduction
-        self.assertIs(False, operation.reduce(operation, []))
-        elidable_operation = migrations.RunSQL('SELECT 1 FROM void;', elidable=True)
-        self.assertEqual(elidable_operation.reduce(operation, []), [operation])
-
-    def test_run_sql_params(self):
-        """
-        #23426 - RunSQL should accept parameters.
-        """
-        project_state = self.set_up_test_model("test_runsql")
-        # Create the operation
-        operation = migrations.RunSQL(
-            ["CREATE TABLE i_love_ponies (id int, special_thing varchar(15));"],
-            ["DROP TABLE i_love_ponies"],
-        )
-        param_operation = migrations.RunSQL(
-            # forwards
-            (
-                "INSERT INTO i_love_ponies (id, special_thing) VALUES (1, 'Django');",
-                ["INSERT INTO i_love_ponies (id, special_thing) VALUES (2, %s);", ['Ponies']],
-                ("INSERT INTO i_love_ponies (id, special_thing) VALUES (%s, %s);", (3, 'Python',)),
-            ),
-            # backwards
-            [
-                "DELETE FROM i_love_ponies WHERE special_thing = 'Django';",
-                ["DELETE FROM i_love_ponies WHERE special_thing = 'Ponies';", None],
-                ("DELETE FROM i_love_ponies WHERE id = %s OR special_thing = %s;", [3, 'Python']),
-            ]
-        )
-
-        # Make sure there's no table
-        self.assertTableNotExists("i_love_ponies")
-        new_state = project_state.clone()
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_runsql", editor, project_state, new_state)
-
-        # Test parameter passing
-        with connection.schema_editor() as editor:
-            param_operation.database_forwards("test_runsql", editor, project_state, new_state)
-        # Make sure all the SQL was processed
-        with connection.cursor() as cursor:
-            cursor.execute("SELECT COUNT(*) FROM i_love_ponies")
-            self.assertEqual(cursor.fetchall()[0][0], 3)
-
-        with connection.schema_editor() as editor:
-            param_operation.database_backwards("test_runsql", editor, new_state, project_state)
-        with connection.cursor() as cursor:
-            cursor.execute("SELECT COUNT(*) FROM i_love_ponies")
-            self.assertEqual(cursor.fetchall()[0][0], 0)
-
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_runsql", editor, new_state, project_state)
-        self.assertTableNotExists("i_love_ponies")
-
-    def test_run_sql_params_invalid(self):
-        """
-        #23426 - RunSQL should fail when a list of statements with an incorrect
-        number of tuples is given.
-        """
-        project_state = self.set_up_test_model("test_runsql")
-        new_state = project_state.clone()
-        operation = migrations.RunSQL(
-            # forwards
-            [
-                ["INSERT INTO foo (bar) VALUES ('buz');"]
-            ],
-            # backwards
-            (
-                ("DELETE FROM foo WHERE bar = 'buz';", 'invalid', 'parameter count'),
-            ),
-        )
-
-        with connection.schema_editor() as editor:
-            with self.assertRaisesMessage(ValueError, "Expected a 2-tuple but got 1"):
-                operation.database_forwards("test_runsql", editor, project_state, new_state)
-
-        with connection.schema_editor() as editor:
-            with self.assertRaisesMessage(ValueError, "Expected a 2-tuple but got 3"):
-                operation.database_backwards("test_runsql", editor, new_state, project_state)
-
-    def test_run_sql_noop(self):
-        """
-        #24098 - Tests no-op RunSQL operations.
-        """
-        operation = migrations.RunSQL(migrations.RunSQL.noop, migrations.RunSQL.noop)
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_runsql", editor, None, None)
-            operation.database_backwards("test_runsql", editor, None, None)
-
-    def test_run_python(self):
-        """
-        Tests the RunPython operation
-        """
-
-        project_state = self.set_up_test_model("test_runpython", mti_model=True)
-
-        # Create the operation
-        def inner_method(models, schema_editor):
-            Pony = models.get_model("test_runpython", "Pony")
-            Pony.objects.create(pink=1, weight=3.55)
-            Pony.objects.create(weight=5)
-
-        def inner_method_reverse(models, schema_editor):
-            Pony = models.get_model("test_runpython", "Pony")
-            Pony.objects.filter(pink=1, weight=3.55).delete()
-            Pony.objects.filter(weight=5).delete()
-        operation = migrations.RunPython(inner_method, reverse_code=inner_method_reverse)
-        self.assertEqual(operation.describe(), "Raw Python operation")
-        # Test the state alteration does nothing
-        new_state = project_state.clone()
-        operation.state_forwards("test_runpython", new_state)
-        self.assertEqual(new_state, project_state)
-        # Test the database alteration
-        self.assertEqual(project_state.apps.get_model("test_runpython", "Pony").objects.count(), 0)
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_runpython", editor, project_state, new_state)
-        self.assertEqual(project_state.apps.get_model("test_runpython", "Pony").objects.count(), 2)
-        # Now test reversal
-        self.assertTrue(operation.reversible)
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_runpython", editor, project_state, new_state)
-        self.assertEqual(project_state.apps.get_model("test_runpython", "Pony").objects.count(), 0)
-        # Now test we can't use a string
-        with self.assertRaisesMessage(ValueError, 'RunPython must be supplied with a callable'):
-            migrations.RunPython("print 'ahahaha'")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "RunPython")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(sorted(definition[2]), ["code", "reverse_code"])
-
-        # Also test reversal fails, with an operation identical to above but without reverse_code set
-        no_reverse_operation = migrations.RunPython(inner_method)
-        self.assertFalse(no_reverse_operation.reversible)
-        with connection.schema_editor() as editor:
-            no_reverse_operation.database_forwards("test_runpython", editor, project_state, new_state)
-            with self.assertRaises(NotImplementedError):
-                no_reverse_operation.database_backwards("test_runpython", editor, new_state, project_state)
-        self.assertEqual(project_state.apps.get_model("test_runpython", "Pony").objects.count(), 2)
-
-        def create_ponies(models, schema_editor):
-            Pony = models.get_model("test_runpython", "Pony")
-            pony1 = Pony.objects.create(pink=1, weight=3.55)
-            self.assertIsNot(pony1.pk, None)
-            pony2 = Pony.objects.create(weight=5)
-            self.assertIsNot(pony2.pk, None)
-            self.assertNotEqual(pony1.pk, pony2.pk)
-
-        operation = migrations.RunPython(create_ponies)
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_runpython", editor, project_state, new_state)
-        self.assertEqual(project_state.apps.get_model("test_runpython", "Pony").objects.count(), 4)
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "RunPython")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(sorted(definition[2]), ["code"])
-
-        def create_shetlandponies(models, schema_editor):
-            ShetlandPony = models.get_model("test_runpython", "ShetlandPony")
-            pony1 = ShetlandPony.objects.create(weight=4.0)
-            self.assertIsNot(pony1.pk, None)
-            pony2 = ShetlandPony.objects.create(weight=5.0)
-            self.assertIsNot(pony2.pk, None)
-            self.assertNotEqual(pony1.pk, pony2.pk)
-
-        operation = migrations.RunPython(create_shetlandponies)
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_runpython", editor, project_state, new_state)
-        self.assertEqual(project_state.apps.get_model("test_runpython", "Pony").objects.count(), 6)
-        self.assertEqual(project_state.apps.get_model("test_runpython", "ShetlandPony").objects.count(), 2)
-        # And elidable reduction
-        self.assertIs(False, operation.reduce(operation, []))
-        elidable_operation = migrations.RunPython(inner_method, elidable=True)
-        self.assertEqual(elidable_operation.reduce(operation, []), [operation])
-
-    def test_run_python_atomic(self):
-        """
-        Tests the RunPython operation correctly handles the "atomic" keyword
-        """
-        project_state = self.set_up_test_model("test_runpythonatomic", mti_model=True)
-
-        def inner_method(models, schema_editor):
-            Pony = models.get_model("test_runpythonatomic", "Pony")
-            Pony.objects.create(pink=1, weight=3.55)
-            raise ValueError("Adrian hates ponies.")
-
-        # Verify atomicity when applying.
-        atomic_migration = Migration("test", "test_runpythonatomic")
-        atomic_migration.operations = [migrations.RunPython(inner_method, reverse_code=inner_method)]
-        non_atomic_migration = Migration("test", "test_runpythonatomic")
-        non_atomic_migration.operations = [migrations.RunPython(inner_method, reverse_code=inner_method, atomic=False)]
-        # If we're a fully-transactional database, both versions should rollback
-        if connection.features.can_rollback_ddl:
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 0)
-            with self.assertRaises(ValueError):
-                with connection.schema_editor() as editor:
-                    atomic_migration.apply(project_state, editor)
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 0)
-            with self.assertRaises(ValueError):
-                with connection.schema_editor() as editor:
-                    non_atomic_migration.apply(project_state, editor)
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 0)
-        # Otherwise, the non-atomic operation should leave a row there
-        else:
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 0)
-            with self.assertRaises(ValueError):
-                with connection.schema_editor() as editor:
-                    atomic_migration.apply(project_state, editor)
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 0)
-            with self.assertRaises(ValueError):
-                with connection.schema_editor() as editor:
-                    non_atomic_migration.apply(project_state, editor)
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 1)
-        # Reset object count to zero and verify atomicity when unapplying.
-        project_state.apps.get_model("test_runpythonatomic", "Pony").objects.all().delete()
-        # On a fully-transactional database, both versions rollback.
-        if connection.features.can_rollback_ddl:
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 0)
-            with self.assertRaises(ValueError):
-                with connection.schema_editor() as editor:
-                    atomic_migration.unapply(project_state, editor)
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 0)
-            with self.assertRaises(ValueError):
-                with connection.schema_editor() as editor:
-                    non_atomic_migration.unapply(project_state, editor)
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 0)
-        # Otherwise, the non-atomic operation leaves a row there.
-        else:
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 0)
-            with self.assertRaises(ValueError):
-                with connection.schema_editor() as editor:
-                    atomic_migration.unapply(project_state, editor)
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 0)
-            with self.assertRaises(ValueError):
-                with connection.schema_editor() as editor:
-                    non_atomic_migration.unapply(project_state, editor)
-            self.assertEqual(project_state.apps.get_model("test_runpythonatomic", "Pony").objects.count(), 1)
-        # Verify deconstruction.
-        definition = non_atomic_migration.operations[0].deconstruct()
-        self.assertEqual(definition[0], "RunPython")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(sorted(definition[2]), ["atomic", "code", "reverse_code"])
-
-    def test_run_python_related_assignment(self):
-        """
-        #24282 - Model changes to a FK reverse side update the model
-        on the FK side as well.
-        """
-
-        def inner_method(models, schema_editor):
-            Author = models.get_model("test_authors", "Author")
-            Book = models.get_model("test_books", "Book")
-            author = Author.objects.create(name="Hemingway")
-            Book.objects.create(title="Old Man and The Sea", author=author)
-
-        create_author = migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=100)),
-            ],
-            options={},
-        )
-        create_book = migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("title", models.CharField(max_length=100)),
-                ("author", models.ForeignKey("test_authors.Author", models.CASCADE))
-            ],
-            options={},
-        )
-        add_hometown = migrations.AddField(
-            "Author",
-            "hometown",
-            models.CharField(max_length=100),
-        )
-        create_old_man = migrations.RunPython(inner_method, inner_method)
-
-        project_state = ProjectState()
-        new_state = project_state.clone()
-        with connection.schema_editor() as editor:
-            create_author.state_forwards("test_authors", new_state)
-            create_author.database_forwards("test_authors", editor, project_state, new_state)
-        project_state = new_state
-        new_state = new_state.clone()
-        with connection.schema_editor() as editor:
-            create_book.state_forwards("test_books", new_state)
-            create_book.database_forwards("test_books", editor, project_state, new_state)
-        project_state = new_state
-        new_state = new_state.clone()
-        with connection.schema_editor() as editor:
-            add_hometown.state_forwards("test_authors", new_state)
-            add_hometown.database_forwards("test_authors", editor, project_state, new_state)
-        project_state = new_state
-        new_state = new_state.clone()
-        with connection.schema_editor() as editor:
-            create_old_man.state_forwards("test_books", new_state)
-            create_old_man.database_forwards("test_books", editor, project_state, new_state)
-
-    def test_model_with_bigautofield(self):
-        """
-        A model with BigAutoField can be created.
-        """
-        def create_data(models, schema_editor):
-            Author = models.get_model("test_author", "Author")
-            Book = models.get_model("test_book", "Book")
-            author1 = Author.objects.create(name="Hemingway")
-            Book.objects.create(title="Old Man and The Sea", author=author1)
-            Book.objects.create(id=2 ** 33, title="A farewell to arms", author=author1)
-
-            author2 = Author.objects.create(id=2 ** 33, name="Remarque")
-            Book.objects.create(title="All quiet on the western front", author=author2)
-            Book.objects.create(title="Arc de Triomphe", author=author2)
-
-        create_author = migrations.CreateModel(
-            "Author",
-            [
-                ("id", models.BigAutoField(primary_key=True)),
-                ("name", models.CharField(max_length=100)),
-            ],
-            options={},
-        )
-        create_book = migrations.CreateModel(
-            "Book",
-            [
-                ("id", models.BigAutoField(primary_key=True)),
-                ("title", models.CharField(max_length=100)),
-                ("author", models.ForeignKey(to="test_author.Author", on_delete=models.CASCADE))
-            ],
-            options={},
-        )
-        fill_data = migrations.RunPython(create_data)
-
-        project_state = ProjectState()
-        new_state = project_state.clone()
-        with connection.schema_editor() as editor:
-            create_author.state_forwards("test_author", new_state)
-            create_author.database_forwards("test_author", editor, project_state, new_state)
-
-        project_state = new_state
-        new_state = new_state.clone()
-        with connection.schema_editor() as editor:
-            create_book.state_forwards("test_book", new_state)
-            create_book.database_forwards("test_book", editor, project_state, new_state)
-
-        project_state = new_state
-        new_state = new_state.clone()
-        with connection.schema_editor() as editor:
-            fill_data.state_forwards("fill_data", new_state)
-            fill_data.database_forwards("fill_data", editor, project_state, new_state)
-
-    def _test_autofield_foreignfield_growth(self, source_field, target_field, target_value):
-        """
-        A field may be migrated in the following ways:
-
-        - AutoField to BigAutoField
-        - SmallAutoField to AutoField
-        - SmallAutoField to BigAutoField
-        """
-        def create_initial_data(models, schema_editor):
-            Article = models.get_model("test_article", "Article")
-            Blog = models.get_model("test_blog", "Blog")
-            blog = Blog.objects.create(name="web development done right")
-            Article.objects.create(name="Frameworks", blog=blog)
-            Article.objects.create(name="Programming Languages", blog=blog)
-
-        def create_big_data(models, schema_editor):
-            Article = models.get_model("test_article", "Article")
-            Blog = models.get_model("test_blog", "Blog")
-            blog2 = Blog.objects.create(name="Frameworks", id=target_value)
-            Article.objects.create(name="Django", blog=blog2)
-            Article.objects.create(id=target_value, name="Django2", blog=blog2)
-
-        create_blog = migrations.CreateModel(
-            "Blog",
-            [
-                ("id", source_field(primary_key=True)),
-                ("name", models.CharField(max_length=100)),
-            ],
-            options={},
-        )
-        create_article = migrations.CreateModel(
-            "Article",
-            [
-                ("id", source_field(primary_key=True)),
-                ("blog", models.ForeignKey(to="test_blog.Blog", on_delete=models.CASCADE)),
-                ("name", models.CharField(max_length=100)),
-                ("data", models.TextField(default="")),
-            ],
-            options={},
-        )
-        fill_initial_data = migrations.RunPython(create_initial_data, create_initial_data)
-        fill_big_data = migrations.RunPython(create_big_data, create_big_data)
-
-        grow_article_id = migrations.AlterField('Article', 'id', target_field(primary_key=True))
-        grow_blog_id = migrations.AlterField('Blog', 'id', target_field(primary_key=True))
-
-        project_state = ProjectState()
-        new_state = project_state.clone()
-        with connection.schema_editor() as editor:
-            create_blog.state_forwards("test_blog", new_state)
-            create_blog.database_forwards("test_blog", editor, project_state, new_state)
-
-        project_state = new_state
-        new_state = new_state.clone()
-        with connection.schema_editor() as editor:
-            create_article.state_forwards("test_article", new_state)
-            create_article.database_forwards("test_article", editor, project_state, new_state)
-
-        project_state = new_state
-        new_state = new_state.clone()
-        with connection.schema_editor() as editor:
-            fill_initial_data.state_forwards("fill_initial_data", new_state)
-            fill_initial_data.database_forwards("fill_initial_data", editor, project_state, new_state)
-
-        project_state = new_state
-        new_state = new_state.clone()
-        with connection.schema_editor() as editor:
-            grow_article_id.state_forwards("test_article", new_state)
-            grow_article_id.database_forwards("test_article", editor, project_state, new_state)
-
-        state = new_state.clone()
-        article = state.apps.get_model("test_article.Article")
-        self.assertIsInstance(article._meta.pk, target_field)
-
-        project_state = new_state
-        new_state = new_state.clone()
-        with connection.schema_editor() as editor:
-            grow_blog_id.state_forwards("test_blog", new_state)
-            grow_blog_id.database_forwards("test_blog", editor, project_state, new_state)
-
-        state = new_state.clone()
-        blog = state.apps.get_model("test_blog.Blog")
-        self.assertIsInstance(blog._meta.pk, target_field)
-
-        project_state = new_state
-        new_state = new_state.clone()
-        with connection.schema_editor() as editor:
-            fill_big_data.state_forwards("fill_big_data", new_state)
-            fill_big_data.database_forwards("fill_big_data", editor, project_state, new_state)
-
-    def test_autofield__bigautofield_foreignfield_growth(self):
-        """A field may be migrated from AutoField to BigAutoField."""
-        self._test_autofield_foreignfield_growth(
-            models.AutoField,
-            models.BigAutoField,
-            2 ** 33,
-        )
-
-    def test_smallfield_autofield_foreignfield_growth(self):
-        """A field may be migrated from SmallAutoField to AutoField."""
-        self._test_autofield_foreignfield_growth(
-            models.SmallAutoField,
-            models.AutoField,
-            2 ** 22,
-        )
-
-    def test_smallfield_bigautofield_foreignfield_growth(self):
-        """A field may be migrated from SmallAutoField to BigAutoField."""
-        self._test_autofield_foreignfield_growth(
-            models.SmallAutoField,
-            models.BigAutoField,
-            2 ** 33,
-        )
-
-    def test_run_python_noop(self):
-        """
-        #24098 - Tests no-op RunPython operations.
-        """
-        project_state = ProjectState()
-        new_state = project_state.clone()
-        operation = migrations.RunPython(migrations.RunPython.noop, migrations.RunPython.noop)
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_runpython", editor, project_state, new_state)
-            operation.database_backwards("test_runpython", editor, new_state, project_state)
-
-    def test_separate_database_and_state(self):
-        """
-        Tests the SeparateDatabaseAndState operation.
-        """
-        project_state = self.set_up_test_model("test_separatedatabaseandstate")
-        # Create the operation
-        database_operation = migrations.RunSQL(
-            "CREATE TABLE i_love_ponies (id int, special_thing int);",
-            "DROP TABLE i_love_ponies;"
-        )
-        state_operation = migrations.CreateModel("SomethingElse", [("id", models.AutoField(primary_key=True))])
-        operation = migrations.SeparateDatabaseAndState(
-            state_operations=[state_operation],
-            database_operations=[database_operation]
-        )
-        self.assertEqual(operation.describe(), "Custom state/database change combination")
-        # Test the state alteration
-        new_state = project_state.clone()
-        operation.state_forwards("test_separatedatabaseandstate", new_state)
-        self.assertEqual(len(new_state.models["test_separatedatabaseandstate", "somethingelse"].fields), 1)
-        # Make sure there's no table
-        self.assertTableNotExists("i_love_ponies")
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_separatedatabaseandstate", editor, project_state, new_state)
-        self.assertTableExists("i_love_ponies")
-        # And test reversal
-        self.assertTrue(operation.reversible)
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_separatedatabaseandstate", editor, new_state, project_state)
-        self.assertTableNotExists("i_love_ponies")
-        # And deconstruction
-        definition = operation.deconstruct()
-        self.assertEqual(definition[0], "SeparateDatabaseAndState")
-        self.assertEqual(definition[1], [])
-        self.assertEqual(sorted(definition[2]), ["database_operations", "state_operations"])
-
-    def test_separate_database_and_state2(self):
-        """
-        A complex SeparateDatabaseAndState operation: Multiple operations both
-        for state and database. Verify the state dependencies within each list
-        and that state ops don't affect the database.
-        """
-        app_label = "test_separatedatabaseandstate2"
-        project_state = self.set_up_test_model(app_label)
-        # Create the operation
-        database_operations = [
-            migrations.CreateModel(
-                "ILovePonies",
-                [("id", models.AutoField(primary_key=True))],
-                options={"db_table": "iloveponies"},
-            ),
-            migrations.CreateModel(
-                "ILoveMorePonies",
-                # We use IntegerField and not AutoField because
-                # the model is going to be deleted immediately
-                # and with an AutoField this fails on Oracle
-                [("id", models.IntegerField(primary_key=True))],
-                options={"db_table": "ilovemoreponies"},
-            ),
-            migrations.DeleteModel("ILoveMorePonies"),
-            migrations.CreateModel(
-                "ILoveEvenMorePonies",
-                [("id", models.AutoField(primary_key=True))],
-                options={"db_table": "iloveevenmoreponies"},
-            ),
-        ]
-        state_operations = [
-            migrations.CreateModel(
-                "SomethingElse",
-                [("id", models.AutoField(primary_key=True))],
-                options={"db_table": "somethingelse"},
-            ),
-            migrations.DeleteModel("SomethingElse"),
-            migrations.CreateModel(
-                "SomethingCompletelyDifferent",
-                [("id", models.AutoField(primary_key=True))],
-                options={"db_table": "somethingcompletelydifferent"},
-            ),
-        ]
-        operation = migrations.SeparateDatabaseAndState(
-            state_operations=state_operations,
-            database_operations=database_operations,
-        )
-        # Test the state alteration
-        new_state = project_state.clone()
-        operation.state_forwards(app_label, new_state)
-
-        def assertModelsAndTables(after_db):
-            # Tables and models exist, or don't, as they should:
-            self.assertNotIn((app_label, "somethingelse"), new_state.models)
-            self.assertEqual(len(new_state.models[app_label, "somethingcompletelydifferent"].fields), 1)
-            self.assertNotIn((app_label, "iloveponiesonies"), new_state.models)
-            self.assertNotIn((app_label, "ilovemoreponies"), new_state.models)
-            self.assertNotIn((app_label, "iloveevenmoreponies"), new_state.models)
-            self.assertTableNotExists("somethingelse")
-            self.assertTableNotExists("somethingcompletelydifferent")
-            self.assertTableNotExists("ilovemoreponies")
-            if after_db:
-                self.assertTableExists("iloveponies")
-                self.assertTableExists("iloveevenmoreponies")
-            else:
-                self.assertTableNotExists("iloveponies")
-                self.assertTableNotExists("iloveevenmoreponies")
-
-        assertModelsAndTables(after_db=False)
-        # Test the database alteration
-        with connection.schema_editor() as editor:
-            operation.database_forwards(app_label, editor, project_state, new_state)
-        assertModelsAndTables(after_db=True)
-        # And test reversal
-        self.assertTrue(operation.reversible)
-        with connection.schema_editor() as editor:
-            operation.database_backwards(app_label, editor, new_state, project_state)
-        assertModelsAndTables(after_db=False)
-
-
-class SwappableOperationTests(OperationTestBase):
-    """
-    Key operations ignore swappable models
-    (we don't want to replicate all of them here, as the functionality
-    is in a common base class anyway)
-    """
-
-    available_apps = ['migrations']
-
-    @override_settings(TEST_SWAP_MODEL="migrations.SomeFakeModel")
-    def test_create_ignore_swapped(self):
-        """
-        The CreateTable operation ignores swapped models.
-        """
-        operation = migrations.CreateModel(
-            "Pony",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("pink", models.IntegerField(default=1)),
-            ],
-            options={
-                "swappable": "TEST_SWAP_MODEL",
-            },
-        )
-        # Test the state alteration (it should still be there!)
-        project_state = ProjectState()
-        new_state = project_state.clone()
-        operation.state_forwards("test_crigsw", new_state)
-        self.assertEqual(new_state.models["test_crigsw", "pony"].name, "Pony")
-        self.assertEqual(len(new_state.models["test_crigsw", "pony"].fields), 2)
-        # Test the database alteration
-        self.assertTableNotExists("test_crigsw_pony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_crigsw", editor, project_state, new_state)
-        self.assertTableNotExists("test_crigsw_pony")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_crigsw", editor, new_state, project_state)
-        self.assertTableNotExists("test_crigsw_pony")
-
-    @override_settings(TEST_SWAP_MODEL="migrations.SomeFakeModel")
-    def test_delete_ignore_swapped(self):
-        """
-        Tests the DeleteModel operation ignores swapped models.
-        """
-        operation = migrations.DeleteModel("Pony")
-        project_state, new_state = self.make_test_state("test_dligsw", operation)
-        # Test the database alteration
-        self.assertTableNotExists("test_dligsw_pony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_dligsw", editor, project_state, new_state)
-        self.assertTableNotExists("test_dligsw_pony")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_dligsw", editor, new_state, project_state)
-        self.assertTableNotExists("test_dligsw_pony")
-
-    @override_settings(TEST_SWAP_MODEL="migrations.SomeFakeModel")
-    def test_add_field_ignore_swapped(self):
-        """
-        Tests the AddField operation.
-        """
-        # Test the state alteration
-        operation = migrations.AddField(
-            "Pony",
-            "height",
-            models.FloatField(null=True, default=5),
-        )
-        project_state, new_state = self.make_test_state("test_adfligsw", operation)
-        # Test the database alteration
-        self.assertTableNotExists("test_adfligsw_pony")
-        with connection.schema_editor() as editor:
-            operation.database_forwards("test_adfligsw", editor, project_state, new_state)
-        self.assertTableNotExists("test_adfligsw_pony")
-        # And test reversal
-        with connection.schema_editor() as editor:
-            operation.database_backwards("test_adfligsw", editor, new_state, project_state)
-        self.assertTableNotExists("test_adfligsw_pony")
-
-    @override_settings(TEST_SWAP_MODEL='migrations.SomeFakeModel')
-    def test_indexes_ignore_swapped(self):
-        """
-        Add/RemoveIndex operations ignore swapped models.
-        """
-        operation = migrations.AddIndex('Pony', models.Index(fields=['pink'], name='my_name_idx'))
-        project_state, new_state = self.make_test_state('test_adinigsw', operation)
-        with connection.schema_editor() as editor:
-            # No database queries should be run for swapped models
-            operation.database_forwards('test_adinigsw', editor, project_state, new_state)
-            operation.database_backwards('test_adinigsw', editor, new_state, project_state)
-
-        operation = migrations.RemoveIndex('Pony', models.Index(fields=['pink'], name='my_name_idx'))
-        project_state, new_state = self.make_test_state("test_rminigsw", operation)
-        with connection.schema_editor() as editor:
-            operation.database_forwards('test_rminigsw', editor, project_state, new_state)
-            operation.database_backwards('test_rminigsw', editor, new_state, project_state)
-
-
-class TestCreateModel(SimpleTestCase):
-
-    def test_references_model_mixin(self):
-        migrations.CreateModel(
-            'name',
-            fields=[],
-            bases=(Mixin, models.Model),
-        ).references_model('other_model', 'migrations')
-
-
-class FieldOperationTests(SimpleTestCase):
-    def test_references_model(self):
-        operation = FieldOperation('MoDel', 'field', models.ForeignKey('Other', models.CASCADE))
-        # Model name match.
-        self.assertIs(operation.references_model('mOdEl', 'migrations'), True)
-        # Referenced field.
-        self.assertIs(operation.references_model('oTher', 'migrations'), True)
-        # Doesn't reference.
-        self.assertIs(operation.references_model('Whatever', 'migrations'), False)
-
-    def test_references_field_by_name(self):
-        operation = FieldOperation('MoDel', 'field', models.BooleanField(default=False))
-        self.assertIs(operation.references_field('model', 'field', 'migrations'), True)
-
-    def test_references_field_by_remote_field_model(self):
-        operation = FieldOperation('Model', 'field', models.ForeignKey('Other', models.CASCADE))
-        self.assertIs(operation.references_field('Other', 'whatever', 'migrations'), True)
-        self.assertIs(operation.references_field('Missing', 'whatever', 'migrations'), False)
-
-    def test_references_field_by_from_fields(self):
-        operation = FieldOperation(
-            'Model', 'field', models.fields.related.ForeignObject('Other', models.CASCADE, ['from'], ['to'])
-        )
-        self.assertIs(operation.references_field('Model', 'from', 'migrations'), True)
-        self.assertIs(operation.references_field('Model', 'to', 'migrations'), False)
-        self.assertIs(operation.references_field('Other', 'from', 'migrations'), False)
-        self.assertIs(operation.references_field('Model', 'to', 'migrations'), False)
-
-    def test_references_field_by_to_fields(self):
-        operation = FieldOperation('Model', 'field', models.ForeignKey('Other', models.CASCADE, to_field='field'))
-        self.assertIs(operation.references_field('Other', 'field', 'migrations'), True)
-        self.assertIs(operation.references_field('Other', 'whatever', 'migrations'), False)
-        self.assertIs(operation.references_field('Missing', 'whatever', 'migrations'), False)
-
-    def test_references_field_by_through(self):
-        operation = FieldOperation('Model', 'field', models.ManyToManyField('Other', through='Through'))
-        self.assertIs(operation.references_field('Other', 'whatever', 'migrations'), True)
-        self.assertIs(operation.references_field('Through', 'whatever', 'migrations'), True)
-        self.assertIs(operation.references_field('Missing', 'whatever', 'migrations'), False)
-
-    def test_reference_field_by_through_fields(self):
-        operation = FieldOperation(
-            'Model', 'field', models.ManyToManyField('Other', through='Through', through_fields=('first', 'second'))
-        )
-        self.assertIs(operation.references_field('Other', 'whatever', 'migrations'), True)
-        self.assertIs(operation.references_field('Through', 'whatever', 'migrations'), False)
-        self.assertIs(operation.references_field('Through', 'first', 'migrations'), True)
-        self.assertIs(operation.references_field('Through', 'second', 'migrations'), True)
diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py
deleted file mode 100644
index 2950635514..0000000000
--- a/tests/migrations/test_optimizer.py
+++ /dev/null
@@ -1,832 +0,0 @@
-from django.db import migrations, models
-from django.db.migrations import operations
-from django.db.migrations.optimizer import MigrationOptimizer
-from django.db.migrations.serializer import serializer_factory
-from django.test import SimpleTestCase
-
-from .models import EmptyManager, UnicodeModel
-
-
-class OptimizerTests(SimpleTestCase):
-    """
-    Tests the migration autodetector.
-    """
-
-    def optimize(self, operations, app_label):
-        """
-        Handy shortcut for getting results + number of loops
-        """
-        optimizer = MigrationOptimizer()
-        return optimizer.optimize(operations, app_label), optimizer._iterations
-
-    def serialize(self, value):
-        return serializer_factory(value).serialize()[0]
-
-    def assertOptimizesTo(self, operations, expected, exact=None, less_than=None, app_label=None):
-        result, iterations = self.optimize(operations, app_label or 'migrations')
-        result = [self.serialize(f) for f in result]
-        expected = [self.serialize(f) for f in expected]
-        self.assertEqual(expected, result)
-        if exact is not None and iterations != exact:
-            raise self.failureException(
-                "Optimization did not take exactly %s iterations (it took %s)" % (exact, iterations)
-            )
-        if less_than is not None and iterations >= less_than:
-            raise self.failureException(
-                "Optimization did not take less than %s iterations (it took %s)" % (less_than, iterations)
-            )
-
-    def assertDoesNotOptimize(self, operations, **kwargs):
-        self.assertOptimizesTo(operations, operations, **kwargs)
-
-    def test_none_app_label(self):
-        optimizer = MigrationOptimizer()
-        with self.assertRaisesMessage(TypeError, 'app_label must be a str'):
-            optimizer.optimize([], None)
-
-    def test_single(self):
-        """
-        The optimizer does nothing on a single operation,
-        and that it does it in just one pass.
-        """
-        self.assertOptimizesTo(
-            [migrations.DeleteModel("Foo")],
-            [migrations.DeleteModel("Foo")],
-            exact=1,
-        )
-
-    def test_create_delete_model(self):
-        """
-        CreateModel and DeleteModel should collapse into nothing.
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.DeleteModel("Foo"),
-            ],
-            [],
-        )
-
-    def test_create_rename_model(self):
-        """
-        CreateModel should absorb RenameModels.
-        """
-        managers = [('objects', EmptyManager())]
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel(
-                    name="Foo",
-                    fields=[("name", models.CharField(max_length=255))],
-                    options={'verbose_name': 'Foo'},
-                    bases=(UnicodeModel,),
-                    managers=managers,
-                ),
-                migrations.RenameModel("Foo", "Bar"),
-            ],
-            [
-                migrations.CreateModel(
-                    "Bar",
-                    [("name", models.CharField(max_length=255))],
-                    options={'verbose_name': 'Foo'},
-                    bases=(UnicodeModel,),
-                    managers=managers,
-                )
-            ],
-        )
-
-    def test_rename_model_self(self):
-        """
-        RenameModels should absorb themselves.
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.RenameModel("Foo", "Baa"),
-                migrations.RenameModel("Baa", "Bar"),
-            ],
-            [
-                migrations.RenameModel("Foo", "Bar"),
-            ],
-        )
-
-    def test_create_alter_model_options(self):
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel('Foo', fields=[]),
-                migrations.AlterModelOptions(name='Foo', options={'verbose_name_plural': 'Foozes'}),
-            ],
-            [
-                migrations.CreateModel('Foo', fields=[], options={'verbose_name_plural': 'Foozes'}),
-            ]
-        )
-
-    def _test_create_alter_foo_delete_model(self, alter_foo):
-        """
-        CreateModel, AlterModelTable, AlterUniqueTogether/AlterIndexTogether/
-        AlterOrderWithRespectTo, and DeleteModel should collapse into nothing.
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.AlterModelTable("Foo", "woohoo"),
-                alter_foo,
-                migrations.DeleteModel("Foo"),
-            ],
-            [],
-        )
-
-    def test_create_alter_unique_delete_model(self):
-        self._test_create_alter_foo_delete_model(migrations.AlterUniqueTogether("Foo", [["a", "b"]]))
-
-    def test_create_alter_index_delete_model(self):
-        self._test_create_alter_foo_delete_model(migrations.AlterIndexTogether("Foo", [["a", "b"]]))
-
-    def test_create_alter_owrt_delete_model(self):
-        self._test_create_alter_foo_delete_model(migrations.AlterOrderWithRespectTo("Foo", "a"))
-
-    def _test_alter_alter_model(self, alter_foo, alter_bar):
-        """
-        Two AlterUniqueTogether/AlterIndexTogether/AlterOrderWithRespectTo
-        should collapse into the second.
-        """
-        self.assertOptimizesTo(
-            [
-                alter_foo,
-                alter_bar,
-            ],
-            [
-                alter_bar,
-            ],
-        )
-
-    def test_alter_alter_table_model(self):
-        self._test_alter_alter_model(
-            migrations.AlterModelTable("Foo", "a"),
-            migrations.AlterModelTable("Foo", "b"),
-        )
-
-    def test_alter_alter_unique_model(self):
-        self._test_alter_alter_model(
-            migrations.AlterUniqueTogether("Foo", [["a", "b"]]),
-            migrations.AlterUniqueTogether("Foo", [["a", "c"]]),
-        )
-
-    def test_alter_alter_index_model(self):
-        self._test_alter_alter_model(
-            migrations.AlterIndexTogether("Foo", [["a", "b"]]),
-            migrations.AlterIndexTogether("Foo", [["a", "c"]]),
-        )
-
-    def test_alter_alter_owrt_model(self):
-        self._test_alter_alter_model(
-            migrations.AlterOrderWithRespectTo("Foo", "a"),
-            migrations.AlterOrderWithRespectTo("Foo", "b"),
-        )
-
-    def test_optimize_through_create(self):
-        """
-        We should be able to optimize away create/delete through a create or delete
-        of a different model, but only if the create operation does not mention the model
-        at all.
-        """
-        # These should work
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.CreateModel("Bar", [("size", models.IntegerField())]),
-                migrations.DeleteModel("Foo"),
-            ],
-            [
-                migrations.CreateModel("Bar", [("size", models.IntegerField())]),
-            ],
-        )
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.CreateModel("Bar", [("size", models.IntegerField())]),
-                migrations.DeleteModel("Bar"),
-                migrations.DeleteModel("Foo"),
-            ],
-            [],
-        )
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.CreateModel("Bar", [("size", models.IntegerField())]),
-                migrations.DeleteModel("Foo"),
-                migrations.DeleteModel("Bar"),
-            ],
-            [],
-        )
-        # Operations should be optimized if the FK references a model from the
-        # other app.
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.CreateModel("Bar", [("other", models.ForeignKey("testapp.Foo", models.CASCADE))]),
-                migrations.DeleteModel("Foo"),
-            ],
-            [
-                migrations.CreateModel("Bar", [("other", models.ForeignKey("testapp.Foo", models.CASCADE))]),
-            ],
-            app_label="otherapp",
-        )
-        # But it shouldn't work if a FK references a model with the same
-        # app_label.
-        self.assertDoesNotOptimize(
-            [
-                migrations.CreateModel('Foo', [('name', models.CharField(max_length=255))]),
-                migrations.CreateModel('Bar', [('other', models.ForeignKey('Foo', models.CASCADE))]),
-                migrations.DeleteModel('Foo'),
-            ],
-        )
-        self.assertDoesNotOptimize(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.CreateModel("Bar", [("other", models.ForeignKey("testapp.Foo", models.CASCADE))]),
-                migrations.DeleteModel("Foo"),
-            ],
-            app_label="testapp",
-        )
-        # This should not work - bases should block it
-        self.assertDoesNotOptimize(
-            [
-                migrations.CreateModel('Foo', [('name', models.CharField(max_length=255))]),
-                migrations.CreateModel('Bar', [('size', models.IntegerField())], bases=('Foo',)),
-                migrations.DeleteModel('Foo'),
-            ],
-        )
-        self.assertDoesNotOptimize(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.CreateModel("Bar", [("size", models.IntegerField())], bases=("testapp.Foo",)),
-                migrations.DeleteModel("Foo"),
-            ],
-            app_label='testapp',
-        )
-        # The same operations should be optimized if app_label and none of
-        # bases belong to that app.
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.CreateModel("Bar", [("size", models.IntegerField())], bases=("testapp.Foo",)),
-                migrations.DeleteModel("Foo"),
-            ],
-            [
-                migrations.CreateModel("Bar", [("size", models.IntegerField())], bases=("testapp.Foo",)),
-            ],
-            app_label="otherapp",
-        )
-        # But it shouldn't work if some of bases belongs to the specified app.
-        self.assertDoesNotOptimize(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.CreateModel("Bar", [("size", models.IntegerField())], bases=("testapp.Foo",)),
-                migrations.DeleteModel("Foo"),
-            ],
-            app_label="testapp",
-        )
-
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel('Book', [('name', models.CharField(max_length=255))]),
-                migrations.CreateModel('Person', [('name', models.CharField(max_length=255))]),
-                migrations.AddField('book', 'author', models.ForeignKey('test_app.Person', models.CASCADE)),
-                migrations.CreateModel('Review', [('book', models.ForeignKey('test_app.Book', models.CASCADE))]),
-                migrations.CreateModel('Reviewer', [('name', models.CharField(max_length=255))]),
-                migrations.AddField('review', 'reviewer', models.ForeignKey('test_app.Reviewer', models.CASCADE)),
-                migrations.RemoveField('book', 'author'),
-                migrations.DeleteModel('Person'),
-            ],
-            [
-                migrations.CreateModel('Book', [('name', models.CharField(max_length=255))]),
-                migrations.CreateModel('Reviewer', [('name', models.CharField(max_length=255))]),
-                migrations.CreateModel('Review', [
-                    ('book', models.ForeignKey('test_app.Book', models.CASCADE)),
-                    ('reviewer', models.ForeignKey('test_app.Reviewer', models.CASCADE)),
-                ]),
-            ],
-            app_label='test_app',
-        )
-
-    def test_create_model_add_field(self):
-        """
-        AddField should optimize into CreateModel.
-        """
-        managers = [('objects', EmptyManager())]
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel(
-                    name="Foo",
-                    fields=[("name", models.CharField(max_length=255))],
-                    options={'verbose_name': 'Foo'},
-                    bases=(UnicodeModel,),
-                    managers=managers,
-                ),
-                migrations.AddField("Foo", "age", models.IntegerField()),
-            ],
-            [
-                migrations.CreateModel(
-                    name="Foo",
-                    fields=[
-                        ("name", models.CharField(max_length=255)),
-                        ("age", models.IntegerField()),
-                    ],
-                    options={'verbose_name': 'Foo'},
-                    bases=(UnicodeModel,),
-                    managers=managers,
-                ),
-            ],
-        )
-
-    def test_create_model_reordering(self):
-        """
-        AddField optimizes into CreateModel if it's a FK to a model that's
-        between them (and there's no FK in the other direction), by changing
-        the order of the CreateModel operations.
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel('Foo', [('name', models.CharField(max_length=255))]),
-                migrations.CreateModel('Link', [('url', models.TextField())]),
-                migrations.AddField('Foo', 'link', models.ForeignKey('migrations.Link', models.CASCADE)),
-            ],
-            [
-                migrations.CreateModel('Link', [('url', models.TextField())]),
-                migrations.CreateModel('Foo', [
-                    ('name', models.CharField(max_length=255)),
-                    ('link', models.ForeignKey('migrations.Link', models.CASCADE))
-                ]),
-            ],
-        )
-
-    def test_create_model_reordering_circular_fk(self):
-        """
-        CreateModel reordering behavior doesn't result in an infinite loop if
-        there are FKs in both directions.
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel('Bar', [('url', models.TextField())]),
-                migrations.CreateModel('Foo', [('name', models.CharField(max_length=255))]),
-                migrations.AddField('Bar', 'foo_fk', models.ForeignKey('migrations.Foo', models.CASCADE)),
-                migrations.AddField('Foo', 'bar_fk', models.ForeignKey('migrations.Bar', models.CASCADE)),
-            ],
-            [
-                migrations.CreateModel('Foo', [('name', models.CharField(max_length=255))]),
-                migrations.CreateModel('Bar', [
-                    ('url', models.TextField()),
-                    ('foo_fk', models.ForeignKey('migrations.Foo', models.CASCADE)),
-                ]),
-                migrations.AddField('Foo', 'bar_fk', models.ForeignKey('migrations.Bar', models.CASCADE)),
-            ],
-        )
-
-    def test_create_model_no_reordering_for_unrelated_fk(self):
-        """
-        CreateModel order remains unchanged if the later AddField operation
-        isn't a FK between them.
-        """
-        self.assertDoesNotOptimize(
-            [
-                migrations.CreateModel('Foo', [('name', models.CharField(max_length=255))]),
-                migrations.CreateModel('Link', [('url', models.TextField())]),
-                migrations.AddField('Other', 'link', models.ForeignKey('migrations.Link', models.CASCADE)),
-            ],
-        )
-
-    def test_create_model_no_reordering_of_inherited_model(self):
-        """
-        A CreateModel that inherits from another isn't reordered to avoid
-        moving it earlier than its parent CreateModel operation.
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel('Other', [('foo', models.CharField(max_length=255))]),
-                migrations.CreateModel('ParentModel', [('bar', models.CharField(max_length=255))]),
-                migrations.CreateModel(
-                    'ChildModel',
-                    [('baz', models.CharField(max_length=255))],
-                    bases=('migrations.parentmodel',),
-                ),
-                migrations.AddField('Other', 'fk', models.ForeignKey('migrations.ChildModel', models.CASCADE)),
-            ],
-            [
-                migrations.CreateModel('ParentModel', [('bar', models.CharField(max_length=255))]),
-                migrations.CreateModel(
-                    'ChildModel',
-                    [('baz', models.CharField(max_length=255))],
-                    bases=('migrations.parentmodel',),
-                ),
-                migrations.CreateModel(
-                    'Other', [
-                        ('foo', models.CharField(max_length=255)),
-                        ('fk', models.ForeignKey('migrations.ChildModel', models.CASCADE)),
-                    ]
-                ),
-            ],
-        )
-
-    def test_create_model_add_field_not_through_m2m_through(self):
-        """
-        AddField should NOT optimize into CreateModel if it's an M2M using a
-        through that's created between them.
-        """
-        self.assertDoesNotOptimize(
-            [
-                migrations.CreateModel('Employee', []),
-                migrations.CreateModel('Employer', []),
-                migrations.CreateModel('Employment', [
-                    ('employee', models.ForeignKey('migrations.Employee', models.CASCADE)),
-                    ('employment', models.ForeignKey('migrations.Employer', models.CASCADE)),
-                ]),
-                migrations.AddField(
-                    'Employer', 'employees', models.ManyToManyField(
-                        'migrations.Employee', through='migrations.Employment',
-                    )
-                ),
-            ],
-        )
-
-    def test_create_model_alter_field(self):
-        """
-        AlterField should optimize into CreateModel.
-        """
-        managers = [('objects', EmptyManager())]
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel(
-                    name="Foo",
-                    fields=[("name", models.CharField(max_length=255))],
-                    options={'verbose_name': 'Foo'},
-                    bases=(UnicodeModel,),
-                    managers=managers,
-                ),
-                migrations.AlterField("Foo", "name", models.IntegerField()),
-            ],
-            [
-                migrations.CreateModel(
-                    name="Foo",
-                    fields=[
-                        ("name", models.IntegerField()),
-                    ],
-                    options={'verbose_name': 'Foo'},
-                    bases=(UnicodeModel,),
-                    managers=managers,
-                ),
-            ],
-        )
-
-    def test_create_model_rename_field(self):
-        """
-        RenameField should optimize into CreateModel.
-        """
-        managers = [('objects', EmptyManager())]
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel(
-                    name="Foo",
-                    fields=[("name", models.CharField(max_length=255))],
-                    options={'verbose_name': 'Foo'},
-                    bases=(UnicodeModel,),
-                    managers=managers,
-                ),
-                migrations.RenameField("Foo", "name", "title"),
-            ],
-            [
-                migrations.CreateModel(
-                    name="Foo",
-                    fields=[
-                        ("title", models.CharField(max_length=255)),
-                    ],
-                    options={'verbose_name': 'Foo'},
-                    bases=(UnicodeModel,),
-                    managers=managers,
-                ),
-            ],
-        )
-
-    def test_add_field_rename_field(self):
-        """
-        RenameField should optimize into AddField
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.AddField("Foo", "name", models.CharField(max_length=255)),
-                migrations.RenameField("Foo", "name", "title"),
-            ],
-            [
-                migrations.AddField("Foo", "title", models.CharField(max_length=255)),
-            ],
-        )
-
-    def test_alter_field_rename_field(self):
-        """
-        RenameField should optimize to the other side of AlterField,
-        and into itself.
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.AlterField("Foo", "name", models.CharField(max_length=255)),
-                migrations.RenameField("Foo", "name", "title"),
-                migrations.RenameField("Foo", "title", "nom"),
-            ],
-            [
-                migrations.RenameField("Foo", "name", "nom"),
-                migrations.AlterField("Foo", "nom", models.CharField(max_length=255)),
-            ],
-        )
-
-    def test_create_model_remove_field(self):
-        """
-        RemoveField should optimize into CreateModel.
-        """
-        managers = [('objects', EmptyManager())]
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel(
-                    name="Foo",
-                    fields=[
-                        ("name", models.CharField(max_length=255)),
-                        ("age", models.IntegerField()),
-                    ],
-                    options={'verbose_name': 'Foo'},
-                    bases=(UnicodeModel,),
-                    managers=managers,
-                ),
-                migrations.RemoveField("Foo", "age"),
-            ],
-            [
-                migrations.CreateModel(
-                    name="Foo",
-                    fields=[
-                        ("name", models.CharField(max_length=255)),
-                    ],
-                    options={'verbose_name': 'Foo'},
-                    bases=(UnicodeModel,),
-                    managers=managers,
-                ),
-            ],
-        )
-
-    def test_add_field_alter_field(self):
-        """
-        AlterField should optimize into AddField.
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.AddField("Foo", "age", models.IntegerField()),
-                migrations.AlterField("Foo", "age", models.FloatField(default=2.4)),
-            ],
-            [
-                migrations.AddField("Foo", name="age", field=models.FloatField(default=2.4)),
-            ],
-        )
-
-    def test_add_field_delete_field(self):
-        """
-        RemoveField should cancel AddField
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.AddField("Foo", "age", models.IntegerField()),
-                migrations.RemoveField("Foo", "age"),
-            ],
-            [],
-        )
-
-    def test_alter_field_delete_field(self):
-        """
-        RemoveField should absorb AlterField
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.AlterField("Foo", "age", models.IntegerField()),
-                migrations.RemoveField("Foo", "age"),
-            ],
-            [
-                migrations.RemoveField("Foo", "age"),
-            ],
-        )
-
-    def _test_create_alter_foo_field(self, alter):
-        """
-        CreateModel, AlterFooTogether/AlterOrderWithRespectTo followed by an
-        add/alter/rename field should optimize to CreateModel with options.
-        """
-        option_value = getattr(alter, alter.option_name)
-        options = {alter.option_name: option_value}
-
-        # AddField
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                ]),
-                alter,
-                migrations.AddField("Foo", "c", models.IntegerField()),
-            ],
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                    ("c", models.IntegerField()),
-                ], options=options),
-            ],
-        )
-
-        # AlterField
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                ]),
-                alter,
-                migrations.AlterField("Foo", "b", models.CharField(max_length=255)),
-            ],
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.CharField(max_length=255)),
-                ], options=options),
-            ],
-        )
-
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                    ("c", models.IntegerField()),
-                ]),
-                alter,
-                migrations.AlterField("Foo", "c", models.CharField(max_length=255)),
-            ],
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                    ("c", models.CharField(max_length=255)),
-                ], options=options),
-            ],
-        )
-
-        # RenameField
-        if isinstance(option_value, str):
-            renamed_options = {alter.option_name: 'c'}
-        else:
-            renamed_options = {
-                alter.option_name: {
-                    tuple('c' if value == 'b' else value for value in item) for item in option_value
-                }
-            }
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                ]),
-                alter,
-                migrations.RenameField("Foo", "b", "c"),
-            ],
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("c", models.IntegerField()),
-                ], options=renamed_options),
-            ],
-        )
-
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                ]),
-                alter,
-                migrations.RenameField("Foo", "b", "x"),
-                migrations.RenameField("Foo", "x", "c"),
-            ],
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("c", models.IntegerField()),
-                ], options=renamed_options),
-            ],
-        )
-
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                    ("c", models.IntegerField()),
-                ]),
-                alter,
-                migrations.RenameField("Foo", "c", "d"),
-            ],
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                    ("d", models.IntegerField()),
-                ], options=options),
-            ],
-        )
-
-        # RemoveField
-        if isinstance(option_value, str):
-            removed_options = None
-        else:
-            removed_options = {
-                alter.option_name: {
-                    tuple(value for value in item if value != 'b') for item in option_value
-                }
-            }
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                ]),
-                alter,
-                migrations.RemoveField("Foo", "b"),
-            ],
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                ], options=removed_options),
-            ]
-        )
-
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                    ("c", models.IntegerField()),
-                ]),
-                alter,
-                migrations.RemoveField("Foo", "c"),
-            ],
-            [
-                migrations.CreateModel("Foo", [
-                    ("a", models.IntegerField()),
-                    ("b", models.IntegerField()),
-                ], options=options),
-            ],
-        )
-
-    def test_create_alter_unique_field(self):
-        self._test_create_alter_foo_field(migrations.AlterUniqueTogether("Foo", [["a", "b"]]))
-
-    def test_create_alter_index_field(self):
-        self._test_create_alter_foo_field(migrations.AlterIndexTogether("Foo", [["a", "b"]]))
-
-    def test_create_alter_owrt_field(self):
-        self._test_create_alter_foo_field(migrations.AlterOrderWithRespectTo("Foo", "b"))
-
-    def test_optimize_through_fields(self):
-        """
-        field-level through checking is working. This should manage to collapse
-        model Foo to nonexistence, and model Bar to a single IntegerField
-        called "width".
-        """
-        self.assertOptimizesTo(
-            [
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                migrations.CreateModel("Bar", [("size", models.IntegerField())]),
-                migrations.AddField("Foo", "age", models.IntegerField()),
-                migrations.AddField("Bar", "width", models.IntegerField()),
-                migrations.AlterField("Foo", "age", models.IntegerField()),
-                migrations.RenameField("Bar", "size", "dimensions"),
-                migrations.RemoveField("Foo", "age"),
-                migrations.RenameModel("Foo", "Phou"),
-                migrations.RemoveField("Bar", "dimensions"),
-                migrations.RenameModel("Phou", "Fou"),
-                migrations.DeleteModel("Fou"),
-            ],
-            [
-                migrations.CreateModel("Bar", [("width", models.IntegerField())]),
-            ],
-        )
-
-    def test_optimize_elidable_operation(self):
-        elidable_operation = operations.base.Operation()
-        elidable_operation.elidable = True
-        self.assertOptimizesTo(
-            [
-                elidable_operation,
-                migrations.CreateModel("Foo", [("name", models.CharField(max_length=255))]),
-                elidable_operation,
-                migrations.CreateModel("Bar", [("size", models.IntegerField())]),
-                elidable_operation,
-                migrations.RenameModel("Foo", "Phou"),
-                migrations.DeleteModel("Bar"),
-                elidable_operation,
-            ],
-            [
-                migrations.CreateModel("Phou", [("name", models.CharField(max_length=255))]),
-            ],
-        )
diff --git a/tests/migrations/test_questioner.py b/tests/migrations/test_questioner.py
deleted file mode 100644
index e17dd04ab6..0000000000
--- a/tests/migrations/test_questioner.py
+++ /dev/null
@@ -1,25 +0,0 @@
-import datetime
-from unittest import mock
-
-from django.db.migrations.questioner import (
-    InteractiveMigrationQuestioner, MigrationQuestioner,
-)
-from django.test import SimpleTestCase
-from django.test.utils import captured_stdout, override_settings
-
-
-class QuestionerTests(SimpleTestCase):
-    @override_settings(
-        INSTALLED_APPS=['migrations'],
-        MIGRATION_MODULES={'migrations': None},
-    )
-    def test_ask_initial_with_disabled_migrations(self):
-        questioner = MigrationQuestioner()
-        self.assertIs(False, questioner.ask_initial('migrations'))
-
-    @mock.patch('builtins.input', return_value='datetime.timedelta(days=1)')
-    def test_timedelta_default(self, mock):
-        questioner = InteractiveMigrationQuestioner()
-        with captured_stdout():
-            value = questioner._ask_default()
-        self.assertEqual(value, datetime.timedelta(days=1))
diff --git a/tests/migrations/test_state.py b/tests/migrations/test_state.py
deleted file mode 100644
index 40277bf506..0000000000
--- a/tests/migrations/test_state.py
+++ /dev/null
@@ -1,1484 +0,0 @@
-from django.apps.registry import Apps
-from django.contrib.contenttypes.fields import GenericForeignKey
-from django.db import models
-from django.db.migrations.exceptions import InvalidBasesError
-from django.db.migrations.operations import (
-    AddField, AlterField, DeleteModel, RemoveField,
-)
-from django.db.migrations.state import (
-    ModelState, ProjectState, get_related_models_recursive,
-)
-from django.test import SimpleTestCase, override_settings
-from django.test.utils import isolate_apps
-
-from .models import (
-    FoodManager, FoodQuerySet, ModelWithCustomBase, NoMigrationFoodManager,
-    UnicodeModel,
-)
-
-
-class StateTests(SimpleTestCase):
-    """
-    Tests state construction, rendering and modification by operations.
-    """
-
-    def test_create(self):
-        """
-        Tests making a ProjectState from an Apps
-        """
-
-        new_apps = Apps(["migrations"])
-
-        class Author(models.Model):
-            name = models.CharField(max_length=255)
-            bio = models.TextField()
-            age = models.IntegerField(blank=True, null=True)
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-                unique_together = ["name", "bio"]
-                index_together = ["bio", "age"]
-
-        class AuthorProxy(Author):
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-                proxy = True
-                ordering = ["name"]
-
-        class SubAuthor(Author):
-            width = models.FloatField(null=True)
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class Book(models.Model):
-            title = models.CharField(max_length=1000)
-            author = models.ForeignKey(Author, models.CASCADE)
-            contributors = models.ManyToManyField(Author)
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-                verbose_name = "tome"
-                db_table = "test_tome"
-                indexes = [models.Index(fields=['title'])]
-
-        class Food(models.Model):
-
-            food_mgr = FoodManager('a', 'b')
-            food_qs = FoodQuerySet.as_manager()
-            food_no_mgr = NoMigrationFoodManager('x', 'y')
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class FoodNoManagers(models.Model):
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class FoodNoDefaultManager(models.Model):
-
-            food_no_mgr = NoMigrationFoodManager('x', 'y')
-            food_mgr = FoodManager('a', 'b')
-            food_qs = FoodQuerySet.as_manager()
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        mgr1 = FoodManager('a', 'b')
-        mgr2 = FoodManager('x', 'y', c=3, d=4)
-
-        class FoodOrderedManagers(models.Model):
-            # The managers on this model should be ordered by their creation
-            # counter and not by the order in model body
-
-            food_no_mgr = NoMigrationFoodManager('x', 'y')
-            food_mgr2 = mgr2
-            food_mgr1 = mgr1
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        project_state = ProjectState.from_apps(new_apps)
-        author_state = project_state.models['migrations', 'author']
-        author_proxy_state = project_state.models['migrations', 'authorproxy']
-        sub_author_state = project_state.models['migrations', 'subauthor']
-        book_state = project_state.models['migrations', 'book']
-        food_state = project_state.models['migrations', 'food']
-        food_no_managers_state = project_state.models['migrations', 'foodnomanagers']
-        food_no_default_manager_state = project_state.models['migrations', 'foodnodefaultmanager']
-        food_order_manager_state = project_state.models['migrations', 'foodorderedmanagers']
-        book_index = models.Index(fields=['title'])
-        book_index.set_name_with_model(Book)
-
-        self.assertEqual(author_state.app_label, "migrations")
-        self.assertEqual(author_state.name, "Author")
-        self.assertEqual(list(author_state.fields), ["id", "name", "bio", "age"])
-        self.assertEqual(author_state.fields['name'].max_length, 255)
-        self.assertIs(author_state.fields['bio'].null, False)
-        self.assertIs(author_state.fields['age'].null, True)
-        self.assertEqual(
-            author_state.options,
-            {
-                "unique_together": {("name", "bio")},
-                "index_together": {("bio", "age")},
-                "indexes": [],
-                "constraints": [],
-            }
-        )
-        self.assertEqual(author_state.bases, (models.Model,))
-
-        self.assertEqual(book_state.app_label, "migrations")
-        self.assertEqual(book_state.name, "Book")
-        self.assertEqual(list(book_state.fields), ["id", "title", "author", "contributors"])
-        self.assertEqual(book_state.fields['title'].max_length, 1000)
-        self.assertIs(book_state.fields['author'].null, False)
-        self.assertEqual(book_state.fields['contributors'].__class__.__name__, 'ManyToManyField')
-        self.assertEqual(
-            book_state.options,
-            {"verbose_name": "tome", "db_table": "test_tome", "indexes": [book_index], "constraints": []},
-        )
-        self.assertEqual(book_state.bases, (models.Model,))
-
-        self.assertEqual(author_proxy_state.app_label, "migrations")
-        self.assertEqual(author_proxy_state.name, "AuthorProxy")
-        self.assertEqual(author_proxy_state.fields, {})
-        self.assertEqual(
-            author_proxy_state.options,
-            {"proxy": True, "ordering": ["name"], "indexes": [], "constraints": []},
-        )
-        self.assertEqual(author_proxy_state.bases, ("migrations.author",))
-
-        self.assertEqual(sub_author_state.app_label, "migrations")
-        self.assertEqual(sub_author_state.name, "SubAuthor")
-        self.assertEqual(len(sub_author_state.fields), 2)
-        self.assertEqual(sub_author_state.bases, ("migrations.author",))
-
-        # The default manager is used in migrations
-        self.assertEqual([name for name, mgr in food_state.managers], ['food_mgr'])
-        self.assertTrue(all(isinstance(name, str) for name, mgr in food_state.managers))
-        self.assertEqual(food_state.managers[0][1].args, ('a', 'b', 1, 2))
-
-        # No explicit managers defined. Migrations will fall back to the default
-        self.assertEqual(food_no_managers_state.managers, [])
-
-        # food_mgr is used in migration but isn't the default mgr, hence add the
-        # default
-        self.assertEqual([name for name, mgr in food_no_default_manager_state.managers],
-                         ['food_no_mgr', 'food_mgr'])
-        self.assertTrue(all(isinstance(name, str) for name, mgr in food_no_default_manager_state.managers))
-        self.assertEqual(food_no_default_manager_state.managers[0][1].__class__, models.Manager)
-        self.assertIsInstance(food_no_default_manager_state.managers[1][1], FoodManager)
-
-        self.assertEqual([name for name, mgr in food_order_manager_state.managers],
-                         ['food_mgr1', 'food_mgr2'])
-        self.assertTrue(all(isinstance(name, str) for name, mgr in food_order_manager_state.managers))
-        self.assertEqual([mgr.args for name, mgr in food_order_manager_state.managers],
-                         [('a', 'b', 1, 2), ('x', 'y', 3, 4)])
-
-    def test_custom_default_manager_added_to_the_model_state(self):
-        """
-        When the default manager of the model is a custom manager,
-        it needs to be added to the model state.
-        """
-        new_apps = Apps(['migrations'])
-        custom_manager = models.Manager()
-
-        class Author(models.Model):
-            objects = models.TextField()
-            authors = custom_manager
-
-            class Meta:
-                app_label = 'migrations'
-                apps = new_apps
-
-        project_state = ProjectState.from_apps(new_apps)
-        author_state = project_state.models['migrations', 'author']
-        self.assertEqual(author_state.managers, [('authors', custom_manager)])
-
-    def test_custom_default_manager_named_objects_with_false_migration_flag(self):
-        """
-        When a manager is added with a name of 'objects' but it does not
-        have `use_in_migrations = True`, no migration should be added to the
-        model state (#26643).
-        """
-        new_apps = Apps(['migrations'])
-
-        class Author(models.Model):
-            objects = models.Manager()
-
-            class Meta:
-                app_label = 'migrations'
-                apps = new_apps
-
-        project_state = ProjectState.from_apps(new_apps)
-        author_state = project_state.models['migrations', 'author']
-        self.assertEqual(author_state.managers, [])
-
-    def test_no_duplicate_managers(self):
-        """
-        When a manager is added with `use_in_migrations = True` and a parent
-        model had a manager with the same name and `use_in_migrations = True`,
-        the parent's manager shouldn't appear in the model state (#26881).
-        """
-        new_apps = Apps(['migrations'])
-
-        class PersonManager(models.Manager):
-            use_in_migrations = True
-
-        class Person(models.Model):
-            objects = PersonManager()
-
-            class Meta:
-                abstract = True
-
-        class BossManager(PersonManager):
-            use_in_migrations = True
-
-        class Boss(Person):
-            objects = BossManager()
-
-            class Meta:
-                app_label = 'migrations'
-                apps = new_apps
-
-        project_state = ProjectState.from_apps(new_apps)
-        boss_state = project_state.models['migrations', 'boss']
-        self.assertEqual(boss_state.managers, [('objects', Boss.objects)])
-
-    def test_custom_default_manager(self):
-        new_apps = Apps(['migrations'])
-
-        class Author(models.Model):
-            manager1 = models.Manager()
-            manager2 = models.Manager()
-
-            class Meta:
-                app_label = 'migrations'
-                apps = new_apps
-                default_manager_name = 'manager2'
-
-        project_state = ProjectState.from_apps(new_apps)
-        author_state = project_state.models['migrations', 'author']
-        self.assertEqual(author_state.options['default_manager_name'], 'manager2')
-        self.assertEqual(author_state.managers, [('manager2', Author.manager1)])
-
-    def test_custom_base_manager(self):
-        new_apps = Apps(['migrations'])
-
-        class Author(models.Model):
-            manager1 = models.Manager()
-            manager2 = models.Manager()
-
-            class Meta:
-                app_label = 'migrations'
-                apps = new_apps
-                base_manager_name = 'manager2'
-
-        class Author2(models.Model):
-            manager1 = models.Manager()
-            manager2 = models.Manager()
-
-            class Meta:
-                app_label = 'migrations'
-                apps = new_apps
-                base_manager_name = 'manager1'
-
-        project_state = ProjectState.from_apps(new_apps)
-
-        author_state = project_state.models['migrations', 'author']
-        self.assertEqual(author_state.options['base_manager_name'], 'manager2')
-        self.assertEqual(author_state.managers, [
-            ('manager1', Author.manager1),
-            ('manager2', Author.manager2),
-        ])
-
-        author2_state = project_state.models['migrations', 'author2']
-        self.assertEqual(author2_state.options['base_manager_name'], 'manager1')
-        self.assertEqual(author2_state.managers, [
-            ('manager1', Author2.manager1),
-        ])
-
-    def test_apps_bulk_update(self):
-        """
-        StateApps.bulk_update() should update apps.ready to False and reset
-        the value afterwards.
-        """
-        project_state = ProjectState()
-        apps = project_state.apps
-        with apps.bulk_update():
-            self.assertFalse(apps.ready)
-        self.assertTrue(apps.ready)
-        with self.assertRaises(ValueError):
-            with apps.bulk_update():
-                self.assertFalse(apps.ready)
-                raise ValueError()
-        self.assertTrue(apps.ready)
-
-    def test_render(self):
-        """
-        Tests rendering a ProjectState into an Apps.
-        """
-        project_state = ProjectState()
-        project_state.add_model(ModelState(
-            app_label="migrations",
-            name="Tag",
-            fields=[
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=100)),
-                ("hidden", models.BooleanField()),
-            ],
-        ))
-        project_state.add_model(ModelState(
-            app_label="migrations",
-            name="SubTag",
-            fields=[
-                ('tag_ptr', models.OneToOneField(
-                    'migrations.Tag',
-                    models.CASCADE,
-                    auto_created=True,
-                    parent_link=True,
-                    primary_key=True,
-                    to_field='id',
-                    serialize=False,
-                )),
-                ("awesome", models.BooleanField()),
-            ],
-            bases=("migrations.Tag",),
-        ))
-
-        base_mgr = models.Manager()
-        mgr1 = FoodManager('a', 'b')
-        mgr2 = FoodManager('x', 'y', c=3, d=4)
-        project_state.add_model(ModelState(
-            app_label="migrations",
-            name="Food",
-            fields=[
-                ("id", models.AutoField(primary_key=True)),
-            ],
-            managers=[
-                # The ordering we really want is objects, mgr1, mgr2
-                ('default', base_mgr),
-                ('food_mgr2', mgr2),
-                ('food_mgr1', mgr1),
-            ]
-        ))
-
-        new_apps = project_state.apps
-        self.assertEqual(new_apps.get_model("migrations", "Tag")._meta.get_field("name").max_length, 100)
-        self.assertIs(new_apps.get_model("migrations", "Tag")._meta.get_field("hidden").null, False)
-
-        self.assertEqual(len(new_apps.get_model("migrations", "SubTag")._meta.local_fields), 2)
-
-        Food = new_apps.get_model("migrations", "Food")
-        self.assertEqual([mgr.name for mgr in Food._meta.managers],
-                         ['default', 'food_mgr1', 'food_mgr2'])
-        self.assertTrue(all(isinstance(mgr.name, str) for mgr in Food._meta.managers))
-        self.assertEqual([mgr.__class__ for mgr in Food._meta.managers],
-                         [models.Manager, FoodManager, FoodManager])
-
-    def test_render_model_inheritance(self):
-        class Book(models.Model):
-            title = models.CharField(max_length=1000)
-
-            class Meta:
-                app_label = "migrations"
-                apps = Apps()
-
-        class Novel(Book):
-            class Meta:
-                app_label = "migrations"
-                apps = Apps()
-
-        # First, test rendering individually
-        apps = Apps(["migrations"])
-
-        # We shouldn't be able to render yet
-        ms = ModelState.from_model(Novel)
-        with self.assertRaises(InvalidBasesError):
-            ms.render(apps)
-
-        # Once the parent model is in the app registry, it should be fine
-        ModelState.from_model(Book).render(apps)
-        ModelState.from_model(Novel).render(apps)
-
-    def test_render_model_with_multiple_inheritance(self):
-        class Foo(models.Model):
-            class Meta:
-                app_label = "migrations"
-                apps = Apps()
-
-        class Bar(models.Model):
-            class Meta:
-                app_label = "migrations"
-                apps = Apps()
-
-        class FooBar(Foo, Bar):
-            class Meta:
-                app_label = "migrations"
-                apps = Apps()
-
-        class AbstractSubFooBar(FooBar):
-            class Meta:
-                abstract = True
-                apps = Apps()
-
-        class SubFooBar(AbstractSubFooBar):
-            class Meta:
-                app_label = "migrations"
-                apps = Apps()
-
-        apps = Apps(["migrations"])
-
-        # We shouldn't be able to render yet
-        ms = ModelState.from_model(FooBar)
-        with self.assertRaises(InvalidBasesError):
-            ms.render(apps)
-
-        # Once the parent models are in the app registry, it should be fine
-        ModelState.from_model(Foo).render(apps)
-        self.assertSequenceEqual(ModelState.from_model(Foo).bases, [models.Model])
-        ModelState.from_model(Bar).render(apps)
-        self.assertSequenceEqual(ModelState.from_model(Bar).bases, [models.Model])
-        ModelState.from_model(FooBar).render(apps)
-        self.assertSequenceEqual(ModelState.from_model(FooBar).bases, ['migrations.foo', 'migrations.bar'])
-        ModelState.from_model(SubFooBar).render(apps)
-        self.assertSequenceEqual(ModelState.from_model(SubFooBar).bases, ['migrations.foobar'])
-
-    def test_render_project_dependencies(self):
-        """
-        The ProjectState render method correctly renders models
-        to account for inter-model base dependencies.
-        """
-        new_apps = Apps()
-
-        class A(models.Model):
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class B(A):
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class C(B):
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class D(A):
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class E(B):
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-                proxy = True
-
-        class F(D):
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-                proxy = True
-
-        # Make a ProjectState and render it
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(A))
-        project_state.add_model(ModelState.from_model(B))
-        project_state.add_model(ModelState.from_model(C))
-        project_state.add_model(ModelState.from_model(D))
-        project_state.add_model(ModelState.from_model(E))
-        project_state.add_model(ModelState.from_model(F))
-        final_apps = project_state.apps
-        self.assertEqual(len(final_apps.get_models()), 6)
-
-        # Now make an invalid ProjectState and make sure it fails
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(A))
-        project_state.add_model(ModelState.from_model(B))
-        project_state.add_model(ModelState.from_model(C))
-        project_state.add_model(ModelState.from_model(F))
-        with self.assertRaises(InvalidBasesError):
-            project_state.apps
-
-    def test_render_unique_app_labels(self):
-        """
-        The ProjectState render method doesn't raise an
-        ImproperlyConfigured exception about unique labels if two dotted app
-        names have the same last part.
-        """
-        class A(models.Model):
-            class Meta:
-                app_label = "django.contrib.auth"
-
-        class B(models.Model):
-            class Meta:
-                app_label = "vendor.auth"
-
-        # Make a ProjectState and render it
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(A))
-        project_state.add_model(ModelState.from_model(B))
-        self.assertEqual(len(project_state.apps.get_models()), 2)
-
-    def test_reload_related_model_on_non_relational_fields(self):
-        """
-        The model is reloaded even on changes that are not involved in
-        relations. Other models pointing to or from it are also reloaded.
-        """
-        project_state = ProjectState()
-        project_state.apps  # Render project state.
-        project_state.add_model(ModelState('migrations', 'A', []))
-        project_state.add_model(ModelState('migrations', 'B', [
-            ('a', models.ForeignKey('A', models.CASCADE)),
-        ]))
-        project_state.add_model(ModelState('migrations', 'C', [
-            ('b', models.ForeignKey('B', models.CASCADE)),
-            ('name', models.TextField()),
-        ]))
-        project_state.add_model(ModelState('migrations', 'D', [
-            ('a', models.ForeignKey('A', models.CASCADE)),
-        ]))
-        operation = AlterField(
-            model_name='C',
-            name='name',
-            field=models.TextField(blank=True),
-        )
-        operation.state_forwards('migrations', project_state)
-        project_state.reload_model('migrations', 'a', delay=True)
-        A = project_state.apps.get_model('migrations.A')
-        B = project_state.apps.get_model('migrations.B')
-        D = project_state.apps.get_model('migrations.D')
-        self.assertIs(B._meta.get_field('a').related_model, A)
-        self.assertIs(D._meta.get_field('a').related_model, A)
-
-    def test_reload_model_relationship_consistency(self):
-        project_state = ProjectState()
-        project_state.add_model(ModelState('migrations', 'A', []))
-        project_state.add_model(ModelState('migrations', 'B', [
-            ('a', models.ForeignKey('A', models.CASCADE)),
-        ]))
-        project_state.add_model(ModelState('migrations', 'C', [
-            ('b', models.ForeignKey('B', models.CASCADE)),
-        ]))
-        A = project_state.apps.get_model('migrations.A')
-        B = project_state.apps.get_model('migrations.B')
-        C = project_state.apps.get_model('migrations.C')
-        self.assertEqual([r.related_model for r in A._meta.related_objects], [B])
-        self.assertEqual([r.related_model for r in B._meta.related_objects], [C])
-        self.assertEqual([r.related_model for r in C._meta.related_objects], [])
-
-        project_state.reload_model('migrations', 'a', delay=True)
-        A = project_state.apps.get_model('migrations.A')
-        B = project_state.apps.get_model('migrations.B')
-        C = project_state.apps.get_model('migrations.C')
-        self.assertEqual([r.related_model for r in A._meta.related_objects], [B])
-        self.assertEqual([r.related_model for r in B._meta.related_objects], [C])
-        self.assertEqual([r.related_model for r in C._meta.related_objects], [])
-
-    def test_add_relations(self):
-        """
-        #24573 - Adding relations to existing models should reload the
-        referenced models too.
-        """
-        new_apps = Apps()
-
-        class A(models.Model):
-            class Meta:
-                app_label = 'something'
-                apps = new_apps
-
-        class B(A):
-            class Meta:
-                app_label = 'something'
-                apps = new_apps
-
-        class C(models.Model):
-            class Meta:
-                app_label = 'something'
-                apps = new_apps
-
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(A))
-        project_state.add_model(ModelState.from_model(B))
-        project_state.add_model(ModelState.from_model(C))
-
-        project_state.apps  # We need to work with rendered models
-
-        old_state = project_state.clone()
-        model_a_old = old_state.apps.get_model('something', 'A')
-        model_b_old = old_state.apps.get_model('something', 'B')
-        model_c_old = old_state.apps.get_model('something', 'C')
-        # The relations between the old models are correct
-        self.assertIs(model_a_old._meta.get_field('b').related_model, model_b_old)
-        self.assertIs(model_b_old._meta.get_field('a_ptr').related_model, model_a_old)
-
-        operation = AddField('c', 'to_a', models.OneToOneField(
-            'something.A',
-            models.CASCADE,
-            related_name='from_c',
-        ))
-        operation.state_forwards('something', project_state)
-        model_a_new = project_state.apps.get_model('something', 'A')
-        model_b_new = project_state.apps.get_model('something', 'B')
-        model_c_new = project_state.apps.get_model('something', 'C')
-
-        # All models have changed
-        self.assertIsNot(model_a_old, model_a_new)
-        self.assertIsNot(model_b_old, model_b_new)
-        self.assertIsNot(model_c_old, model_c_new)
-        # The relations between the old models still hold
-        self.assertIs(model_a_old._meta.get_field('b').related_model, model_b_old)
-        self.assertIs(model_b_old._meta.get_field('a_ptr').related_model, model_a_old)
-        # The relations between the new models correct
-        self.assertIs(model_a_new._meta.get_field('b').related_model, model_b_new)
-        self.assertIs(model_b_new._meta.get_field('a_ptr').related_model, model_a_new)
-        self.assertIs(model_a_new._meta.get_field('from_c').related_model, model_c_new)
-        self.assertIs(model_c_new._meta.get_field('to_a').related_model, model_a_new)
-
-    def test_remove_relations(self):
-        """
-        #24225 - Relations between models are updated while
-        remaining the relations and references for models of an old state.
-        """
-        new_apps = Apps()
-
-        class A(models.Model):
-            class Meta:
-                app_label = "something"
-                apps = new_apps
-
-        class B(models.Model):
-            to_a = models.ForeignKey(A, models.CASCADE)
-
-            class Meta:
-                app_label = "something"
-                apps = new_apps
-
-        def get_model_a(state):
-            return [mod for mod in state.apps.get_models() if mod._meta.model_name == 'a'][0]
-
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(A))
-        project_state.add_model(ModelState.from_model(B))
-        self.assertEqual(len(get_model_a(project_state)._meta.related_objects), 1)
-        old_state = project_state.clone()
-
-        operation = RemoveField("b", "to_a")
-        operation.state_forwards("something", project_state)
-        # Model from old_state still has the relation
-        model_a_old = get_model_a(old_state)
-        model_a_new = get_model_a(project_state)
-        self.assertIsNot(model_a_old, model_a_new)
-        self.assertEqual(len(model_a_old._meta.related_objects), 1)
-        self.assertEqual(len(model_a_new._meta.related_objects), 0)
-
-        # Same test for deleted model
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(A))
-        project_state.add_model(ModelState.from_model(B))
-        old_state = project_state.clone()
-
-        operation = DeleteModel("b")
-        operation.state_forwards("something", project_state)
-        model_a_old = get_model_a(old_state)
-        model_a_new = get_model_a(project_state)
-        self.assertIsNot(model_a_old, model_a_new)
-        self.assertEqual(len(model_a_old._meta.related_objects), 1)
-        self.assertEqual(len(model_a_new._meta.related_objects), 0)
-
-    def test_self_relation(self):
-        """
-        #24513 - Modifying an object pointing to itself would cause it to be
-        rendered twice and thus breaking its related M2M through objects.
-        """
-        class A(models.Model):
-            to_a = models.ManyToManyField('something.A', symmetrical=False)
-
-            class Meta:
-                app_label = "something"
-
-        def get_model_a(state):
-            return [mod for mod in state.apps.get_models() if mod._meta.model_name == 'a'][0]
-
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(A))
-        self.assertEqual(len(get_model_a(project_state)._meta.related_objects), 1)
-        old_state = project_state.clone()
-
-        operation = AlterField(
-            model_name="a",
-            name="to_a",
-            field=models.ManyToManyField("something.A", symmetrical=False, blank=True)
-        )
-        # At this point the model would be rendered twice causing its related
-        # M2M through objects to point to an old copy and thus breaking their
-        # attribute lookup.
-        operation.state_forwards("something", project_state)
-
-        model_a_old = get_model_a(old_state)
-        model_a_new = get_model_a(project_state)
-        self.assertIsNot(model_a_old, model_a_new)
-
-        # The old model's _meta is still consistent
-        field_to_a_old = model_a_old._meta.get_field("to_a")
-        self.assertEqual(field_to_a_old.m2m_field_name(), "from_a")
-        self.assertEqual(field_to_a_old.m2m_reverse_field_name(), "to_a")
-        self.assertIs(field_to_a_old.related_model, model_a_old)
-        self.assertIs(field_to_a_old.remote_field.through._meta.get_field('to_a').related_model, model_a_old)
-        self.assertIs(field_to_a_old.remote_field.through._meta.get_field('from_a').related_model, model_a_old)
-
-        # The new model's _meta is still consistent
-        field_to_a_new = model_a_new._meta.get_field("to_a")
-        self.assertEqual(field_to_a_new.m2m_field_name(), "from_a")
-        self.assertEqual(field_to_a_new.m2m_reverse_field_name(), "to_a")
-        self.assertIs(field_to_a_new.related_model, model_a_new)
-        self.assertIs(field_to_a_new.remote_field.through._meta.get_field('to_a').related_model, model_a_new)
-        self.assertIs(field_to_a_new.remote_field.through._meta.get_field('from_a').related_model, model_a_new)
-
-    def test_equality(self):
-        """
-        == and != are implemented correctly.
-        """
-        # Test two things that should be equal
-        project_state = ProjectState()
-        project_state.add_model(ModelState(
-            "migrations",
-            "Tag",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=100)),
-                ("hidden", models.BooleanField()),
-            ],
-            {},
-            None,
-        ))
-        project_state.apps  # Fill the apps cached property
-        other_state = project_state.clone()
-        self.assertEqual(project_state, project_state)
-        self.assertEqual(project_state, other_state)
-        self.assertIs(project_state != project_state, False)
-        self.assertIs(project_state != other_state, False)
-        self.assertNotEqual(project_state.apps, other_state.apps)
-
-        # Make a very small change (max_len 99) and see if that affects it
-        project_state = ProjectState()
-        project_state.add_model(ModelState(
-            "migrations",
-            "Tag",
-            [
-                ("id", models.AutoField(primary_key=True)),
-                ("name", models.CharField(max_length=99)),
-                ("hidden", models.BooleanField()),
-            ],
-            {},
-            None,
-        ))
-        self.assertNotEqual(project_state, other_state)
-        self.assertIs(project_state == other_state, False)
-
-    def test_dangling_references_throw_error(self):
-        new_apps = Apps()
-
-        class Author(models.Model):
-            name = models.TextField()
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class Publisher(models.Model):
-            name = models.TextField()
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class Book(models.Model):
-            author = models.ForeignKey(Author, models.CASCADE)
-            publisher = models.ForeignKey(Publisher, models.CASCADE)
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class Magazine(models.Model):
-            authors = models.ManyToManyField(Author)
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        # Make a valid ProjectState and render it
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(Author))
-        project_state.add_model(ModelState.from_model(Publisher))
-        project_state.add_model(ModelState.from_model(Book))
-        project_state.add_model(ModelState.from_model(Magazine))
-        self.assertEqual(len(project_state.apps.get_models()), 4)
-
-        # now make an invalid one with a ForeignKey
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(Book))
-        msg = (
-            "The field migrations.Book.author was declared with a lazy reference "
-            "to 'migrations.author', but app 'migrations' doesn't provide model 'author'.\n"
-            "The field migrations.Book.publisher was declared with a lazy reference "
-            "to 'migrations.publisher', but app 'migrations' doesn't provide model 'publisher'."
-        )
-        with self.assertRaisesMessage(ValueError, msg):
-            project_state.apps
-
-        # And another with ManyToManyField.
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(Magazine))
-        msg = (
-            "The field migrations.Magazine.authors was declared with a lazy reference "
-            "to 'migrations.author\', but app 'migrations' doesn't provide model 'author'.\n"
-            "The field migrations.Magazine_authors.author was declared with a lazy reference "
-            "to \'migrations.author\', but app 'migrations' doesn't provide model 'author'."
-        )
-        with self.assertRaisesMessage(ValueError, msg):
-            project_state.apps
-
-        # And now with multiple models and multiple fields.
-        project_state.add_model(ModelState.from_model(Book))
-        msg = (
-            "The field migrations.Book.author was declared with a lazy reference "
-            "to 'migrations.author', but app 'migrations' doesn't provide model 'author'.\n"
-            "The field migrations.Book.publisher was declared with a lazy reference "
-            "to 'migrations.publisher', but app 'migrations' doesn't provide model 'publisher'.\n"
-            "The field migrations.Magazine.authors was declared with a lazy reference "
-            "to 'migrations.author', but app 'migrations' doesn't provide model 'author'.\n"
-            "The field migrations.Magazine_authors.author was declared with a lazy reference "
-            "to 'migrations.author', but app 'migrations' doesn't provide model 'author'."
-        )
-        with self.assertRaisesMessage(ValueError, msg):
-            project_state.apps
-
-    def test_real_apps(self):
-        """
-        Including real apps can resolve dangling FK errors.
-        This test relies on the fact that contenttypes is always loaded.
-        """
-        new_apps = Apps()
-
-        class TestModel(models.Model):
-            ct = models.ForeignKey("contenttypes.ContentType", models.CASCADE)
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        # If we just stick it into an empty state it should fail
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(TestModel))
-        with self.assertRaises(ValueError):
-            project_state.apps
-
-        # If we include the real app it should succeed
-        project_state = ProjectState(real_apps=["contenttypes"])
-        project_state.add_model(ModelState.from_model(TestModel))
-        rendered_state = project_state.apps
-        self.assertEqual(
-            len([x for x in rendered_state.get_models() if x._meta.app_label == "migrations"]),
-            1,
-        )
-
-    def test_ignore_order_wrt(self):
-        """
-        Makes sure ProjectState doesn't include OrderWrt fields when
-        making from existing models.
-        """
-        new_apps = Apps()
-
-        class Author(models.Model):
-            name = models.TextField()
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        class Book(models.Model):
-            author = models.ForeignKey(Author, models.CASCADE)
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-                order_with_respect_to = "author"
-
-        # Make a valid ProjectState and render it
-        project_state = ProjectState()
-        project_state.add_model(ModelState.from_model(Author))
-        project_state.add_model(ModelState.from_model(Book))
-        self.assertEqual(
-            list(project_state.models['migrations', 'book'].fields),
-            ["id", "author"],
-        )
-
-    def test_manager_refer_correct_model_version(self):
-        """
-        #24147 - Managers refer to the correct version of a
-        historical model
-        """
-        project_state = ProjectState()
-        project_state.add_model(ModelState(
-            app_label="migrations",
-            name="Tag",
-            fields=[
-                ("id", models.AutoField(primary_key=True)),
-                ("hidden", models.BooleanField()),
-            ],
-            managers=[
-                ('food_mgr', FoodManager('a', 'b')),
-                ('food_qs', FoodQuerySet.as_manager()),
-            ]
-        ))
-
-        old_model = project_state.apps.get_model('migrations', 'tag')
-
-        new_state = project_state.clone()
-        operation = RemoveField("tag", "hidden")
-        operation.state_forwards("migrations", new_state)
-
-        new_model = new_state.apps.get_model('migrations', 'tag')
-
-        self.assertIsNot(old_model, new_model)
-        self.assertIs(old_model, old_model.food_mgr.model)
-        self.assertIs(old_model, old_model.food_qs.model)
-        self.assertIs(new_model, new_model.food_mgr.model)
-        self.assertIs(new_model, new_model.food_qs.model)
-        self.assertIsNot(old_model.food_mgr, new_model.food_mgr)
-        self.assertIsNot(old_model.food_qs, new_model.food_qs)
-        self.assertIsNot(old_model.food_mgr.model, new_model.food_mgr.model)
-        self.assertIsNot(old_model.food_qs.model, new_model.food_qs.model)
-
-    def test_choices_iterator(self):
-        """
-        #24483 - ProjectState.from_apps should not destructively consume
-        Field.choices iterators.
-        """
-        new_apps = Apps(["migrations"])
-        choices = [('a', 'A'), ('b', 'B')]
-
-        class Author(models.Model):
-            name = models.CharField(max_length=255)
-            choice = models.CharField(max_length=255, choices=iter(choices))
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-
-        ProjectState.from_apps(new_apps)
-        choices_field = Author._meta.get_field('choice')
-        self.assertEqual(list(choices_field.choices), choices)
-
-
-class ModelStateTests(SimpleTestCase):
-    def test_custom_model_base(self):
-        state = ModelState.from_model(ModelWithCustomBase)
-        self.assertEqual(state.bases, (models.Model,))
-
-    def test_bound_field_sanity_check(self):
-        field = models.CharField(max_length=1)
-        field.model = models.Model
-        with self.assertRaisesMessage(ValueError, 'ModelState.fields cannot be bound to a model - "field" is.'):
-            ModelState('app', 'Model', [('field', field)])
-
-    def test_sanity_check_to(self):
-        field = models.ForeignKey(UnicodeModel, models.CASCADE)
-        with self.assertRaisesMessage(
-            ValueError,
-            'ModelState.fields cannot refer to a model class - "field.to" does. '
-            'Use a string reference instead.'
-        ):
-            ModelState('app', 'Model', [('field', field)])
-
-    def test_sanity_check_through(self):
-        field = models.ManyToManyField('UnicodeModel')
-        field.remote_field.through = UnicodeModel
-        with self.assertRaisesMessage(
-            ValueError,
-            'ModelState.fields cannot refer to a model class - "field.through" does. '
-            'Use a string reference instead.'
-        ):
-            ModelState('app', 'Model', [('field', field)])
-
-    def test_sanity_index_name(self):
-        field = models.IntegerField()
-        options = {'indexes': [models.Index(fields=['field'])]}
-        msg = "Indexes passed to ModelState require a name attribute. <Index: fields='field'> doesn't have one."
-        with self.assertRaisesMessage(ValueError, msg):
-            ModelState('app', 'Model', [('field', field)], options=options)
-
-    def test_fields_immutability(self):
-        """
-        Rendering a model state doesn't alter its internal fields.
-        """
-        apps = Apps()
-        field = models.CharField(max_length=1)
-        state = ModelState('app', 'Model', [('name', field)])
-        Model = state.render(apps)
-        self.assertNotEqual(Model._meta.get_field('name'), field)
-
-    def test_repr(self):
-        field = models.CharField(max_length=1)
-        state = ModelState('app', 'Model', [('name', field)], bases=['app.A', 'app.B', 'app.C'])
-        self.assertEqual(repr(state), "<ModelState: 'app.Model'>")
-
-        project_state = ProjectState()
-        project_state.add_model(state)
-        with self.assertRaisesMessage(InvalidBasesError, "Cannot resolve bases for [<ModelState: 'app.Model'>]"):
-            project_state.apps
-
-    def test_fields_ordering_equality(self):
-        state = ModelState(
-            'migrations',
-            'Tag',
-            [
-                ('id', models.AutoField(primary_key=True)),
-                ('name', models.CharField(max_length=100)),
-                ('hidden', models.BooleanField()),
-            ],
-        )
-        reordered_state = ModelState(
-            'migrations',
-            'Tag',
-            [
-                ('id', models.AutoField(primary_key=True)),
-                # Purposedly re-ordered.
-                ('hidden', models.BooleanField()),
-                ('name', models.CharField(max_length=100)),
-            ],
-        )
-        self.assertEqual(state, reordered_state)
-
-    @override_settings(TEST_SWAPPABLE_MODEL='migrations.SomeFakeModel')
-    def test_create_swappable(self):
-        """
-        Tests making a ProjectState from an Apps with a swappable model
-        """
-        new_apps = Apps(['migrations'])
-
-        class Author(models.Model):
-            name = models.CharField(max_length=255)
-            bio = models.TextField()
-            age = models.IntegerField(blank=True, null=True)
-
-            class Meta:
-                app_label = 'migrations'
-                apps = new_apps
-                swappable = 'TEST_SWAPPABLE_MODEL'
-
-        author_state = ModelState.from_model(Author)
-        self.assertEqual(author_state.app_label, 'migrations')
-        self.assertEqual(author_state.name, 'Author')
-        self.assertEqual(list(author_state.fields), ['id', 'name', 'bio', 'age'])
-        self.assertEqual(author_state.fields['name'].max_length, 255)
-        self.assertIs(author_state.fields['bio'].null, False)
-        self.assertIs(author_state.fields['age'].null, True)
-        self.assertEqual(author_state.options, {'swappable': 'TEST_SWAPPABLE_MODEL', 'indexes': [], "constraints": []})
-        self.assertEqual(author_state.bases, (models.Model,))
-        self.assertEqual(author_state.managers, [])
-
-    @override_settings(TEST_SWAPPABLE_MODEL='migrations.SomeFakeModel')
-    def test_create_swappable_from_abstract(self):
-        """
-        A swappable model inheriting from a hierarchy:
-        concrete -> abstract -> concrete.
-        """
-        new_apps = Apps(['migrations'])
-
-        class SearchableLocation(models.Model):
-            keywords = models.CharField(max_length=256)
-
-            class Meta:
-                app_label = 'migrations'
-                apps = new_apps
-
-        class Station(SearchableLocation):
-            name = models.CharField(max_length=128)
-
-            class Meta:
-                abstract = True
-
-        class BusStation(Station):
-            bus_routes = models.CharField(max_length=128)
-            inbound = models.BooleanField(default=False)
-
-            class Meta(Station.Meta):
-                app_label = 'migrations'
-                apps = new_apps
-                swappable = 'TEST_SWAPPABLE_MODEL'
-
-        station_state = ModelState.from_model(BusStation)
-        self.assertEqual(station_state.app_label, 'migrations')
-        self.assertEqual(station_state.name, 'BusStation')
-        self.assertEqual(
-            list(station_state.fields),
-            ['searchablelocation_ptr', 'name', 'bus_routes', 'inbound']
-        )
-        self.assertEqual(station_state.fields['name'].max_length, 128)
-        self.assertIs(station_state.fields['bus_routes'].null, False)
-        self.assertEqual(
-            station_state.options,
-            {'abstract': False, 'swappable': 'TEST_SWAPPABLE_MODEL', 'indexes': [], 'constraints': []}
-        )
-        self.assertEqual(station_state.bases, ('migrations.searchablelocation',))
-        self.assertEqual(station_state.managers, [])
-
-    @override_settings(TEST_SWAPPABLE_MODEL='migrations.SomeFakeModel')
-    def test_custom_manager_swappable(self):
-        """
-        Tests making a ProjectState from unused models with custom managers
-        """
-        new_apps = Apps(['migrations'])
-
-        class Food(models.Model):
-
-            food_mgr = FoodManager('a', 'b')
-            food_qs = FoodQuerySet.as_manager()
-            food_no_mgr = NoMigrationFoodManager('x', 'y')
-
-            class Meta:
-                app_label = "migrations"
-                apps = new_apps
-                swappable = 'TEST_SWAPPABLE_MODEL'
-
-        food_state = ModelState.from_model(Food)
-
-        # The default manager is used in migrations
-        self.assertEqual([name for name, mgr in food_state.managers], ['food_mgr'])
-        self.assertEqual(food_state.managers[0][1].args, ('a', 'b', 1, 2))
-
-    @isolate_apps('migrations', 'django.contrib.contenttypes')
-    def test_order_with_respect_to_private_field(self):
-        class PrivateFieldModel(models.Model):
-            content_type = models.ForeignKey('contenttypes.ContentType', models.CASCADE)
-            object_id = models.PositiveIntegerField()
-            private = GenericForeignKey()
-
-            class Meta:
-                order_with_respect_to = 'private'
-
-        state = ModelState.from_model(PrivateFieldModel)
-        self.assertNotIn('order_with_respect_to', state.options)
-
-    @isolate_apps('migrations')
-    def test_abstract_model_children_inherit_indexes(self):
-        class Abstract(models.Model):
-            name = models.CharField(max_length=50)
-
-            class Meta:
-                app_label = 'migrations'
-                abstract = True
-                indexes = [models.Index(fields=['name'])]
-
-        class Child1(Abstract):
-            pass
-
-        class Child2(Abstract):
-            pass
-
-        child1_state = ModelState.from_model(Child1)
-        child2_state = ModelState.from_model(Child2)
-        index_names = [index.name for index in child1_state.options['indexes']]
-        self.assertEqual(index_names, ['migrations__name_b0afd7_idx'])
-        index_names = [index.name for index in child2_state.options['indexes']]
-        self.assertEqual(index_names, ['migrations__name_016466_idx'])
-
-        # Modifying the state doesn't modify the index on the model.
-        child1_state.options['indexes'][0].name = 'bar'
-        self.assertEqual(Child1._meta.indexes[0].name, 'migrations__name_b0afd7_idx')
-
-    @isolate_apps('migrations')
-    def test_explicit_index_name(self):
-        class TestModel(models.Model):
-            name = models.CharField(max_length=50)
-
-            class Meta:
-                app_label = 'migrations'
-                indexes = [models.Index(fields=['name'], name='foo_idx')]
-
-        model_state = ModelState.from_model(TestModel)
-        index_names = [index.name for index in model_state.options['indexes']]
-        self.assertEqual(index_names, ['foo_idx'])
-
-    @isolate_apps('migrations')
-    def test_from_model_constraints(self):
-        class ModelWithConstraints(models.Model):
-            size = models.IntegerField()
-
-            class Meta:
-                constraints = [models.CheckConstraint(check=models.Q(size__gt=1), name='size_gt_1')]
-
-        state = ModelState.from_model(ModelWithConstraints)
-        model_constraints = ModelWithConstraints._meta.constraints
-        state_constraints = state.options['constraints']
-        self.assertEqual(model_constraints, state_constraints)
-        self.assertIsNot(model_constraints, state_constraints)
-        self.assertIsNot(model_constraints[0], state_constraints[0])
-
-
-class RelatedModelsTests(SimpleTestCase):
-
-    def setUp(self):
-        self.apps = Apps(['migrations.related_models_app'])
-
-    def create_model(self, name, foreign_keys=[], bases=(), abstract=False, proxy=False):
-        test_name = 'related_models_app'
-        assert not (abstract and proxy)
-        meta_contents = {
-            'abstract': abstract,
-            'app_label': test_name,
-            'apps': self.apps,
-            'proxy': proxy,
-        }
-        meta = type("Meta", (), meta_contents)
-        if not bases:
-            bases = (models.Model,)
-        body = {
-            'Meta': meta,
-            '__module__': "__fake__",
-        }
-        fname_base = fname = '%s_%%d' % name.lower()
-        for i, fk in enumerate(foreign_keys, 1):
-            fname = fname_base % i
-            body[fname] = fk
-        return type(name, bases, body)
-
-    def assertRelated(self, model, needle):
-        self.assertEqual(
-            get_related_models_recursive(model),
-            {(n._meta.app_label, n._meta.model_name) for n in needle},
-        )
-
-    def test_unrelated(self):
-        A = self.create_model("A")
-        B = self.create_model("B")
-        self.assertRelated(A, [])
-        self.assertRelated(B, [])
-
-    def test_direct_fk(self):
-        A = self.create_model("A", foreign_keys=[models.ForeignKey('B', models.CASCADE)])
-        B = self.create_model("B")
-        self.assertRelated(A, [B])
-        self.assertRelated(B, [A])
-
-    def test_direct_hidden_fk(self):
-        A = self.create_model("A", foreign_keys=[models.ForeignKey('B', models.CASCADE, related_name='+')])
-        B = self.create_model("B")
-        self.assertRelated(A, [B])
-        self.assertRelated(B, [A])
-
-    def test_fk_through_proxy(self):
-        A = self.create_model("A")
-        B = self.create_model("B", bases=(A,), proxy=True)
-        C = self.create_model("C", bases=(B,), proxy=True)
-        D = self.create_model("D", foreign_keys=[models.ForeignKey('C', models.CASCADE)])
-        self.assertRelated(A, [B, C, D])
-        self.assertRelated(B, [A, C, D])
-        self.assertRelated(C, [A, B, D])
-        self.assertRelated(D, [A, B, C])
-
-    def test_nested_fk(self):
-        A = self.create_model("A", foreign_keys=[models.ForeignKey('B', models.CASCADE)])
-        B = self.create_model("B", foreign_keys=[models.ForeignKey('C', models.CASCADE)])
-        C = self.create_model("C")
-        self.assertRelated(A, [B, C])
-        self.assertRelated(B, [A, C])
-        self.assertRelated(C, [A, B])
-
-    def test_two_sided(self):
-        A = self.create_model("A", foreign_keys=[models.ForeignKey('B', models.CASCADE)])
-        B = self.create_model("B", foreign_keys=[models.ForeignKey('A', models.CASCADE)])
-        self.assertRelated(A, [B])
-        self.assertRelated(B, [A])
-
-    def test_circle(self):
-        A = self.create_model("A", foreign_keys=[models.ForeignKey('B', models.CASCADE)])
-        B = self.create_model("B", foreign_keys=[models.ForeignKey('C', models.CASCADE)])
-        C = self.create_model("C", foreign_keys=[models.ForeignKey('A', models.CASCADE)])
-        self.assertRelated(A, [B, C])
-        self.assertRelated(B, [A, C])
-        self.assertRelated(C, [A, B])
-
-    def test_base(self):
-        A = self.create_model("A")
-        B = self.create_model("B", bases=(A,))
-        self.assertRelated(A, [B])
-        self.assertRelated(B, [A])
-
-    def test_nested_base(self):
-        A = self.create_model("A")
-        B = self.create_model("B", bases=(A,))
-        C = self.create_model("C", bases=(B,))
-        self.assertRelated(A, [B, C])
-        self.assertRelated(B, [A, C])
-        self.assertRelated(C, [A, B])
-
-    def test_multiple_bases(self):
-        A = self.create_model("A")
-        B = self.create_model("B")
-        C = self.create_model("C", bases=(A, B,))
-        self.assertRelated(A, [B, C])
-        self.assertRelated(B, [A, C])
-        self.assertRelated(C, [A, B])
-
-    def test_multiple_nested_bases(self):
-        A = self.create_model("A")
-        B = self.create_model("B")
-        C = self.create_model("C", bases=(A, B,))
-        D = self.create_model("D")
-        E = self.create_model("E", bases=(D,))
-        F = self.create_model("F", bases=(C, E,))
-        Y = self.create_model("Y")
-        Z = self.create_model("Z", bases=(Y,))
-        self.assertRelated(A, [B, C, D, E, F])
-        self.assertRelated(B, [A, C, D, E, F])
-        self.assertRelated(C, [A, B, D, E, F])
-        self.assertRelated(D, [A, B, C, E, F])
-        self.assertRelated(E, [A, B, C, D, F])
-        self.assertRelated(F, [A, B, C, D, E])
-        self.assertRelated(Y, [Z])
-        self.assertRelated(Z, [Y])
-
-    def test_base_to_base_fk(self):
-        A = self.create_model("A", foreign_keys=[models.ForeignKey('Y', models.CASCADE)])
-        B = self.create_model("B", bases=(A,))
-        Y = self.create_model("Y")
-        Z = self.create_model("Z", bases=(Y,))
-        self.assertRelated(A, [B, Y, Z])
-        self.assertRelated(B, [A, Y, Z])
-        self.assertRelated(Y, [A, B, Z])
-        self.assertRelated(Z, [A, B, Y])
-
-    def test_base_to_subclass_fk(self):
-        A = self.create_model("A", foreign_keys=[models.ForeignKey('Z', models.CASCADE)])
-        B = self.create_model("B", bases=(A,))
-        Y = self.create_model("Y")
-        Z = self.create_model("Z", bases=(Y,))
-        self.assertRelated(A, [B, Y, Z])
-        self.assertRelated(B, [A, Y, Z])
-        self.assertRelated(Y, [A, B, Z])
-        self.assertRelated(Z, [A, B, Y])
-
-    def test_direct_m2m(self):
-        A = self.create_model("A", foreign_keys=[models.ManyToManyField('B')])
-        B = self.create_model("B")
-        self.assertRelated(A, [A.a_1.rel.through, B])
-        self.assertRelated(B, [A, A.a_1.rel.through])
-
-    def test_direct_m2m_self(self):
-        A = self.create_model("A", foreign_keys=[models.ManyToManyField('A')])
-        self.assertRelated(A, [A.a_1.rel.through])
-
-    def test_intermediate_m2m_self(self):
-        A = self.create_model("A", foreign_keys=[models.ManyToManyField('A', through='T')])
-        T = self.create_model("T", foreign_keys=[
-            models.ForeignKey('A', models.CASCADE),
-            models.ForeignKey('A', models.CASCADE),
-        ])
-        self.assertRelated(A, [T])
-        self.assertRelated(T, [A])
-
-    def test_intermediate_m2m(self):
-        A = self.create_model("A", foreign_keys=[models.ManyToManyField('B', through='T')])
-        B = self.create_model("B")
-        T = self.create_model("T", foreign_keys=[
-            models.ForeignKey('A', models.CASCADE),
-            models.ForeignKey('B', models.CASCADE),
-        ])
-        self.assertRelated(A, [B, T])
-        self.assertRelated(B, [A, T])
-        self.assertRelated(T, [A, B])
-
-    def test_intermediate_m2m_extern_fk(self):
-        A = self.create_model("A", foreign_keys=[models.ManyToManyField('B', through='T')])
-        B = self.create_model("B")
-        Z = self.create_model("Z")
-        T = self.create_model("T", foreign_keys=[
-            models.ForeignKey('A', models.CASCADE),
-            models.ForeignKey('B', models.CASCADE),
-            models.ForeignKey('Z', models.CASCADE),
-        ])
-        self.assertRelated(A, [B, T, Z])
-        self.assertRelated(B, [A, T, Z])
-        self.assertRelated(T, [A, B, Z])
-        self.assertRelated(Z, [A, B, T])
-
-    def test_intermediate_m2m_base(self):
-        A = self.create_model("A", foreign_keys=[models.ManyToManyField('B', through='T')])
-        B = self.create_model("B")
-        S = self.create_model("S")
-        T = self.create_model("T", foreign_keys=[
-            models.ForeignKey('A', models.CASCADE),
-            models.ForeignKey('B', models.CASCADE),
-        ], bases=(S,))
-        self.assertRelated(A, [B, S, T])
-        self.assertRelated(B, [A, S, T])
-        self.assertRelated(S, [A, B, T])
-        self.assertRelated(T, [A, B, S])
-
-    def test_generic_fk(self):
-        A = self.create_model("A", foreign_keys=[
-            models.ForeignKey('B', models.CASCADE),
-            GenericForeignKey(),
-        ])
-        B = self.create_model("B", foreign_keys=[
-            models.ForeignKey('C', models.CASCADE),
-        ])
-        self.assertRelated(A, [B])
-        self.assertRelated(B, [A])
-
-    def test_abstract_base(self):
-        A = self.create_model("A", abstract=True)
-        B = self.create_model("B", bases=(A,))
-        self.assertRelated(A, [B])
-        self.assertRelated(B, [])
-
-    def test_nested_abstract_base(self):
-        A = self.create_model("A", abstract=True)
-        B = self.create_model("B", bases=(A,), abstract=True)
-        C = self.create_model("C", bases=(B,))
-        self.assertRelated(A, [B, C])
-        self.assertRelated(B, [C])
-        self.assertRelated(C, [])
-
-    def test_proxy_base(self):
-        A = self.create_model("A")
-        B = self.create_model("B", bases=(A,), proxy=True)
-        self.assertRelated(A, [B])
-        self.assertRelated(B, [])
-
-    def test_nested_proxy_base(self):
-        A = self.create_model("A")
-        B = self.create_model("B", bases=(A,), proxy=True)
-        C = self.create_model("C", bases=(B,), proxy=True)
-        self.assertRelated(A, [B, C])
-        self.assertRelated(B, [C])
-        self.assertRelated(C, [])
-
-    def test_multiple_mixed_bases(self):
-        A = self.create_model("A", abstract=True)
-        M = self.create_model("M")
-        P = self.create_model("P")
-        Q = self.create_model("Q", bases=(P,), proxy=True)
-        Z = self.create_model("Z", bases=(A, M, Q))
-        # M has a pointer O2O field p_ptr to P
-        self.assertRelated(A, [M, P, Q, Z])
-        self.assertRelated(M, [P, Q, Z])
-        self.assertRelated(P, [M, Q, Z])
-        self.assertRelated(Q, [M, P, Z])
-        self.assertRelated(Z, [M, P, Q])
diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py
deleted file mode 100644
index 6a65e87d5a..0000000000
--- a/tests/migrations/test_writer.py
+++ /dev/null
@@ -1,766 +0,0 @@
-import datetime
-import decimal
-import enum
-import functools
-import math
-import os
-import re
-import uuid
-from unittest import mock
-
-import custom_migration_operations.more_operations
-import custom_migration_operations.operations
-
-from django import get_version
-from django.conf import SettingsReference, settings
-from django.core.validators import EmailValidator, RegexValidator
-from django.db import migrations, models
-from django.db.migrations.serializer import BaseSerializer
-from django.db.migrations.writer import MigrationWriter, OperationWriter
-from django.test import SimpleTestCase
-from django.utils.deconstruct import deconstructible
-from django.utils.functional import SimpleLazyObject
-from django.utils.timezone import get_default_timezone, get_fixed_timezone, utc
-from django.utils.translation import gettext_lazy as _
-
-from .models import FoodManager, FoodQuerySet
-
-
-class DeconstructibleInstances:
-    def deconstruct(self):
-        return ('DeconstructibleInstances', [], {})
-
-
-class Money(decimal.Decimal):
-    def deconstruct(self):
-        return (
-            '%s.%s' % (self.__class__.__module__, self.__class__.__name__),
-            [str(self)],
-            {}
-        )
-
-
-class TestModel1:
-    def upload_to(self):
-        return '/somewhere/dynamic/'
-    thing = models.FileField(upload_to=upload_to)
-
-
-class TextEnum(enum.Enum):
-    A = 'a-value'
-    B = 'value-b'
-
-
-class TextTranslatedEnum(enum.Enum):
-    A = _('a-value')
-    B = _('value-b')
-
-
-class BinaryEnum(enum.Enum):
-    A = b'a-value'
-    B = b'value-b'
-
-
-class IntEnum(enum.IntEnum):
-    A = 1
-    B = 2
-
-
-class OperationWriterTests(SimpleTestCase):
-
-    def test_empty_signature(self):
-        operation = custom_migration_operations.operations.TestOperation()
-        buff, imports = OperationWriter(operation, indentation=0).serialize()
-        self.assertEqual(imports, {'import custom_migration_operations.operations'})
-        self.assertEqual(
-            buff,
-            'custom_migration_operations.operations.TestOperation(\n'
-            '),'
-        )
-
-    def test_args_signature(self):
-        operation = custom_migration_operations.operations.ArgsOperation(1, 2)
-        buff, imports = OperationWriter(operation, indentation=0).serialize()
-        self.assertEqual(imports, {'import custom_migration_operations.operations'})
-        self.assertEqual(
-            buff,
-            'custom_migration_operations.operations.ArgsOperation(\n'
-            '    arg1=1,\n'
-            '    arg2=2,\n'
-            '),'
-        )
-
-    def test_kwargs_signature(self):
-        operation = custom_migration_operations.operations.KwargsOperation(kwarg1=1)
-        buff, imports = OperationWriter(operation, indentation=0).serialize()
-        self.assertEqual(imports, {'import custom_migration_operations.operations'})
-        self.assertEqual(
-            buff,
-            'custom_migration_operations.operations.KwargsOperation(\n'
-            '    kwarg1=1,\n'
-            '),'
-        )
-
-    def test_args_kwargs_signature(self):
-        operation = custom_migration_operations.operations.ArgsKwargsOperation(1, 2, kwarg2=4)
-        buff, imports = OperationWriter(operation, indentation=0).serialize()
-        self.assertEqual(imports, {'import custom_migration_operations.operations'})
-        self.assertEqual(
-            buff,
-            'custom_migration_operations.operations.ArgsKwargsOperation(\n'
-            '    arg1=1,\n'
-            '    arg2=2,\n'
-            '    kwarg2=4,\n'
-            '),'
-        )
-
-    def test_nested_args_signature(self):
-        operation = custom_migration_operations.operations.ArgsOperation(
-            custom_migration_operations.operations.ArgsOperation(1, 2),
-            custom_migration_operations.operations.KwargsOperation(kwarg1=3, kwarg2=4)
-        )
-        buff, imports = OperationWriter(operation, indentation=0).serialize()
-        self.assertEqual(imports, {'import custom_migration_operations.operations'})
-        self.assertEqual(
-            buff,
-            'custom_migration_operations.operations.ArgsOperation(\n'
-            '    arg1=custom_migration_operations.operations.ArgsOperation(\n'
-            '        arg1=1,\n'
-            '        arg2=2,\n'
-            '    ),\n'
-            '    arg2=custom_migration_operations.operations.KwargsOperation(\n'
-            '        kwarg1=3,\n'
-            '        kwarg2=4,\n'
-            '    ),\n'
-            '),'
-        )
-
-    def test_multiline_args_signature(self):
-        operation = custom_migration_operations.operations.ArgsOperation("test\n    arg1", "test\narg2")
-        buff, imports = OperationWriter(operation, indentation=0).serialize()
-        self.assertEqual(imports, {'import custom_migration_operations.operations'})
-        self.assertEqual(
-            buff,
-            "custom_migration_operations.operations.ArgsOperation(\n"
-            "    arg1='test\\n    arg1',\n"
-            "    arg2='test\\narg2',\n"
-            "),"
-        )
-
-    def test_expand_args_signature(self):
-        operation = custom_migration_operations.operations.ExpandArgsOperation([1, 2])
-        buff, imports = OperationWriter(operation, indentation=0).serialize()
-        self.assertEqual(imports, {'import custom_migration_operations.operations'})
-        self.assertEqual(
-            buff,
-            'custom_migration_operations.operations.ExpandArgsOperation(\n'
-            '    arg=[\n'
-            '        1,\n'
-            '        2,\n'
-            '    ],\n'
-            '),'
-        )
-
-    def test_nested_operation_expand_args_signature(self):
-        operation = custom_migration_operations.operations.ExpandArgsOperation(
-            arg=[
-                custom_migration_operations.operations.KwargsOperation(
-                    kwarg1=1,
-                    kwarg2=2,
-                ),
-            ]
-        )
-        buff, imports = OperationWriter(operation, indentation=0).serialize()
-        self.assertEqual(imports, {'import custom_migration_operations.operations'})
-        self.assertEqual(
-            buff,
-            'custom_migration_operations.operations.ExpandArgsOperation(\n'
-            '    arg=[\n'
-            '        custom_migration_operations.operations.KwargsOperation(\n'
-            '            kwarg1=1,\n'
-            '            kwarg2=2,\n'
-            '        ),\n'
-            '    ],\n'
-            '),'
-        )
-
-
-class WriterTests(SimpleTestCase):
-    """
-    Tests the migration writer (makes migration files from Migration instances)
-    """
-    class NestedEnum(enum.IntEnum):
-        A = 1
-        B = 2
-
-    class NestedChoices(models.TextChoices):
-        X = 'X', 'X value'
-        Y = 'Y', 'Y value'
-
-    def safe_exec(self, string, value=None):
-        d = {}
-        try:
-            exec(string, globals(), d)
-        except Exception as e:
-            if value:
-                self.fail("Could not exec %r (from value %r): %s" % (string.strip(), value, e))
-            else:
-                self.fail("Could not exec %r: %s" % (string.strip(), e))
-        return d
-
-    def serialize_round_trip(self, value):
-        string, imports = MigrationWriter.serialize(value)
-        return self.safe_exec("%s\ntest_value_result = %s" % ("\n".join(imports), string), value)['test_value_result']
-
-    def assertSerializedEqual(self, value):
-        self.assertEqual(self.serialize_round_trip(value), value)
-
-    def assertSerializedResultEqual(self, value, target):
-        self.assertEqual(MigrationWriter.serialize(value), target)
-
-    def assertSerializedFieldEqual(self, value):
-        new_value = self.serialize_round_trip(value)
-        self.assertEqual(value.__class__, new_value.__class__)
-        self.assertEqual(value.max_length, new_value.max_length)
-        self.assertEqual(value.null, new_value.null)
-        self.assertEqual(value.unique, new_value.unique)
-
-    def test_serialize_numbers(self):
-        self.assertSerializedEqual(1)
-        self.assertSerializedEqual(1.2)
-        self.assertTrue(math.isinf(self.serialize_round_trip(float("inf"))))
-        self.assertTrue(math.isinf(self.serialize_round_trip(float("-inf"))))
-        self.assertTrue(math.isnan(self.serialize_round_trip(float("nan"))))
-
-        self.assertSerializedEqual(decimal.Decimal('1.3'))
-        self.assertSerializedResultEqual(
-            decimal.Decimal('1.3'),
-            ("Decimal('1.3')", {'from decimal import Decimal'})
-        )
-
-        self.assertSerializedEqual(Money('1.3'))
-        self.assertSerializedResultEqual(
-            Money('1.3'),
-            ("migrations.test_writer.Money('1.3')", {'import migrations.test_writer'})
-        )
-
-    def test_serialize_constants(self):
-        self.assertSerializedEqual(None)
-        self.assertSerializedEqual(True)
-        self.assertSerializedEqual(False)
-
-    def test_serialize_strings(self):
-        self.assertSerializedEqual(b"foobar")
-        string, imports = MigrationWriter.serialize(b"foobar")
-        self.assertEqual(string, "b'foobar'")
-        self.assertSerializedEqual("föobár")
-        string, imports = MigrationWriter.serialize("foobar")
-        self.assertEqual(string, "'foobar'")
-
-    def test_serialize_multiline_strings(self):
-        self.assertSerializedEqual(b"foo\nbar")
-        string, imports = MigrationWriter.serialize(b"foo\nbar")
-        self.assertEqual(string, "b'foo\\nbar'")
-        self.assertSerializedEqual("föo\nbár")
-        string, imports = MigrationWriter.serialize("foo\nbar")
-        self.assertEqual(string, "'foo\\nbar'")
-
-    def test_serialize_collections(self):
-        self.assertSerializedEqual({1: 2})
-        self.assertSerializedEqual(["a", 2, True, None])
-        self.assertSerializedEqual({2, 3, "eighty"})
-        self.assertSerializedEqual({"lalalala": ["yeah", "no", "maybe"]})
-        self.assertSerializedEqual(_('Hello'))
-
-    def test_serialize_builtin_types(self):
-        self.assertSerializedEqual([list, tuple, dict, set, frozenset])
-        self.assertSerializedResultEqual(
-            [list, tuple, dict, set, frozenset],
-            ("[list, tuple, dict, set, frozenset]", set())
-        )
-
-    def test_serialize_lazy_objects(self):
-        pattern = re.compile(r'^foo$')
-        lazy_pattern = SimpleLazyObject(lambda: pattern)
-        self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)
-
-    def test_serialize_enums(self):
-        self.assertSerializedResultEqual(
-            TextEnum.A,
-            ("migrations.test_writer.TextEnum['A']", {'import migrations.test_writer'})
-        )
-        self.assertSerializedResultEqual(
-            TextTranslatedEnum.A,
-            ("migrations.test_writer.TextTranslatedEnum['A']", {'import migrations.test_writer'})
-        )
-        self.assertSerializedResultEqual(
-            BinaryEnum.A,
-            ("migrations.test_writer.BinaryEnum['A']", {'import migrations.test_writer'})
-        )
-        self.assertSerializedResultEqual(
-            IntEnum.B,
-            ("migrations.test_writer.IntEnum['B']", {'import migrations.test_writer'})
-        )
-        self.assertSerializedResultEqual(
-            self.NestedEnum.A,
-            (
-                "migrations.test_writer.WriterTests.NestedEnum['A']",
-                {'import migrations.test_writer'},
-            ),
-        )
-        self.assertSerializedEqual(self.NestedEnum.A)
-
-        field = models.CharField(default=TextEnum.B, choices=[(m.value, m) for m in TextEnum])
-        string = MigrationWriter.serialize(field)[0]
-        self.assertEqual(
-            string,
-            "models.CharField(choices=["
-            "('a-value', migrations.test_writer.TextEnum['A']), "
-            "('value-b', migrations.test_writer.TextEnum['B'])], "
-            "default=migrations.test_writer.TextEnum['B'])"
-        )
-        field = models.CharField(
-            default=TextTranslatedEnum.A,
-            choices=[(m.value, m) for m in TextTranslatedEnum],
-        )
-        string = MigrationWriter.serialize(field)[0]
-        self.assertEqual(
-            string,
-            "models.CharField(choices=["
-            "('a-value', migrations.test_writer.TextTranslatedEnum['A']), "
-            "('value-b', migrations.test_writer.TextTranslatedEnum['B'])], "
-            "default=migrations.test_writer.TextTranslatedEnum['A'])"
-        )
-        field = models.CharField(default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum])
-        string = MigrationWriter.serialize(field)[0]
-        self.assertEqual(
-            string,
-            "models.CharField(choices=["
-            "(b'a-value', migrations.test_writer.BinaryEnum['A']), "
-            "(b'value-b', migrations.test_writer.BinaryEnum['B'])], "
-            "default=migrations.test_writer.BinaryEnum['B'])"
-        )
-        field = models.IntegerField(default=IntEnum.A, choices=[(m.value, m) for m in IntEnum])
-        string = MigrationWriter.serialize(field)[0]
-        self.assertEqual(
-            string,
-            "models.IntegerField(choices=["
-            "(1, migrations.test_writer.IntEnum['A']), "
-            "(2, migrations.test_writer.IntEnum['B'])], "
-            "default=migrations.test_writer.IntEnum['A'])"
-        )
-
-    def test_serialize_choices(self):
-        class TextChoices(models.TextChoices):
-            A = 'A', 'A value'
-            B = 'B', 'B value'
-
-        class IntegerChoices(models.IntegerChoices):
-            A = 1, 'One'
-            B = 2, 'Two'
-
-        class DateChoices(datetime.date, models.Choices):
-            DATE_1 = 1969, 7, 20, 'First date'
-            DATE_2 = 1969, 11, 19, 'Second date'
-
-        self.assertSerializedResultEqual(TextChoices.A, ("'A'", set()))
-        self.assertSerializedResultEqual(IntegerChoices.A, ('1', set()))
-        self.assertSerializedResultEqual(
-            DateChoices.DATE_1,
-            ('datetime.date(1969, 7, 20)', {'import datetime'}),
-        )
-        field = models.CharField(default=TextChoices.B, choices=TextChoices.choices)
-        string = MigrationWriter.serialize(field)[0]
-        self.assertEqual(
-            string,
-            "models.CharField(choices=[('A', 'A value'), ('B', 'B value')], "
-            "default='B')",
-        )
-        field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices.choices)
-        string = MigrationWriter.serialize(field)[0]
-        self.assertEqual(
-            string,
-            "models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)",
-        )
-        field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices.choices)
-        string = MigrationWriter.serialize(field)[0]
-        self.assertEqual(
-            string,
-            "models.DateField(choices=["
-            "(datetime.date(1969, 7, 20), 'First date'), "
-            "(datetime.date(1969, 11, 19), 'Second date')], "
-            "default=datetime.date(1969, 11, 19))"
-        )
-
-    def test_serialize_nested_class(self):
-        for nested_cls in [self.NestedEnum, self.NestedChoices]:
-            cls_name = nested_cls.__name__
-            with self.subTest(cls_name):
-                self.assertSerializedResultEqual(
-                    nested_cls,
-                    (
-                        "migrations.test_writer.WriterTests.%s" % cls_name,
-                        {'import migrations.test_writer'},
-                    ),
-                )
-
-    def test_serialize_uuid(self):
-        self.assertSerializedEqual(uuid.uuid1())
-        self.assertSerializedEqual(uuid.uuid4())
-
-        uuid_a = uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')
-        uuid_b = uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')
-        self.assertSerializedResultEqual(
-            uuid_a,
-            ("uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')", {'import uuid'})
-        )
-        self.assertSerializedResultEqual(
-            uuid_b,
-            ("uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')", {'import uuid'})
-        )
-
-        field = models.UUIDField(choices=((uuid_a, 'UUID A'), (uuid_b, 'UUID B')), default=uuid_a)
-        string = MigrationWriter.serialize(field)[0]
-        self.assertEqual(
-            string,
-            "models.UUIDField(choices=["
-            "(uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'), 'UUID A'), "
-            "(uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2'), 'UUID B')], "
-            "default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))"
-        )
-
-    def test_serialize_functions(self):
-        with self.assertRaisesMessage(ValueError, 'Cannot serialize function: lambda'):
-            self.assertSerializedEqual(lambda x: 42)
-        self.assertSerializedEqual(models.SET_NULL)
-        string, imports = MigrationWriter.serialize(models.SET(42))
-        self.assertEqual(string, 'models.SET(42)')
-        self.serialize_round_trip(models.SET(42))
-
-    def test_serialize_datetime(self):
-        self.assertSerializedEqual(datetime.datetime.utcnow())
-        self.assertSerializedEqual(datetime.datetime.utcnow)
-        self.assertSerializedEqual(datetime.datetime.today())
-        self.assertSerializedEqual(datetime.datetime.today)
-        self.assertSerializedEqual(datetime.date.today())
-        self.assertSerializedEqual(datetime.date.today)
-        self.assertSerializedEqual(datetime.datetime.now().time())
-        self.assertSerializedEqual(datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone()))
-        self.assertSerializedEqual(datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180)))
-        self.assertSerializedResultEqual(
-            datetime.datetime(2014, 1, 1, 1, 1),
-            ("datetime.datetime(2014, 1, 1, 1, 1)", {'import datetime'})
-        )
-        self.assertSerializedResultEqual(
-            datetime.datetime(2012, 1, 1, 1, 1, tzinfo=utc),
-            (
-                "datetime.datetime(2012, 1, 1, 1, 1, tzinfo=utc)",
-                {'import datetime', 'from django.utils.timezone import utc'},
-            )
-        )
-
-    def test_serialize_fields(self):
-        self.assertSerializedFieldEqual(models.CharField(max_length=255))
-        self.assertSerializedResultEqual(
-            models.CharField(max_length=255),
-            ("models.CharField(max_length=255)", {"from django.db import models"})
-        )
-        self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))
-        self.assertSerializedResultEqual(
-            models.TextField(null=True, blank=True),
-            ("models.TextField(blank=True, null=True)", {'from django.db import models'})
-        )
-
-    def test_serialize_settings(self):
-        self.assertSerializedEqual(SettingsReference(settings.AUTH_USER_MODEL, "AUTH_USER_MODEL"))
-        self.assertSerializedResultEqual(
-            SettingsReference("someapp.model", "AUTH_USER_MODEL"),
-            ("settings.AUTH_USER_MODEL", {"from django.conf import settings"})
-        )
-
-    def test_serialize_iterators(self):
-        self.assertSerializedResultEqual(
-            ((x, x * x) for x in range(3)),
-            ("((0, 0), (1, 1), (2, 4))", set())
-        )
-
-    def test_serialize_compiled_regex(self):
-        """
-        Make sure compiled regex can be serialized.
-        """
-        regex = re.compile(r'^\w+$')
-        self.assertSerializedEqual(regex)
-
-    def test_serialize_class_based_validators(self):
-        """
-        Ticket #22943: Test serialization of class-based validators, including
-        compiled regexes.
-        """
-        validator = RegexValidator(message="hello")
-        string = MigrationWriter.serialize(validator)[0]
-        self.assertEqual(string, "django.core.validators.RegexValidator(message='hello')")
-        self.serialize_round_trip(validator)
-
-        # Test with a compiled regex.
-        validator = RegexValidator(regex=re.compile(r'^\w+$'))
-        string = MigrationWriter.serialize(validator)[0]
-        self.assertEqual(string, "django.core.validators.RegexValidator(regex=re.compile('^\\\\w+$'))")
-        self.serialize_round_trip(validator)
-
-        # Test a string regex with flag
-        validator = RegexValidator(r'^[0-9]+$', flags=re.S)
-        string = MigrationWriter.serialize(validator)[0]
-        self.assertEqual(string, "django.core.validators.RegexValidator('^[0-9]+$', flags=re.RegexFlag['DOTALL'])")
-        self.serialize_round_trip(validator)
-
-        # Test message and code
-        validator = RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', 'invalid')
-        string = MigrationWriter.serialize(validator)[0]
-        self.assertEqual(string, "django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', 'invalid')")
-        self.serialize_round_trip(validator)
-
-        # Test with a subclass.
-        validator = EmailValidator(message="hello")
-        string = MigrationWriter.serialize(validator)[0]
-        self.assertEqual(string, "django.core.validators.EmailValidator(message='hello')")
-        self.serialize_round_trip(validator)
-
-        validator = deconstructible(path="migrations.test_writer.EmailValidator")(EmailValidator)(message="hello")
-        string = MigrationWriter.serialize(validator)[0]
-        self.assertEqual(string, "migrations.test_writer.EmailValidator(message='hello')")
-
-        validator = deconstructible(path="custom.EmailValidator")(EmailValidator)(message="hello")
-        with self.assertRaisesMessage(ImportError, "No module named 'custom'"):
-            MigrationWriter.serialize(validator)
-
-        validator = deconstructible(path="django.core.validators.EmailValidator2")(EmailValidator)(message="hello")
-        with self.assertRaisesMessage(ValueError, "Could not find object EmailValidator2 in django.core.validators."):
-            MigrationWriter.serialize(validator)
-
-    def test_serialize_empty_nonempty_tuple(self):
-        """
-        Ticket #22679: makemigrations generates invalid code for (an empty
-        tuple) default_permissions = ()
-        """
-        empty_tuple = ()
-        one_item_tuple = ('a',)
-        many_items_tuple = ('a', 'b', 'c')
-        self.assertSerializedEqual(empty_tuple)
-        self.assertSerializedEqual(one_item_tuple)
-        self.assertSerializedEqual(many_items_tuple)
-
-    def test_serialize_range(self):
-        string, imports = MigrationWriter.serialize(range(1, 5))
-        self.assertEqual(string, 'range(1, 5)')
-        self.assertEqual(imports, set())
-
-    def test_serialize_builtins(self):
-        string, imports = MigrationWriter.serialize(range)
-        self.assertEqual(string, 'range')
-        self.assertEqual(imports, set())
-
-    def test_serialize_unbound_method_reference(self):
-        """An unbound method used within a class body can be serialized."""
-        self.serialize_round_trip(TestModel1.thing)
-
-    def test_serialize_local_function_reference(self):
-        """A reference in a local scope can't be serialized."""
-        class TestModel2:
-            def upload_to(self):
-                return "somewhere dynamic"
-            thing = models.FileField(upload_to=upload_to)
-
-        with self.assertRaisesMessage(ValueError, 'Could not find function upload_to in migrations.test_writer'):
-            self.serialize_round_trip(TestModel2.thing)
-
-    def test_serialize_managers(self):
-        self.assertSerializedEqual(models.Manager())
-        self.assertSerializedResultEqual(
-            FoodQuerySet.as_manager(),
-            ('migrations.models.FoodQuerySet.as_manager()', {'import migrations.models'})
-        )
-        self.assertSerializedEqual(FoodManager('a', 'b'))
-        self.assertSerializedEqual(FoodManager('x', 'y', c=3, d=4))
-
-    def test_serialize_frozensets(self):
-        self.assertSerializedEqual(frozenset())
-        self.assertSerializedEqual(frozenset("let it go"))
-
-    def test_serialize_set(self):
-        self.assertSerializedEqual(set())
-        self.assertSerializedResultEqual(set(), ('set()', set()))
-        self.assertSerializedEqual({'a'})
-        self.assertSerializedResultEqual({'a'}, ("{'a'}", set()))
-
-    def test_serialize_timedelta(self):
-        self.assertSerializedEqual(datetime.timedelta())
-        self.assertSerializedEqual(datetime.timedelta(minutes=42))
-
-    def test_serialize_functools_partial(self):
-        value = functools.partial(datetime.timedelta, 1, seconds=2)
-        result = self.serialize_round_trip(value)
-        self.assertEqual(result.func, value.func)
-        self.assertEqual(result.args, value.args)
-        self.assertEqual(result.keywords, value.keywords)
-
-    def test_serialize_functools_partialmethod(self):
-        value = functools.partialmethod(datetime.timedelta, 1, seconds=2)
-        result = self.serialize_round_trip(value)
-        self.assertIsInstance(result, functools.partialmethod)
-        self.assertEqual(result.func, value.func)
-        self.assertEqual(result.args, value.args)
-        self.assertEqual(result.keywords, value.keywords)
-
-    def test_serialize_type_none(self):
-        self.assertSerializedEqual(type(None))
-
-    def test_simple_migration(self):
-        """
-        Tests serializing a simple migration.
-        """
-        fields = {
-            'charfield': models.DateTimeField(default=datetime.datetime.utcnow),
-            'datetimefield': models.DateTimeField(default=datetime.datetime.utcnow),
-        }
-
-        options = {
-            'verbose_name': 'My model',
-            'verbose_name_plural': 'My models',
-        }
-
-        migration = type("Migration", (migrations.Migration,), {
-            "operations": [
-                migrations.CreateModel("MyModel", tuple(fields.items()), options, (models.Model,)),
-                migrations.CreateModel("MyModel2", tuple(fields.items()), bases=(models.Model,)),
-                migrations.CreateModel(
-                    name="MyModel3", fields=tuple(fields.items()), options=options, bases=(models.Model,)
-                ),
-                migrations.DeleteModel("MyModel"),
-                migrations.AddField("OtherModel", "datetimefield", fields["datetimefield"]),
-            ],
-            "dependencies": [("testapp", "some_other_one")],
-        })
-        writer = MigrationWriter(migration)
-        output = writer.as_string()
-        # We don't test the output formatting - that's too fragile.
-        # Just make sure it runs for now, and that things look alright.
-        result = self.safe_exec(output)
-        self.assertIn("Migration", result)
-
-    def test_migration_path(self):
-        test_apps = [
-            'migrations.migrations_test_apps.normal',
-            'migrations.migrations_test_apps.with_package_model',
-            'migrations.migrations_test_apps.without_init_file',
-        ]
-
-        base_dir = os.path.dirname(os.path.dirname(__file__))
-
-        for app in test_apps:
-            with self.modify_settings(INSTALLED_APPS={'append': app}):
-                migration = migrations.Migration('0001_initial', app.split('.')[-1])
-                expected_path = os.path.join(base_dir, *(app.split('.') + ['migrations', '0001_initial.py']))
-                writer = MigrationWriter(migration)
-                self.assertEqual(writer.path, expected_path)
-
-    def test_custom_operation(self):
-        migration = type("Migration", (migrations.Migration,), {
-            "operations": [
-                custom_migration_operations.operations.TestOperation(),
-                custom_migration_operations.operations.CreateModel(),
-                migrations.CreateModel("MyModel", (), {}, (models.Model,)),
-                custom_migration_operations.more_operations.TestOperation()
-            ],
-            "dependencies": []
-        })
-        writer = MigrationWriter(migration)
-        output = writer.as_string()
-        result = self.safe_exec(output)
-        self.assertIn("custom_migration_operations", result)
-        self.assertNotEqual(
-            result['custom_migration_operations'].operations.TestOperation,
-            result['custom_migration_operations'].more_operations.TestOperation
-        )
-
-    def test_sorted_imports(self):
-        """
-        #24155 - Tests ordering of imports.
-        """
-        migration = type("Migration", (migrations.Migration,), {
-            "operations": [
-                migrations.AddField("mymodel", "myfield", models.DateTimeField(
-                    default=datetime.datetime(2012, 1, 1, 1, 1, tzinfo=utc),
-                )),
-            ]
-        })
-        writer = MigrationWriter(migration)
-        output = writer.as_string()
-        self.assertIn(
-            "import datetime\n"
-            "from django.db import migrations, models\n"
-            "from django.utils.timezone import utc\n",
-            output
-        )
-
-    def test_migration_file_header_comments(self):
-        """
-        Test comments at top of file.
-        """
-        migration = type("Migration", (migrations.Migration,), {
-            "operations": []
-        })
-        dt = datetime.datetime(2015, 7, 31, 4, 40, 0, 0, tzinfo=utc)
-        with mock.patch('django.db.migrations.writer.now', lambda: dt):
-            for include_header in (True, False):
-                with self.subTest(include_header=include_header):
-                    writer = MigrationWriter(migration, include_header)
-                    output = writer.as_string()
-
-                    self.assertEqual(
-                        include_header,
-                        output.startswith(
-                            "# Generated by Django %s on 2015-07-31 04:40\n\n" % get_version()
-                        )
-                    )
-                    if not include_header:
-                        # Make sure the output starts with something that's not
-                        # a comment or indentation or blank line
-                        self.assertRegex(output.splitlines(keepends=True)[0], r"^[^#\s]+")
-
-    def test_models_import_omitted(self):
-        """
-        django.db.models shouldn't be imported if unused.
-        """
-        migration = type("Migration", (migrations.Migration,), {
-            "operations": [
-                migrations.AlterModelOptions(
-                    name='model',
-                    options={'verbose_name': 'model', 'verbose_name_plural': 'models'},
-                ),
-            ]
-        })
-        writer = MigrationWriter(migration)
-        output = writer.as_string()
-        self.assertIn("from django.db import migrations\n", output)
-
-    def test_deconstruct_class_arguments(self):
-        # Yes, it doesn't make sense to use a class as a default for a
-        # CharField. It does make sense for custom fields though, for example
-        # an enumfield that takes the enum class as an argument.
-        string = MigrationWriter.serialize(models.CharField(default=DeconstructibleInstances))[0]
-        self.assertEqual(string, "models.CharField(default=migrations.test_writer.DeconstructibleInstances)")
-
-    def test_register_serializer(self):
-        class ComplexSerializer(BaseSerializer):
-            def serialize(self):
-                return 'complex(%r)' % self.value, {}
-
-        MigrationWriter.register_serializer(complex, ComplexSerializer)
-        self.assertSerializedEqual(complex(1, 2))
-        MigrationWriter.unregister_serializer(complex)
-        with self.assertRaisesMessage(ValueError, 'Cannot serialize: (1+2j)'):
-            self.assertSerializedEqual(complex(1, 2))
-
-    def test_register_non_serializer(self):
-        with self.assertRaisesMessage(ValueError, "'TestModel1' must inherit from 'BaseSerializer'."):
-            MigrationWriter.register_serializer(complex, TestModel1)
diff --git a/tests/queries/tests.py b/tests/queries/tests.py
index cd31453d08..79f014a341 100644
--- a/tests/queries/tests.py
+++ b/tests/queries/tests.py
@@ -3875,6 +3875,26 @@ class Ticket23605Tests(TestCase):
         qs2 = Ticket23605A.objects.exclude(complex_q)
         self.assertSequenceEqual(qs2, [a2])
 
+    def test_expression_wrapper_constant_group_by(self):
+        # Test that wrapping a constant Value in ExpressionWrapper doesn't
+        # incorrectly add it to the GROUP BY clause.
+        from django.db.models import ExpressionWrapper, IntegerField, Sum, Value
+        qs = Author.objects.annotate(
+            const=ExpressionWrapper(Value(3), output_field=IntegerField())
+        ).values('const', 'name').annotate(total_num=Sum('num'))
+        # Check the generated SQL's GROUP BY clause
+        sql = str(qs.query).upper()
+        group_by_index = sql.find('GROUP BY')
+        self.assertGreater(group_by_index, 0, "GROUP BY clause not found in query")
+        group_by_clause = sql[group_by_index:]
+        # The constant '3' or its alias 'CONST' should NOT be in the GROUP BY
+        self.assertNotIn('CONST', group_by_clause)
+        self.assertNotIn(' 3', group_by_clause) # Check for the literal value too
+        # The actual column 'name' should be in the GROUP BY
+        self.assertIn(connection.ops.quote_name('name'.upper()), group_by_clause)
+        # Ensure the query executes
+        list(qs)
+
 
 class TestTicket24279(TestCase):
     def test_ticket_24278(self):
