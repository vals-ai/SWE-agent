diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index a44adfc760..a8323577f5 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -420,17 +420,25 @@ class SQLCompiler:
                 if compiler.get_order_by():
                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')
         parts = ()
-        for compiler in compilers:
+        for original_compiler in compilers:
             try:
                 # If the columns list is limited, then all combined queries
                 # must have the same columns list. Set the selects defined on
                 # the query on all combined queries, if not already set.
-                if not compiler.query.values_select and self.query.values_select:
-                    compiler.query.set_values((
+                compiler = original_compiler # Start with the original compiler
+                query = compiler.query # Get the inner query
+                # If the columns list is limited, then all combined queries
+                # must have the same columns list. Clone the query and set the
+                # selects defined on the outer query if not already set on the inner query.
+                if not query.values_select and self.query.values_select:
+                    query = query.clone() # Clone the inner query
+                    query.set_values(( # Mutate the CLONE
                         *self.query.extra_select,
                         *self.query.values_select,
                         *self.query.annotation_select,
                     ))
+                    # Create a new compiler for the cloned query
+                    compiler = query.get_compiler(self.using, self.connection)
                 part_sql, part_args = compiler.as_sql()
                 if compiler.query.combinator:
                     # Wrap in a subquery if wrapping in parentheses isn't
diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py
index 3902db59e2..169309dda4 100644
--- a/tests/queries/test_qs_combinators.py
+++ b/tests/queries/test_qs_combinators.py
@@ -97,6 +97,7 @@ class QuerySetSetOperationTests(TestCase):
         self.assertEqual(len(qs3.union(qs1)), 10)
         self.assertEqual(len(qs2.union(qs1, qs1, qs1)), 10)
         self.assertEqual(len(qs2.union(qs1, qs1, all=True)), 20)
+        self.assertEqual(len(qs3.union(qs3)), 0)
         self.assertEqual(len(qs2.union(qs2)), 0)
         self.assertEqual(len(qs3.union(qs3)), 0)
 
@@ -124,6 +125,18 @@ class QuerySetSetOperationTests(TestCase):
         reserved_name = qs1.union(qs1).values_list('name', 'order', 'id').get()
         self.assertEqual(reserved_name[:2], ('a', 2))
 
+    def test_values_list_on_combined_queryset_evaluated_multiple_times(self):
+        # Tests that a combined queryset can be evaluated multiple times with
+        # different values/values_list arguments.
+        ReservedName.objects.create(name='a', order=2)
+        qs1 = ReservedName.objects.all()
+        combined_qs = qs1.union(qs1)
+        # First evaluation selects ('name', 'order').
+        self.assertEqual(combined_qs.values_list('name', 'order').get(), ('a', 2))
+        # Second evaluation selects ('order',). It should return (2,) but
+        # fails before the fix (#33271).
+        self.assertEqual(combined_qs.values_list('order').get(), (2,))
+
     def test_union_with_two_annotated_values_list(self):
         qs1 = Number.objects.filter(num=1).annotate(
             count=Value(0, IntegerField()),
