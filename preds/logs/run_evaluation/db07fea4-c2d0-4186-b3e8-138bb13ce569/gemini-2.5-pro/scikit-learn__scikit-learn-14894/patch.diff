diff --git a/reproduce_bug.py b/reproduce_bug.py
new file mode 100644
index 000000000..981bfc4a3
--- /dev/null
+++ b/reproduce_bug.py
@@ -0,0 +1,26 @@
+
+import numpy as np
+import scipy
+import sklearn
+from sklearn.svm import SVR
+x_train = np.array([[0, 1, 0, 0],
+[0, 0, 0, 1],
+[0, 0, 1, 0],
+[0, 0, 0, 1]])
+y_train = np.array([0.04, 0.04, 0.10, 0.16])
+model = SVR(C=316.227766017, cache_size=200, coef0=0.0, degree=3, epsilon=0.1,
+      gamma=1.0, kernel='linear', max_iter=15000,
+      shrinking=True, tol=0.001, verbose=False)
+# dense x_train has no error
+print("Fitting with dense data...")
+model.fit(x_train, y_train)
+print("Dense fit successful.")
+
+# convert to sparse
+print("Converting to sparse...")
+xtrain= scipy.sparse.csr_matrix(x_train)
+print("Fitting with sparse data...")
+model.fit(xtrain, y_train)
+print("Sparse fit successful.")
+
+print("Script completed successfully, no errors.") # Added success message
\ No newline at end of file
diff --git a/sklearn/svm/base.py b/sklearn/svm/base.py
index 64cebe837..265942ee3 100644
--- a/sklearn/svm/base.py
+++ b/sklearn/svm/base.py
@@ -286,12 +286,19 @@ class BaseLibSVM(BaseEstimator, metaclass=ABCMeta):
             n_class = 1
         n_SV = self.support_vectors_.shape[0]
 
-        dual_coef_indices = np.tile(np.arange(n_SV), n_class)
-        dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1,
-                                     dual_coef_indices.size / n_class)
-        self.dual_coef_ = sp.csr_matrix(
-            (dual_coef_data, dual_coef_indices, dual_coef_indptr),
-            (n_class, n_SV))
+        if n_SV == 0:
+            # dual_coef_data should be empty in this case anyway
+            # Use the dtype of dual_coef_data if available, else default float
+            dtype = dual_coef_data.dtype if hasattr(dual_coef_data, 'dtype') else np.float64
+            self.dual_coef_ = sp.csr_matrix((n_class, 0), dtype=dtype)
+        else:
+            dual_coef_indices = np.tile(np.arange(n_SV), n_class)
+            # step should be n_SV
+            step = n_SV
+            dual_coef_indptr = np.arange(0, dual_coef_indices.size + 1, step)
+            self.dual_coef_ = sp.csr_matrix(
+                (dual_coef_data, dual_coef_indices, dual_coef_indptr),
+                (n_class, n_SV))
 
     def predict(self, X):
         """Perform regression on samples in X.
diff --git a/sklearn/svm/tests/test_sparse.py b/sklearn/svm/tests/test_sparse.py
index 7cf6e8af2..4533cd4a4 100644
--- a/sklearn/svm/tests/test_sparse.py
+++ b/sklearn/svm/tests/test_sparse.py
@@ -352,6 +352,32 @@ def test_timeout():
     assert_warns(ConvergenceWarning, sp.fit, X_sp, Y)
 
 
+def test_sparse_svr_no_support_vectors():
+    # Test SVR with sparse data resulting in zero support vectors.
+    # This specifically tests the fix for the ZeroDivisionError.
+    # See https://github.com/scikit-learn/scikit-learn/issues/14894
+    x_train = np.array([[0, 1, 0, 0],
+                        [0, 0, 0, 1],
+                        [0, 0, 1, 0],
+                        [0, 0, 0, 1]])
+    y_train = np.array([0.04, 0.04, 0.10, 0.16])
+    xtrain_sparse = sparse.csr_matrix(x_train)
+
+    # Parameters from the original issue
+    model = svm.SVR(C=316.227766017, cache_size=200, coef0=0.0, degree=3,
+                    epsilon=0.1, gamma=1.0, kernel='linear', max_iter=15000,
+                    shrinking=True, tol=0.001, verbose=False)
+
+    # Fit should complete without ZeroDivisionError
+    model.fit(xtrain_sparse, y_train)
+
+    # Check that support vectors and dual coefficients are empty as expected
+    assert model.support_vectors_.shape[0] == 0
+    # For SVR, dual_coef_ is (1, n_SV)
+    assert model.dual_coef_.shape == (1, 0)
+    assert isinstance(model.dual_coef_, sparse.csr_matrix)
+
+
 def test_consistent_proba():
     a = svm.SVC(probability=True, max_iter=1, random_state=0)
     with ignore_warnings(category=ConvergenceWarning):
