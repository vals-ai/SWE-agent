diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index 08d7faf194..ca0642e3ef 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -2031,6 +2031,10 @@ class Query(BaseExpression):
         self.select_related = False
         self.clear_deferred_loading()
         self.clear_select_fields()
+        if self.combinator:
+            # Ordering depends on the selected columns for combined
+            # queries, so it must be cleared when calling values().
+            self.clear_ordering(True)
 
         if self.group_by is True:
             self.add_fields((f.attname for f in self.model._meta.concrete_fields), False)
diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py
index 227972e8c4..21e47a607f 100644
--- a/tests/queries/test_qs_combinators.py
+++ b/tests/queries/test_qs_combinators.py
@@ -227,4 +227,21 @@ class QuerySetSetOperationTests(TestCase):
     def test_qs_with_subcompound_qs(self):
         qs1 = Number.objects.all()
         qs2 = Number.objects.intersection(Number.objects.filter(num__gt=1))
+
+    def test_union_order_by_reused_queryset(self):
+        # Test that reusing a queryset after ordering a combined queryset
+        # doesn't break.
+        qs1 = Number.objects.filter(num__in=[1, 2])
+        qs2 = Number.objects.filter(num__in=[5, 6])
+        combined_qs = qs1.union(qs2).order_by('num')
+
+        # Evaluate the combined queryset
+        list(combined_qs)
+
+        # This caused the error in the original issue report.
+        # Re-evaluating the queryset after a subsequent operation.
+        list(combined_qs.values_list('pk', flat=True))
+
+        # Check if the original queryset is still usable
+        self.assertNumbersEqual(combined_qs, [1, 2, 5, 6])
         self.assertEqual(qs1.difference(qs2).count(), 2)
