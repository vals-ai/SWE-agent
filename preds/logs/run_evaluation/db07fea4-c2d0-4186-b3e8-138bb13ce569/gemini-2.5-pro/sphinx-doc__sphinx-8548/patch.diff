diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index ddfd2b365..f9ef0f55a 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -594,21 +594,61 @@ class Documenter:
 
         # set sourcename and add content from attribute documentation
         sourcename = self.get_sourcename()
+        docstrings = None
         if self.analyzer:
             attr_docs = self.analyzer.find_attr_docs()
             if self.objpath:
                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
                 if key in attr_docs:
-                    no_docstring = True
-                    # make a copy of docstring for attributes to avoid cache
-                    # the change of autodoc-process-docstring event.
+                    # Found in current class's analyzer
                     docstrings = [list(attr_docs[key])]
+                else:
+                    # Try finding attribute docstring in base classes
+                    # Check if the parent is a ClassDocumenter to ensure we are documenting a class member
+                    if hasattr(self.parent, 'object') and hasattr(self.parent.object, '__mro__'): # Use simpler check
+                        # Get MRO, excluding the class itself
+                        try:
+                            mro = inspect.getmro(self.parent.object)[1:]
+                        except AttributeError:
+                            mro = [] # Handle cases where MRO is not available
+
+                        for base_cls in mro:
+                            base_modname = getattr(base_cls, '__module__', None)
+                            if not base_modname:
+                                continue
+                            try:
+                                base_analyzer = ModuleAnalyzer.for_module(base_modname)
+                                # Ensure find_attr_docs is called; it might not have been if the module wasn't parsed yet
+                                base_analyzer.find_attr_docs()
+                                base_attr_docs = base_analyzer.attr_docs # Access the cached result
+
+                                # Use base_cls.__qualname__ if available, fallback to __name__
+                                base_cls_name = getattr(base_cls, '__qualname__', base_cls.__name__)
+                                base_key = (base_cls_name, self.objpath[-1])
+
+                                if base_attr_docs and base_key in base_attr_docs: # Check base_attr_docs is not None
+                                    docstrings = [list(base_attr_docs[base_key])]
+                                    # Add dependency on the base class's file
+                                    if base_analyzer.srcname:
+                                        self.directive.filename_set.add(base_analyzer.srcname)
+                                    break  # Found in this base class
+                            except PycodeError:
+                                # Silently ignore if analyzer fails for a base class
+                                continue
+                            except Exception as e:
+                                # Log other potential errors during base class analysis
+                                logger.warning(f"Error analyzing base class {base_cls} for attribute docs: {e}", type='autodoc')
+                                continue
+
+        if docstrings is not None:
+            no_docstring = True # Indicate we found attribute docs
+            # make a copy of docstring for attributes to avoid cache
+            # the change of autodoc-process-docstring event.
+            for i, line in enumerate(self.process_doc(docstrings)):
+                self.add_line(line, sourcename, i)
 
-                    for i, line in enumerate(self.process_doc(docstrings)):
-                        self.add_line(line, sourcename, i)
-
-        # add content from docstrings
-        if not no_docstring:
+        # add content from __doc__
+        if not no_docstring: # Only add __doc__ if attribute docs weren't found
             docstrings = self.get_doc()
             if not docstrings:
                 # append at least a dummy docstring, so that the event
