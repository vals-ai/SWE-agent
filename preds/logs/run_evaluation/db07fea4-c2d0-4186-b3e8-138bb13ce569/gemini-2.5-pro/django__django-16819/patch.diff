diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py
index 967a91fdc8..6448695f0d 100644
--- a/django/db/migrations/operations/models.py
+++ b/django/db/migrations/operations/models.py
@@ -861,6 +861,20 @@ class AddIndex(IndexOperation):
     def migration_name_fragment(self):
         return "%s_%s" % (self.model_name_lower, self.index.name.lower())
 
+    def reduce(self, operation, app_label):
+        # Check for cancellation
+        if isinstance(operation, RemoveIndex) and self.model_name_lower == operation.model_name_lower and self.index.name == operation.name:
+            return []  # Cancel each other out.
+        # Check if we can move AddIndex past the operation
+        # Note: Removed AlterIndex from check due to definition order
+        if isinstance(operation, (AddField, AlterField, RemoveField, RenameField, AlterModelOptions, AlterOrderWithRespectTo, AlterUniqueTogether, RenameModel, AlterModelTable, AlterModelManagers)) and self.model_name_lower == operation.model_name_lower:
+            # If the operation affects the same model, AddIndex can usually be moved after it.
+            # This isn't strictly true for all cases (e.g., RenameField might affect index),
+            # but it's a good starting point for optimization.
+            # A more robust solution would check if the operation fields conflict with index fields.
+            return True # Allow optimizer to reorder
+        return super().reduce(operation, app_label)
+
 
 class RemoveIndex(IndexOperation):
     """Remove an index from a model."""
@@ -904,6 +918,20 @@ class RemoveIndex(IndexOperation):
     def migration_name_fragment(self):
         return "remove_%s_%s" % (self.model_name_lower, self.name.lower())
 
+    def reduce(self, operation, app_label):
+        # Check for cancellation
+        if isinstance(operation, AddIndex) and self.model_name_lower == operation.model_name_lower and self.name == operation.index.name:
+            # TODO: Detect if the index definition is different and
+            # replace with AlterIndex instead. For now, just cancel out.
+            return []  # Cancel each other out.
+        # Check if we can move RemoveIndex past the operation
+        # Note: Removed AlterIndex from check due to definition order
+        if isinstance(operation, (AddField, AlterField, RemoveField, RenameField, AlterModelOptions, AlterOrderWithRespectTo, AlterUniqueTogether, RenameModel, AlterModelTable, AlterModelManagers)) and self.model_name_lower == operation.model_name_lower:
+            # Similar logic as AddIndex.reduce
+            return True # Allow optimizer to reorder
+        # TODO: Detect AlterIndex and cancel out?
+        return super().reduce(operation, app_label)
+
 
 class RenameIndex(IndexOperation):
     """Rename an index."""
diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py
index 8cd4c67fbd..6d74cfb096 100644
--- a/tests/migrations/test_optimizer.py
+++ b/tests/migrations/test_optimizer.py
@@ -1121,6 +1121,77 @@ class OptimizerTests(SimpleTestCase):
             ],
         )
 
+
+    def test_optimize_add_remove_index(self):
+        """
+        Test that AddIndex and RemoveIndex cancel each other out.
+        """
+        # Add followed by Remove
+        self.assertOptimizesTo(
+            [
+                migrations.AddIndex(
+                    "Pony", models.Index(fields=["weight"], name="pony_weight_idx")
+                ),
+                migrations.RemoveIndex("Pony", "pony_weight_idx"),
+            ],
+            [],
+        )
+        # Remove followed by Add
+        self.assertOptimizesTo(
+            [
+                migrations.RemoveIndex("Pony", "pony_weight_idx"),
+                migrations.AddIndex(
+                    "Pony", models.Index(fields=["weight"], name="pony_weight_idx")
+                ),
+            ],
+            [],
+        )
+        # Add/Remove separated by an unrelated operation
+        self.assertOptimizesTo(
+            [
+                migrations.AddIndex(
+                    "Pony", models.Index(fields=["weight"], name="pony_weight_idx")
+                ),
+                migrations.AddField("Pony", "height", models.IntegerField(default=10)),
+                migrations.RemoveIndex("Pony", "pony_weight_idx"),
+            ],
+            [
+                migrations.AddField("Pony", "height", models.IntegerField(default=10)),
+            ],
+        )
+        # Remove/Add separated by an unrelated operation
+        self.assertOptimizesTo(
+            [
+                migrations.RemoveIndex("Pony", "pony_weight_idx"),
+                migrations.AddField("Pony", "height", models.IntegerField(default=10)),
+                migrations.AddIndex(
+                    "Pony", models.Index(fields=["weight"], name="pony_weight_idx")
+                ),
+            ],
+            [
+                migrations.AddField("Pony", "height", models.IntegerField(default=10)),
+            ],
+        )
+        # Add/Remove for different models - should not optimize
+        self.assertDoesNotOptimize(
+            [
+                migrations.AddIndex(
+                    "Pony", models.Index(fields=["weight"], name="pony_weight_idx")
+                ),
+                migrations.RemoveIndex("Horse", "pony_weight_idx"),
+            ],
+        )
+        # Add/Remove for different index names - should not optimize
+        self.assertDoesNotOptimize(
+            [
+                migrations.AddIndex(
+                    "Pony", models.Index(fields=["weight"], name="pony_weight_idx")
+                ),
+                migrations.RemoveIndex("Pony", "pony_other_idx"),
+            ],
+        )
+
+
     def test_rename_index(self):
         self.assertOptimizesTo(
             [
