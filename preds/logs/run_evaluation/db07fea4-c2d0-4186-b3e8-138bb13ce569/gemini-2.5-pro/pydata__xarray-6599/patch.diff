diff --git a/xarray/core/computation.py b/xarray/core/computation.py
index 823cbe02..8ed60687 100644
--- a/xarray/core/computation.py
+++ b/xarray/core/computation.py
@@ -1891,6 +1891,9 @@ def polyval(
     --------
     xarray.DataArray.polyfit
     numpy.polynomial.polynomial.polyval
+
+
+
     """
 
     if degree_dim not in coeffs._indexes:
@@ -1905,13 +1908,42 @@ def polyval(
     coeffs = coeffs.reindex(
         {degree_dim: np.arange(max_deg + 1)}, fill_value=0, copy=False
     )
-    coord = _ensure_numeric(coord)  # type: ignore # https://github.com/python/mypy/issues/1533 ?
+    # Extract the coordinate used for evaluation
+    if type(coord).__name__ == "DataArray":
+        # Use the coordinate with the same name as the DataArray
+        # Ensure it exists and is a dimension coordinate
+        if coord.name is None or coord.name not in coord.coords or coord.name not in coord.dims:
+            raise ValueError(
+                "Cannot determine the coordinate for polynomial evaluation "
+                "from the input DataArray. Ensure it has a name and a "
+                "corresponding dimension coordinate."
+            )
+        eval_coord = coord[coord.name]
+    elif type(coord).__name__ == "Dataset":
+        # If coord is a Dataset, require it to have exactly one dimension,
+        # which is used as the evaluation coordinate.
+        if len(coord.dims) != 1:
+            raise ValueError(
+                "If 'coord' is a Dataset, it must have exactly one dimension "
+                "to be used for polynomial evaluation."
+            )
+        dim_name = next(iter(coord.dims))
+        if dim_name not in coord.coords:
+            raise ValueError(
+                f"Dataset 'coord' must have a coordinate variable for its dimension '{dim_name}'."
+            )
+        eval_coord = coord[dim_name]
+    else:
+        # Should be unreachable due to type hints, but good practice
+        raise TypeError("Input 'coord' must be a DataArray or Dataset.")
+
+    numeric_eval_coord = _ensure_numeric(eval_coord)
 
     # using Horner's method
     # https://en.wikipedia.org/wiki/Horner%27s_method
-    res = coeffs.isel({degree_dim: max_deg}, drop=True) + zeros_like(coord)
+    res = coeffs.isel({degree_dim: max_deg}, drop=True) + zeros_like(coeffs.isel({degree_dim: max_deg}, drop=True))
     for deg in range(max_deg - 1, -1, -1):
-        res *= coord
+        res = res * numeric_eval_coord
         res += coeffs.isel({degree_dim: deg}, drop=True)
 
     return res
@@ -1933,7 +1965,16 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:
     from .dataset import Dataset
 
     def to_floatable(x: DataArray) -> DataArray:
-        if x.dtype.kind in "mM":
+        if x.dtype.kind == "m":  # timedelta64
+            # Convert timedelta64 to numeric representation (nanoseconds)
+            return x.copy(
+                data=datetime_to_numeric(
+                    x.data,
+                    datetime_unit="ns",
+                ),
+            )
+        elif x.dtype.kind == "M":  # datetime64
+            # Convert datetime64 to numeric representation (nanoseconds since 1970-01-01)
             return x.copy(
                 data=datetime_to_numeric(
                     x.data,
