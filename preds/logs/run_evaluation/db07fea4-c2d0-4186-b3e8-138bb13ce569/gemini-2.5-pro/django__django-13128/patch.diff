diff --git a/django/db/backends/sqlite3/base.py b/django/db/backends/sqlite3/base.py
index 31e8a55a43..9b392d1893 100644
--- a/django/db/backends/sqlite3/base.py
+++ b/django/db/backends/sqlite3/base.py
@@ -3,6 +3,7 @@ SQLite backend for the sqlite3 module in the standard library.
 """
 import datetime
 import decimal
+import sqlite3
 import functools
 import hashlib
 import json
@@ -77,6 +78,7 @@ Database.register_converter("timestamp", decoder(parse_datetime))
 Database.register_converter("TIMESTAMP", decoder(parse_datetime))
 
 Database.register_adapter(decimal.Decimal, str)
+Database.register_adapter(datetime.timedelta, lambda td: duration_microseconds(td))
 
 
 class DatabaseWrapper(BaseDatabaseWrapper):
@@ -559,9 +561,8 @@ def _sqlite_format_dtdelta(conn, lhs, rhs):
             out = real_lhs - real_rhs
     except (ValueError, TypeError):
         return None
-    # typecast_timestamp returns a date or a datetime without timezone.
-    # It will be formatted as "%Y-%m-%d" or "%Y-%m-%d %H:%M:%S[.%f]"
-    return str(out)
+    # Convert the resulting timedelta back to microseconds for SQLite.
+    return duration_microseconds(out)
 
 
 @none_guard
diff --git a/django/db/backends/sqlite3/operations.py b/django/db/backends/sqlite3/operations.py
index 1f77b3109f..2d50b0efbc 100644
--- a/django/db/backends/sqlite3/operations.py
+++ b/django/db/backends/sqlite3/operations.py
@@ -3,6 +3,7 @@ import decimal
 import uuid
 from functools import lru_cache
 from itertools import chain
+from django.utils.duration import duration_microseconds
 
 from django.conf import settings
 from django.core.exceptions import FieldError
@@ -271,6 +272,8 @@ class DatabaseOperations(BaseDatabaseOperations):
             converters.append(self.convert_uuidfield_value)
         elif internal_type in ('NullBooleanField', 'BooleanField'):
             converters.append(self.convert_booleanfield_value)
+        elif internal_type == 'DurationField':
+            converters.append(self.convert_durationfield_value)
         return converters
 
     def convert_datetimefield_value(self, value, expression, connection):
@@ -317,6 +320,29 @@ class DatabaseOperations(BaseDatabaseOperations):
     def convert_booleanfield_value(self, value, expression, connection):
         return bool(value) if value in (1, 0) else value
 
+    def convert_durationfield_value(self, value, expression, connection):
+        if value is not None:
+            if isinstance(value, datetime.timedelta):
+                # Value is already a timedelta, return it directly.
+                return value
+            # Otherwise, value is microseconds from SQLite subtraction or
+            # a string from django_format_dtdelta. Try converting to int.
+            try:
+                value = int(value)
+            except (ValueError, TypeError):
+                # Should not happen if the custom functions return correctly.
+                return None
+            return datetime.timedelta(microseconds=value)
+        return value
+
+    def adapt_durationfield_value(self, value):
+        # SQLite doesn't support timedelta objects directly. For parameter
+        # binding, return the value unchanged if it's not a timedelta.
+        # Otherwise, convert timedelta to integer microseconds.
+        if not isinstance(value, datetime.timedelta):
+            return value
+        return duration_microseconds(value)
+
     def bulk_insert_sql(self, fields, placeholder_rows):
         return " UNION ALL ".join(
             "SELECT %s" % ", ".join(row)
diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
index d913658291..0e9ad63ca0 100644
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -309,6 +309,23 @@ class BaseExpression:
                             source.__class__.__name__,
                         )
                     )
+            # Check for subtraction of two identical date/time types.
+            try:
+                lhs_field = self.lhs.output_field
+                rhs_field = self.rhs.output_field
+            except FieldError:
+                # If either side fails to resolve, we can't determine the output.
+                pass
+            else:
+                if (
+                    self.connector == self.SUB and
+                    isinstance(lhs_field, (fields.DateField, fields.TimeField)) and
+                    lhs_field.__class__ == rhs_field.__class__
+                ):
+                    return fields.DurationField()
+
+            # Fall back to the default behavior if the special case doesn't apply
+            # or if field resolution failed.
             return output_field
 
     @staticmethod
@@ -478,6 +495,10 @@ class CombinedExpression(SQLiteNumericMixin, Expression):
         c.is_summary = summarize
         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
+        # Call _resolve_output_field to set the output_field attribute.
+        # This is important for CombinedExpressions created by F() objects where
+        # the output_field is not explicitly set.
+        c._resolve_output_field()
         return c
 
 
diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 28374272f4..0f9bc140c8 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -1561,11 +1561,12 @@ class DurationField(Field):
         )
 
     def get_db_prep_value(self, value, connection, prepared=False):
-        if connection.features.has_native_duration_field:
-            return value
+        value = super().get_db_prep_value(value, connection, prepared)
         if value is None:
             return None
-        return duration_microseconds(value)
+        if not prepared:
+            value = self.to_python(value)
+        return connection.ops.adapt_durationfield_value(value)
 
     def get_db_converters(self, connection):
         converters = []
diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py
index 72f95f0194..4b52eb5e1a 100644
--- a/tests/expressions/tests.py
+++ b/tests/expressions/tests.py
@@ -1670,6 +1670,36 @@ class FTimeDeltaTests(TestCase):
         e0 = Experiment.objects.get(name='e0')
         self.assertEqual(e0.start, expected_start)
 
+class TemporalSubtractionTests(TestCase):
+    @classmethod
+    def setUpTestData(cls):
+        cls.e1 = Experiment.objects.create(
+            name='e1',
+            start=datetime.datetime(2023, 10, 26, 12, 0, 0),
+            end=datetime.datetime(2023, 10, 26, 13, 30, 0),
+            assigned=datetime.date(2023, 10, 26),
+            completed=datetime.date(2023, 10, 27),
+            estimated_time=datetime.timedelta(hours=1),
+        )
+
+    @skipUnlessDBFeature('supports_temporal_subtraction')
+    def test_datetime_subtraction_without_wrapper(self):
+        # This test reproduces the issue described in the ticket.
+        # Subtraction of two DateTimeFields should result in a DurationField
+        # without needing an explicit ExpressionWrapper.
+        queryset = Experiment.objects.annotate(
+            delta=F('end') - F('start')
+        )
+        self.assertEqual(queryset.first().delta, datetime.timedelta(hours=1, minutes=30))
+
+    @skipUnlessDBFeature('supports_temporal_subtraction')
+    def test_datetime_subtraction_with_timedelta_without_wrapper(self):
+        # Verify that adding/subtracting a timedelta also works correctly.
+        queryset = Experiment.objects.annotate(
+            delta=F('end') - F('start') + Value(datetime.timedelta(minutes=15))
+        )
+        self.assertEqual(queryset.first().delta, datetime.timedelta(hours=1, minutes=45))
+
 
 class ValueTests(TestCase):
     def test_update_TimeField_using_Value(self):
