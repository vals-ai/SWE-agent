diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index f8e4be999..3dc4312d8 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -447,11 +447,16 @@ class Documenter:
 
         # one signature per line, indented by column
         prefix = '.. %s:%s:: ' % (domain, directive)
+        first_line_prefix = '%s%s' % (prefix, name)
+        # Padding should align subsequent signatures under the first one
+        padding = ' ' * len(prefix) # <-- Pad based on directive prefix only
         for i, sig_line in enumerate(sig.split("\n")):
-            self.add_line('%s%s%s' % (prefix, name, sig_line),
-                          sourcename)
             if i == 0:
-                prefix = " " * len(prefix)
+                # First line includes directive prefix and name
+                self.add_line('%s%s' % (first_line_prefix, sig_line), sourcename)
+            else:
+                # Subsequent lines are padded (by prefix length) and include the name
+                self.add_line('%s%s%s' % (padding, name, sig_line), sourcename)
 
         if self.options.noindex:
             self.add_line('   :noindex:', sourcename)
@@ -825,11 +830,22 @@ class Documenter:
         # reST and no starting newline is present
         self.add_line('', sourcename)
 
-        # format the object's signature, if any
-        sig = self.format_signature()
+        # format the object's signature, if any. This might populate self.docstring_signatures
+        main_sig = self.format_signature()
 
         # generate the directive header and options, if applicable
-        self.add_directive_header(sig)
+        if hasattr(self, 'docstring_signatures') and self.docstring_signatures:
+            # If docstring signatures were found, format them as "(args) [-> retann]"
+            # and pass the newline-joined string to add_directive_header.
+            sigs_to_render = []
+            for args, retann in self.docstring_signatures:
+                # args is just the content inside parens, e.g., "a: int"
+                formatted = '(' + args + ')' + ((' -> %s' % retann) if retann else '')
+                sigs_to_render.append(formatted)
+            self.add_directive_header('\n'.join(sigs_to_render))
+        else:
+            # Otherwise, use the main signature (from introspection or explicit self.args)
+            self.add_directive_header(main_sig)
         self.add_line('', sourcename)
 
         # e.g. the module directive doesn't have content
@@ -1037,39 +1053,56 @@ class DocstringSignatureMixin:
     feature of reading the signature from the docstring.
     """
 
-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
+    def _find_signature(self, encoding: str = None) -> List[Tuple[str, str]]:
         if encoding is not None:
             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
                           "deprecated." % self.__class__.__name__,
                           RemovedInSphinx40Warning, stacklevel=2)
         docstrings = self.get_doc()
         self._new_docstrings = docstrings[:]
-        result = None
-        for i, doclines in enumerate(docstrings):
-            # no lines in docstring, no match
-            if not doclines:
-                continue
-            # match first line of docstring against signature RE
-            match = py_ext_sig_re.match(doclines[0])
-            if not match:
-                continue
-            exmod, path, base, args, retann = match.groups()
-            # the base name must match ours
+        signatures = []
+        lines_stripped = 0
+        # Assume signatures are only in the first docstring block
+        if docstrings and docstrings[0]:
+            doclines = docstrings[0]
+            tab_width = self.directive.state.document.settings.tab_width  # type: ignore
             valid_names = [self.objpath[-1]]  # type: ignore
             if isinstance(self, ClassDocumenter):
                 valid_names.append('__init__')
                 if hasattr(self.object, '__mro__'):
                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)
-            if base not in valid_names:
-                continue
-            # re-prepare docstring to ignore more leading indentation
-            tab_width = self.directive.state.document.settings.tab_width  # type: ignore
-            self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[1:]),
-                                                        tabsize=tab_width)
-            result = args, retann
-            # don't look any further
-            break
-        return result
+
+            for i, line in enumerate(doclines):
+                match = py_ext_sig_re.match(line)
+                if not match:
+                    # Stop processing lines as soon as one doesn't match
+                    break
+
+                exmod, path, base, args, retann = match.groups()
+                # The base name must match ours
+                if base not in valid_names:
+                    # Stop if the name doesn't match
+                    break
+
+                # Signature matched, store it and mark line for stripping
+                signatures.append((args, retann))
+                lines_stripped += 1
+            
+            if lines_stripped > 0:
+                # Re-prepare the docstring, removing the stripped lines
+                remaining_docstring = '\n'.join(doclines[lines_stripped:])
+                self._new_docstrings[0] = prepare_docstring(remaining_docstring,
+                                                            tabsize=tab_width)
+            else:
+                # No signatures found or stripped, ensure _new_docstrings is consistent
+                # In the original code, _new_docstrings was always assigned before the loop.
+                # Here we ensure it's handled if no signatures are stripped.
+                # If docstrings[0] existed, _new_docstrings[0] should remain as is.
+                # If docstrings[0] was empty/didn't exist, _new_docstrings[0] remains unchanged (likely empty list).
+                pass # No change needed if no lines stripped
+
+        # Return the list of found signatures (args, retann tuples)
+        return signatures
 
     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
         if encoding is not None:
@@ -1082,12 +1115,17 @@ class DocstringSignatureMixin:
         return super().get_doc(None, ignore)  # type: ignore
 
     def format_signature(self, **kwargs: Any) -> str:
+        self.docstring_signatures = []  # Initialize the new attribute
         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
             # only act if a signature is not explicitly given already, and if
             # the feature is enabled
-            result = self._find_signature()
-            if result is not None:
-                self.args, self.retann = result
+            signatures = self._find_signature() # Returns List[Tuple[str, str]]
+            if signatures: # Check if the list is not empty
+                self.docstring_signatures = signatures
+                # Set self.args and self.retann from the first signature
+                # for potential use by super().format_signature or other methods
+                self.args, self.retann = signatures[0]
+            # If signatures is empty, self.args and self.retann remain None
         return super().format_signature(**kwargs)  # type: ignore
 
 
@@ -1100,12 +1138,13 @@ class DocstringStripSignatureMixin(DocstringSignatureMixin):
         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
             # only act if a signature is not explicitly given already, and if
             # the feature is enabled
-            result = self._find_signature()
-            if result is not None:
-                # Discarding _args is a only difference with
-                # DocstringSignatureMixin.format_signature.
-                # Documenter.format_signature use self.args value to format.
-                _args, self.retann = result
+            signatures = self._find_signature() # Returns List[Tuple[str, str]]
+            if signatures: # Check if the list is not empty
+                # Discarding args is the main purpose here.
+                # We only potentially keep the return annotation from the first signature.
+                # self.args remains None, so super().format_signature won't use it.
+                _args, self.retann = signatures[0]
+            # If signatures is empty, self.retann remains None
         return super().format_signature(**kwargs)
 
 
diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py
index c1799778c..919509de2 100644
--- a/tests/test_ext_autodoc.py
+++ b/tests/test_ext_autodoc.py
@@ -9,6 +9,7 @@
     :license: BSD, see LICENSE for details.
 """
 
+import textwrap
 import sys
 from unittest.mock import Mock
 from warnings import catch_warnings
@@ -288,6 +289,153 @@ def test_format_signature(app):
     assert formatsig('function', 'curried4', curried4, None, None) == \
         '(b, c=42, *d, **e)'
 
+@pytest.mark.sphinx('html', testroot='ext-autodoc')
+def test_autodoc_docstring_multiple_signatures(app):
+    """Test autodoc with multiple signatures in the docstring."""
+    # Ensure the config option is enabled
+    app.config.autodoc_docstring_signature = True
+
+    # Define a target module and function with multiple signatures
+    options = {}
+    (app.srcdir / 'test_multisig.py').write_text(textwrap.dedent("""\
+        def overloaded_func(a: int) -> int:
+            '''
+            overloaded_func(a: int) -> int
+            overloaded_func(a: str, b: float = 1.0) -> str
+
+            This is the actual docstring.
+            It should appear after the signatures.
+            '''
+            if isinstance(a, int):
+                return a + 1
+            else:
+                return a * int(b)
+    """), encoding='utf8')
+
+    # Run autodoc
+    actual = do_autodoc(app, 'function', 'test_multisig.overloaded_func', {})
+
+    # Assertions
+    expected_directive = [
+        '',
+        '.. py:function:: overloaded_func(a: int) -> int',
+        '                 overloaded_func(a: str, b: float = 1.0) -> str',
+        '   :module: test_multisig',
+        '',
+        '   This is the actual docstring.',
+        '   It should appear after the signatures.',
+        '',
+    ]
+    assert list(actual) == expected_directive
+
+    # Test with a class method as well
+    (app.srcdir / 'test_multisig_class.py').write_text(textwrap.dedent("""\
+        class MyClass:
+            def overloaded_meth(self, x: int):
+                '''
+                overloaded_meth(self, x: int)
+                overloaded_meth(self, x: str, y: bool) -> str
+
+                Method docstring.
+                '''
+                if isinstance(x, int):
+                    print(x)
+                else:
+                    return x if y else ""
+    """), encoding='utf8')
+
+    # Test using autoclass with :members: to provide context
+    actual_class_with_method = do_autodoc(app, 'class', 'test_multisig_class.MyClass', {'members': 'overloaded_meth'})
+    expected_class_output = [
+        '',
+        '.. py:class:: MyClass()',
+        '   :module: test_multisig_class',
+        '',
+        '',
+        '   .. py:method:: MyClass.overloaded_meth(self, x: int)',
+        '                   MyClass.overloaded_meth(self, x: str, y: bool) -> str',
+        '      :module: test_multisig_class',
+        '',
+        '      Method docstring.',
+        '',
+    ]
+    # Filter out potential empty lines from docstring processing differences
+    actual_filtered = [line for line in actual_class_with_method if line or line.strip()]
+    expected_filtered = [line for line in expected_class_output if line or line.strip()]
+    assert actual_filtered == expected_filtered
+
+    # Test with __init__
+    (app.srcdir / 'test_multisig_init.py').write_text(textwrap.dedent("""\
+        class MyInitClass:
+            def __init__(self, val: int):
+                '''
+                __init__(self, val: int)
+                __init__(self, name: str)
+
+                Init docstring.
+                '''
+                self.val = val
+    """), encoding='utf8')
+
+    actual_init = do_autodoc(app, 'class', 'test_multisig_init.MyInitClass', {})
+    expected_init_directive = [
+        '',
+        '.. py:class:: MyInitClass(val: int)',
+        '               MyInitClass(name: str)',
+        '   :module: test_multisig_init',
+        '',
+        '   Init docstring.',
+        '',
+    ]
+    assert list(actual_init) == expected_init_directive
+
+    # Test case where signature does not match function name (should stop parsing)
+    (app.srcdir / 'test_multisig_mismatch.py').write_text(textwrap.dedent("""\
+        def mismatch_func(a: int) -> int:
+            '''
+            mismatch_func(a: int) -> int
+            another_func(a: str) -> str  # This one should be ignored
+
+            Docstring starts here.
+            '''
+            return a + 1
+    """), encoding='utf8')
+
+    actual_mismatch = do_autodoc(app, 'function', 'test_multisig_mismatch.mismatch_func', {})
+    expected_mismatch_directive = [
+        '',
+        '.. py:function:: mismatch_func(a: int) -> int', # Only the first signature
+        '   :module: test_multisig_mismatch',
+        '',
+        '   another_func(a: str) -> str  # This one should be ignored', # Not stripped
+        '',
+        '   Docstring starts here.',
+        '',
+    ]
+    assert list(actual_mismatch) == expected_mismatch_directive
+
+    # Test case with no real docstring after signatures
+    (app.srcdir / 'test_multisig_nodoc.py').write_text(textwrap.dedent("""\
+        def nodoc_func(a: int) -> int:
+            '''
+            nodoc_func(a: int) -> int
+            nodoc_func(b: str) -> str
+            '''
+            return 1
+    """), encoding='utf8')
+
+    actual_nodoc = do_autodoc(app, 'function', 'test_multisig_nodoc.nodoc_func', {})
+    expected_nodoc_directive = [
+        '',
+        '.. py:function:: nodoc_func(a: int) -> int',
+        '                 nodoc_func(b: str) -> str',
+        '   :module: test_multisig_nodoc',
+        '',
+    ]
+    # Need to filter trailing empty lines added by do_autodoc
+    assert list(actual_nodoc) == expected_nodoc_directive
+
+
 
 def test_autodoc_process_signature_typehints(app):
     captured = []
