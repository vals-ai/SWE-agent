diff --git a/db.sqlite3 b/db.sqlite3
new file mode 100644
index 0000000000..c28ce0e251
Binary files /dev/null and b/db.sqlite3 differ
diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index f02199d97c..561fbb5ec3 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -1412,13 +1412,32 @@ class SQLInsertCompiler(SQLCompiler):
             if not self.returning_fields:
                 return []
             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:
-                return self.connection.ops.fetch_returned_insert_rows(cursor)
+                # Convert raw values using from_db_value
+                raw_results = self.connection.ops.fetch_returned_insert_rows(cursor)
+                results = []
+                for row in raw_results:
+                    results.append([
+                        field.from_db_value(val, None, self.connection)
+                        for field, val in zip(self.returning_fields, row)
+                    ])
+                return results
             if self.connection.features.can_return_columns_from_insert:
                 assert len(self.query.objs) == 1
-                return [self.connection.ops.fetch_returned_insert_columns(cursor, self.returning_params)]
-            return [(self.connection.ops.last_insert_id(
+                # Convert raw values using from_db_value
+                raw_result = self.connection.ops.fetch_returned_insert_columns(cursor, self.returning_params)
+                return [[
+                    field.from_db_value(val, None, self.connection)
+                    for field, val in zip(self.returning_fields, raw_result)
+                ]]
+            # Only the PK is returned by last_insert_id, assert it's the only returning field.
+            assert len(self.returning_fields) == 1
+            pk_field = self.returning_fields[0]
+            pk_val = self.connection.ops.last_insert_id(
                 cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column
-            ),)]
+            )
+            # Convert raw value using from_db_value
+            converted_pk = pk_field.from_db_value(pk_val, None, self.connection)
+            return [(converted_pk,)]
 
 
 class SQLDeleteCompiler(SQLCompiler):
diff --git a/manage.py b/manage.py
new file mode 100644
index 0000000000..a142066440
--- /dev/null
+++ b/manage.py
@@ -0,0 +1,21 @@
+
+#!/usr/bin/env python
+"""Django's command-line utility for administrative tasks."""
+import os
+import sys
+
+def main():
+    """Run administrative tasks."""
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
+    try:
+        from django.core.management import execute_from_command_line
+    except ImportError as exc:
+        raise ImportError(
+            "Couldn't import Django. Are you sure it's installed and "
+            "available on your PYTHONPATH environment variable? Did you "
+            "forget to activate a virtual environment?"
+        ) from exc
+    execute_from_command_line(sys.argv)
+
+if __name__ == '__main__':
+    main()
\ No newline at end of file
diff --git a/repro_app/__init__.py b/repro_app/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/repro_app/management/__init__.py b/repro_app/management/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/repro_app/management/commands/__init__.py b/repro_app/management/commands/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/repro_app/management/commands/repro_command.py b/repro_app/management/commands/repro_command.py
new file mode 100644
index 0000000000..2e069f1cc1
--- /dev/null
+++ b/repro_app/management/commands/repro_command.py
@@ -0,0 +1,67 @@
+
+from django.core.management.base import BaseCommand
+from repro_app.models import AutoModel, MyIntWrapper
+
+class Command(BaseCommand):
+    help = 'Reproduces the from_db_value issue for returning fields'
+
+    def handle(self, *args, **options):
+        # Ensure table exists and is empty
+        # Note: In a real scenario, migrations would handle table creation.
+        # Here, we'll rely on Django's test runner or manual setup.
+        print("Setting up: Deleting existing AutoModel objects...")
+        AutoModel.objects.all().delete()
+        print("Setup complete.")
+
+        # Create an instance to check .first() behavior (should work correctly)
+        print("\nTesting .first()...")
+        # Create one to retrieve. Need to save it first.
+        AutoModel().save() # This should get ID 1 (or next available)
+        am = AutoModel.objects.first()
+        print(f"After .first(): am.id = {repr(am.id)}, type = {type(am.id)}")
+        if not isinstance(am.id, MyIntWrapper):
+            print("Error: am.id is not MyIntWrapper after .first()")
+        else:
+            print("OK: am.id is MyIntWrapper after .first()")
+
+
+        # Test .create() - This is expected to show the bug
+        print("\nTesting .create()...")
+        am2 = AutoModel.objects.create() # This should get ID 2 (or next available)
+        print(f"After .create(): am2.id = {repr(am2.id)}, type = {type(am2.id)}")
+        if not isinstance(am2.id, MyIntWrapper):
+            print("BUG REPRODUCED: am2.id is not MyIntWrapper after .create()")
+        else:
+            print("OK: am2.id is MyIntWrapper after .create()")
+
+
+        # Test bulk_create() - This is also expected to show the bug
+        print("\nTesting bulk_create()...")
+        ams = [AutoModel() for _ in range(2)] # Create two new instances
+        # Assuming the backend supports returning PKs (like PostgreSQL)
+        try:
+            # bulk_create might return the objects with IDs assigned
+            created_ams = AutoModel.objects.bulk_create(ams)
+            # Check the ID of the first object *in the list returned by bulk_create*
+            if created_ams:
+                print(f"After bulk_create(): created_ams[0].id = {repr(created_ams[0].id)}, type = {type(created_ams[0].id)}")
+                if not isinstance(created_ams[0].id, MyIntWrapper):
+                    print("BUG REPRODUCED: created_ams[0].id is not MyIntWrapper after bulk_create()")
+                else:
+                    print("OK: created_ams[0].id is MyIntWrapper after bulk_create()")
+            # Also check the ID of the first object *in the original list*
+            # Some backends might modify the original list in-place
+            elif ams and hasattr(ams[0], 'id') and ams[0].id is not None:
+                print(f"After bulk_create() (original list): ams[0].id = {repr(ams[0].id)}, type = {type(ams[0].id)}")
+                if not isinstance(ams[0].id, MyIntWrapper):
+                    print("BUG REPRODUCED: ams[0].id is not MyIntWrapper after bulk_create() (original list)")
+                else:
+                    print("OK: ams[0].id is MyIntWrapper after bulk_create() (original list)")
+            else:
+                print("bulk_create did not return objects, and original list objects have no ID.")
+
+        except Exception as e:
+            print(f"Could not test bulk_create properly, maybe backend doesn't support returning PKs? Error: {e}")
+
+
+        print("\nScript completed.")
\ No newline at end of file
diff --git a/repro_app/migrations/0001_initial.py b/repro_app/migrations/0001_initial.py
new file mode 100644
index 0000000000..a3be228542
--- /dev/null
+++ b/repro_app/migrations/0001_initial.py
@@ -0,0 +1,21 @@
+# Generated by Django 4.0.dev20210407150753 on 2025-04-28 21:34
+
+from django.db import migrations
+import repro_app.models
+
+
+class Migration(migrations.Migration):
+
+    initial = True
+
+    dependencies = [
+    ]
+
+    operations = [
+        migrations.CreateModel(
+            name='AutoModel',
+            fields=[
+                ('id', repro_app.models.MyAutoField(primary_key=True, serialize=False)),
+            ],
+        ),
+    ]
diff --git a/repro_app/migrations/__init__.py b/repro_app/migrations/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/repro_app/models.py b/repro_app/models.py
new file mode 100644
index 0000000000..b4dcb89516
--- /dev/null
+++ b/repro_app/models.py
@@ -0,0 +1,29 @@
+
+from django.db import models
+
+class MyIntWrapper:
+    def __init__(self, value):
+        self.value = value
+
+    def __int__(self):
+        return self.value
+
+    def __repr__(self):
+        return f"<MyIntWrapper: {self.value}>"
+
+class MyAutoField(models.BigAutoField):
+    def from_db_value(self, value, expression, connection):
+        if value is None:
+            return None
+        return MyIntWrapper(value)
+
+    def get_prep_value(self, value):
+        if value is None:
+            return None
+        # Allow MyIntWrapper instances or plain integers
+        if isinstance(value, MyIntWrapper):
+            return int(value.value)
+        return int(value)
+
+class AutoModel(models.Model):
+    id = MyAutoField(primary_key=True)
\ No newline at end of file
diff --git a/settings.py b/settings.py
new file mode 100644
index 0000000000..9107395540
--- /dev/null
+++ b/settings.py
@@ -0,0 +1,12 @@
+
+
+SECRET_KEY = 'django-insecure-test-key-for-repro'
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': 'db.sqlite3',
+    }
+}
+INSTALLED_APPS = [
+    'repro_app',
+]
\ No newline at end of file
diff --git a/tests/from_db_value/models.py b/tests/from_db_value/models.py
index 58e8ec3a27..206994afb2 100644
--- a/tests/from_db_value/models.py
+++ b/tests/from_db_value/models.py
@@ -1,6 +1,7 @@
 import decimal
 
 from django.db import models
+from django.db.models import BigAutoField
 
 
 class Cash(decimal.Decimal):
@@ -18,6 +19,47 @@ class CashField(models.DecimalField):
         cash.vendor = connection.vendor
         return cash
 
+# Models for testing from_db_value on AutoField during INSERT
+class MyIntWrapper:
+    def __init__(self, value):
+        self.value = value
+
+    def __int__(self):
+        return self.value
+
+    def __eq__(self, other):
+        if isinstance(other, MyIntWrapper):
+            return self.value == other.value
+        if isinstance(other, int):
+            return self.value == other
+        return NotImplemented
+
+    def __repr__(self):
+        return f"<MyIntWrapper: {self.value}>"
+
+
+class MyAutoField(BigAutoField):
+    def from_db_value(self, value, expression, connection):
+        if value is None:
+            return None
+        # Store connection vendor for testing purposes, similar to CashField
+        wrapper = MyIntWrapper(value)
+        wrapper.vendor = connection.vendor
+        return wrapper
+
+    def get_prep_value(self, value):
+        if value is None:
+            return None
+        if isinstance(value, MyIntWrapper):
+            return int(value.value)
+        return int(value)
+
+
+class AutoModelWithCustomPk(models.Model):
+    id = MyAutoField(primary_key=True)
+    # Add another field to make bulk_create more realistic
+    data = models.CharField(max_length=10, default='test')
+
 
 class CashModel(models.Model):
     cash = CashField()
diff --git a/tests/from_db_value/tests.py b/tests/from_db_value/tests.py
index ab92f37ccf..b974539aa3 100644
--- a/tests/from_db_value/tests.py
+++ b/tests/from_db_value/tests.py
@@ -2,7 +2,7 @@ from django.db import connection
 from django.db.models import Max
 from django.test import TestCase
 
-from .models import Cash, CashModel
+from .models import AutoModelWithCustomPk, Cash, CashModel, MyIntWrapper
 
 
 class FromDBValueTest(TestCase):
