diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..f074fbadc2
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,27 @@
+
+
+import inspect
+from sympy import Eq, rf, S, nsolve, Float
+from sympy.utilities.lambdify import lambdify
+
+x = S('x')
+eqn = Eq(rf(18,x), 77 + S(1)/3)
+f = lambdify(x, eqn.lhs - eqn.rhs, 'mpmath')
+
+print("Generated function source:")
+print(inspect.getsource(f))
+
+print("\nCalculating nsolve with high precision:")
+x0 = nsolve(eqn, Float('1.5', 64), prec=64)
+print(f"nsolve result x0: {x0}")
+
+print("\nEvaluating rf(18, x0) with high precision:")
+result = rf(18, x0).evalf(64)
+print(f"rf(18, x0): {result}")
+
+# Check if the result is close to the expected value 77 + 1/3
+expected = (77 + S(1)/3).evalf(64)
+print(f"Expected value (77 + 1/3): {expected}")
+
+# Add a success message at the end
+print("\nScript completed successfully, no errors.")
\ No newline at end of file
diff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py
index d06901425d..ae751b9ebb 100644
--- a/sympy/printing/pycode.py
+++ b/sympy/printing/pycode.py
@@ -330,6 +330,13 @@ def _print_Float(self, e):
         # Remove 'mpz' if gmpy is installed.
         args = str(tuple(map(int, e._mpf_)))
         return '{func}({args})'.format(func=self._module_format('mpmath.mpf'), args=args)
+    def _print_Rational(self, e):
+        # Ensure high-precision division for rationals
+        p, q = int(e.p), int(e.q)
+        # Use mpf for numerator and denominator
+        num_str = '{func}({p})'.format(func=self._module_format('mpmath.mpf'), p=p)
+        den_str = '{func}({q})'.format(func=self._module_format('mpmath.mpf'), q=q)
+        return '{}/{}'.format(num_str, den_str)
 
 
     def _print_uppergamma(self, e):
@@ -393,7 +400,7 @@ def _print_seq(self, seq):
         "General sequence printer: converts to tuple"
         # Print tuples here instead of lists because numba supports
         #     tuples in nopython mode.
-        delimite.get('delimiter', ', ')
+        delimiter = self._settings.get('delimiter', ', ')
         return '({},)'.format(delimiter.join(self._print(item) for item in seq))
 
     def _print_MatMul(self, expr):
diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py
index 149a7e3136..2588a6d116 100644
--- a/sympy/utilities/tests/test_lambdify.py
+++ b/sympy/utilities/tests/test_lambdify.py
@@ -9,7 +9,7 @@
     symbols, lambdify, sqrt, sin, cos, tan, pi, acos, acosh, Rational,
     Float, Matrix, Lambda, Piecewise, exp, Integral, oo, I, Abs, Function,
     true, false, And, Or, Not, ITE, Min, Max, floor, diff, IndexedBase, Sum,
-    DotProduct, Eq, Dummy, sinc)
+    DotProduct, Eq, Dummy, sinc, rf, S)
 from sympy.printing.lambdarepr import LambdaPrinter
 from sympy.utilities.lambdify import implemented_function
 from sympy.utilities.pytest import skip
@@ -898,3 +898,21 @@ def test_issue_14941():
     # test list
     f3 = lambdify([x, y], [y, x], 'sympy')
     assert f3(2, 3) == [3, 2]
+
+def test_mpmath_rational():
+    # Test for issue #14971: lambdify with mpmath module should wrap rationals
+    eqn = Eq(rf(18, x), 77 + S(1)/3)
+    f = lambdify(x, eqn.lhs - eqn.rhs, 'mpmath')
+
+    # Check the generated source code
+    src = inspect.getsource(f)
+    # Expect mpf division, not standard float division
+    assert 'mpf(232)/mpf(3)' in src or 'mpf(-232)/mpf(3)' in src
+
+    # Check evaluation with mpmath
+    with mpmath.workdps(30):
+        val = f(mpmath.mpf('1.5'))
+        # Check that the function evaluates close to the expected value
+        # rf(18, 1.5) - (77 + 1/3)
+        expected = mpmath.rf(18, mpmath.mpf('1.5')) - (mpmath.mpf(77) + mpmath.mpf(1)/mpmath.mpf(3))
+        assert mpmath.fabs(val - expected) < mpmath.mpf('1e-28')
\ No newline at end of file
