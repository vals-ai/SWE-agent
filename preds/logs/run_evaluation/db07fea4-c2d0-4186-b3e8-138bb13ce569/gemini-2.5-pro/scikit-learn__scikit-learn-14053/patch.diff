diff --git a/reproduce_bug.py b/reproduce_bug.py
new file mode 100644
index 000000000..f677c6316
--- /dev/null
+++ b/reproduce_bug.py
@@ -0,0 +1,13 @@
+
+from sklearn.tree import DecisionTreeClassifier
+from sklearn.tree import export_text
+from sklearn.datasets import load_iris
+
+X, y = load_iris(return_X_y=True)
+X = X[:, 0].reshape(-1, 1)
+
+tree = DecisionTreeClassifier()
+tree.fit(X, y)
+tree_text = export_text(tree, feature_names=['sepal_length'])
+print(tree_text)
+print("\nScript completed successfully, no errors.") # Added for confirmation
\ No newline at end of file
diff --git a/sklearn/tree/export.py b/sklearn/tree/export.py
index 1fe11e596..333c17f03 100644
--- a/sklearn/tree/export.py
+++ b/sklearn/tree/export.py
@@ -889,10 +889,18 @@ def export_text(decision_tree, feature_names=None, max_depth=10,
     else:
         value_fmt = "{}{} value: {}\n"
 
+    # Map node index to feature name used for splitting at that node
+    feature_names_ = [None] * tree_.node_count
     if feature_names:
-        feature_names_ = [feature_names[i] for i in tree_.feature]
-    else:
-        feature_names_ = ["feature_{}".format(i) for i in tree_.feature]
+        for node_id in range(tree_.node_count):
+            feature_index = tree_.feature[node_id]
+            if feature_index != _tree.TREE_UNDEFINED:
+                feature_names_[node_id] = feature_names[feature_index]
+    else:  # Use generic feature names
+        for node_id in range(tree_.node_count):
+            feature_index = tree_.feature[node_id]
+            if feature_index != _tree.TREE_UNDEFINED:
+                feature_names_[node_id] = "feature_{}".format(feature_index)
 
     export_text.report = ""
 
diff --git a/sklearn/tree/tests/test_export.py b/sklearn/tree/tests/test_export.py
index 503431f45..61ce10ec7 100644
--- a/sklearn/tree/tests/test_export.py
+++ b/sklearn/tree/tests/test_export.py
@@ -397,6 +397,35 @@ def test_export_text():
     assert export_text(reg, decimals=1, show_weights=True) == expected_report
 
 
+
+def test_export_text_single_feature():
+    # Test export_text with a single feature
+    import numpy as np
+    X_np = np.array(X)
+    y_np = np.array(y)
+    # Non-regression test for #14482
+    X_single = X_np[:, 0].reshape(-1, 1)
+    clf = DecisionTreeClassifier(max_depth=2, random_state=0)
+    clf.fit(X_single, y_np)
+
+    # Check with feature name
+    feature_name = ['sepal_length']
+    text_representation = export_text(clf, feature_names=feature_name)
+    # Basic check: ensure the feature name appears in the output
+    assert feature_name[0] in text_representation
+
+    # Check without feature name (should use default 'feature_0')
+    text_representation_default = export_text(clf)
+    assert 'feature_0' in text_representation_default
+
+    # Check for regressor as well
+    reg = DecisionTreeRegressor(max_depth=2, random_state=0)
+    reg.fit(X_single, y_np)
+    text_representation_reg = export_text(reg, feature_names=feature_name)
+    assert feature_name[0] in text_representation_reg
+    text_representation_reg_default = export_text(reg)
+    assert 'feature_0' in text_representation_reg_default
+
 def test_plot_tree_entropy(pyplot):
     # mostly smoke tests
     # Check correctness of export_graphviz for criterion = entropy
