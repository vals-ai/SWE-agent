diff --git a/pylint/checkers/variables.py b/pylint/checkers/variables.py
index 3ddafd599..04c1ef2f8 100644
--- a/pylint/checkers/variables.py
+++ b/pylint/checkers/variables.py
@@ -1822,31 +1822,51 @@ class VariablesChecker(BaseChecker):
 
     def _store_type_annotation_node(self, type_annotation):
         """Given a type annotation, store all the name nodes it refers to"""
-        if isinstance(type_annotation, astroid.Name):
-            self._type_annotation_names.append(type_annotation.name)
-            return
-
-        if not isinstance(type_annotation, astroid.Subscript):
-            return
-
+        # Special case for typing.X[...]
         if (
-            isinstance(type_annotation.value, astroid.Attribute)
+            isinstance(type_annotation, astroid.Subscript)
+            and isinstance(type_annotation.value, astroid.Attribute)
             and isinstance(type_annotation.value.expr, astroid.Name)
             and type_annotation.value.expr.name == TYPING_MODULE
         ):
             self._type_annotation_names.append(TYPING_MODULE)
-            return
+            # Also store names within the subscript index, e.g., typing.Dict[str, int]
+            # nodes_of_class should handle this recursion
 
+        # For all type annotations (Name, Attribute, Subscript, etc.),
+        # find and store all Name nodes within them.
         self._type_annotation_names.extend(
             annotation.name
             for annotation in type_annotation.nodes_of_class(astroid.Name)
         )
 
+
+
+
     def _store_type_annotation_names(self, node):
-        type_annotation = node.type_annotation
-        if not type_annotation:
+        type_node = node.type_annotation
+        if not type_node and node.type_comment:
+            # If no annotation, check for type comment (PEP 484)
+            try:
+                # Parse the type comment string into an AST node
+                # module_name helps astroid resolve relative names if needed
+                parsed_comment = astroid.parse(
+                    node.type_comment, module_name=node.root().name
+                )
+                # Type comments should parse as Module(body=[Expr(value=type_node)])
+                if (
+                    isinstance(parsed_comment, astroid.Module)
+                    and parsed_comment.body
+                    and isinstance(parsed_comment.body[0], astroid.Expr)
+                ):
+                    type_node = parsed_comment.body[0].value
+            except astroid.AstroidSyntaxError:
+                # Ignore syntactically incorrect type comments
+                pass  # Keep type_node as None
+
+        if not type_node:
             return
-        self._store_type_annotation_node(node.type_annotation)
+        self._store_type_annotation_node(type_node)
 
     def _check_self_cls_assign(self, node):
         """Check that self/cls don't get assigned"""
