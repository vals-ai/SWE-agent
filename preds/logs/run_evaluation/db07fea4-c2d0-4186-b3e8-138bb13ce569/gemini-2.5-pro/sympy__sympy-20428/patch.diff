diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 0000000000..890c2968cc
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,33 @@
+
+from sympy import *
+x = symbols("x")
+f = Poly(sympify("-117968192370600*18**(1/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) - 15720318185*2**(2/3)*3**(1/3)*(24201 + 253*sqrt(9165))**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) + 15720318185*12**(1/3)*(24201 + 253*sqrt(9165))**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) + 117968192370600*2**(1/3)*3**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3))"), x)
+coeff, bad_poly = f.clear_denoms()
+
+print("bad_poly:", bad_poly)
+print("bad_poly.is_zero:", bad_poly.is_zero)
+print("bad_poly.as_expr():", bad_poly.as_expr())
+print("bad_poly.as_expr().is_zero:", bad_poly.as_expr().is_zero)
+print("bad_poly.rep:", bad_poly.rep)
+
+# Test the problematic methods
+try:
+    print("bad_poly.terms_gcd():", bad_poly.terms_gcd())
+except Exception as e:
+    print("Error calling bad_poly.terms_gcd():", e)
+
+try:
+    print("bad_poly.primitive():", bad_poly.primitive())
+except Exception as e:
+    print("Error calling bad_poly.primitive():", e)
+
+# Compare with a standard zero poly
+zero_poly = Poly(0, x, domain="EX")
+print("\nComparing with standard zero poly:")
+print("zero_poly:", zero_poly)
+print("zero_poly.is_zero:", zero_poly.is_zero)
+print("zero_poly.rep:", zero_poly.rep)
+print("zero_poly.terms_gcd():", zero_poly.terms_gcd())
+print("zero_poly.primitive():", zero_poly.primitive())
+
+print("\nScript completed successfully, no errors.")
\ No newline at end of file
diff --git a/sympy/polys/densearith.py b/sympy/polys/densearith.py
index bce08bb356..4b8b395ca1 100644
--- a/sympy/polys/densearith.py
+++ b/sympy/polys/densearith.py
@@ -269,7 +269,10 @@ def dup_mul_ground(f, c, K):
     if not c or not f:
         return []
     else:
-        return [ cf * c for cf in f ]
+        # Multiply and then strip leading zeros
+        res = [ cf * c for cf in f ]
+        # dmp_strip expects (list, level), here level is 0 (dup)
+        return dmp_strip(res, 0)
 
 
 def dmp_mul_ground(f, c, u, K):
diff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py
index 70112de3b6..1fe9b6ab5b 100644
--- a/sympy/polys/polytools.py
+++ b/sympy/polys/polytools.py
@@ -2245,6 +2245,7 @@ def clear_denoms(self, convert=False):
 
         if hasattr(f.rep, 'clear_denoms'):
             coeff, result = f.rep.clear_denoms()
+
         else:  # pragma: no cover
             raise OperationNotSupported(f, 'clear_denoms')
 
diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py
index c774fc41e2..6e35a0a809 100644
--- a/sympy/polys/tests/test_polytools.py
+++ b/sympy/polys/tests/test_polytools.py
@@ -54,8 +54,8 @@
 from sympy.polys.orderings import lex, grlex, grevlex
 
 from sympy import (
-    S, Integer, Rational, Float, Mul, Symbol, sqrt, Piecewise, Derivative,
-    exp, sin, tanh, expand, oo, I, pi, re, im, rootof, Eq, Tuple, Expr, diff)
+    S, Integer, Rational, Float, Mul, Symbol, sqrt, Piecewise, Derivative, sympify,
+    exp, sin, tanh, expand, oo, I, pi, re, im, rootof, Eq, Tuple, Expr, diff, simplify,)
 
 from sympy.core.basic import _aresame
 from sympy.core.compatibility import iterable
@@ -2215,6 +2215,40 @@ def test_compose():
     assert compose(x**2 - y**2, x - y, y, x) == -y**2 + 2*x*y
 
 
+def test_clear_denoms_zero_poly():
+    # Test case from issue #20427
+    # clear_denoms on a complicated expression that simplifies to zero
+    # should produce a canonical zero poly.
+    expr_str = "-117968192370600*18**(1/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) - 15720318185*2**(2/3)*3**(1/3)*(24201 + 253*sqrt(9165))**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) + 15720318185*12**(1/3)*(24201 + 253*sqrt(9165))**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3)) + 117968192370600*2**(1/3)*3**(2/3)/(217603955769048*(24201 + 253*sqrt(9165))**(1/3) + 2273005839412*sqrt(9165)*(24201 + 253*sqrt(9165))**(1/3))"
+    # Simplify first to check it's indeed zero (takes time)
+    # assert simplify(sympify(expr_str)) == 0
+    f = Poly(sympify(expr_str), x)
+    coeff, zero_p = f.clear_denoms()
+
+    assert zero_p == Poly(0, x, domain='EX')
+    assert zero_p.is_zero is True
+    assert zero_p.rep == DMP([], EX, 0) # Check canonical representation
+
+    # Check methods that failed before the fix
+    assert zero_p.terms_gcd() == ((0,), Poly(0, x, domain='EX'))
+    assert zero_p.primitive() == (1, Poly(0, x, domain='EX'))
+
+    # Test a simpler case that might also produce non-canonical zero
+    f_simple = Poly(S.Zero, x, domain=EX)
+    coeff_s, zero_s = f_simple.clear_denoms()
+    assert coeff_s == 1
+    assert zero_s == Poly(0, x, domain='EX')
+    assert zero_s.is_zero is True
+    assert zero_s.rep == DMP([], EX, 0)
+
+    # Test case where input is already zero
+    f_zero = Poly(0, x, domain=EX)
+    coeff_z, zero_z = f_zero.clear_denoms()
+    assert coeff_z == 1
+    assert zero_z == Poly(0, x, domain='EX')
+    assert zero_z.is_zero is True
+    assert zero_z.rep == DMP([], EX, 0)
+
 def test_shift():
     assert Poly(x**2 - 2*x + 1, x).shift(2) == Poly(x**2 + 2*x + 1, x)
 
