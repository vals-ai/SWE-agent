diff --git a/django/utils/decorators.py b/django/utils/decorators.py
index 5c9a5d01c7..926dbadd7b 100644
--- a/django/utils/decorators.py
+++ b/django/utils/decorators.py
@@ -1,6 +1,6 @@
+from functools import partial, update_wrapper, wraps
 "Functions that help with dynamically creating decorators for views."
 
-from functools import partial, update_wrapper, wraps
 
 
 class classonlymethod(classmethod):
@@ -37,7 +37,7 @@ def _multi_decorate(decorators, method):
         # 'self' argument, but it's a closure over self so it can call
         # 'func'. Also, wrap method.__get__() in a function because new
         # attributes can't be set on bound method objects, only on functions.
-        bound_method = partial(method.__get__(self, type(self)))
+        bound_method = update_wrapper(partial(method.__get__(self, type(self))), method)
         for dec in decorators:
             bound_method = dec(bound_method)
         return bound_method(*args, **kwargs)
diff --git a/reproduce_method_decorator_bug.py b/reproduce_method_decorator_bug.py
new file mode 100644
index 0000000000..eef61147bf
--- /dev/null
+++ b/reproduce_method_decorator_bug.py
@@ -0,0 +1,32 @@
+
+from functools import wraps
+from django.utils.decorators import method_decorator
+import logging
+
+# Configure a basic logger for demonstration
+logging.basicConfig(level=logging.DEBUG)
+logger_instance = logging.getLogger(__name__)
+
+def logger(func):
+    @wraps(func)
+    def inner(*args, **kwargs):
+        try:
+            result = func(*args, **kwargs)
+        except Exception as e:
+            result = str(e)
+        finally:
+            # Use logger_instance instead of logger which is the decorator function itself
+            logger_instance.debug(f"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}")
+        return result # Added return statement
+    return inner
+
+class Test:
+    @method_decorator(logger)
+    def hello_world(self):
+        return "hello"
+
+# Instantiate and call the method
+test_instance = Test()
+test_instance.hello_world()
+
+print("Script completed successfully, no errors.") # Added success message
\ No newline at end of file
diff --git a/tests/utils_tests/test_decorators.py b/tests/utils_tests/test_decorators.py
index 4cd8320d0b..9ffe64a215 100644
--- a/tests/utils_tests/test_decorators.py
+++ b/tests/utils_tests/test_decorators.py
@@ -2,6 +2,8 @@ from django.http import HttpResponse
 from django.template import engines
 from django.template.response import TemplateResponse
 from django.test import RequestFactory, SimpleTestCase
+from functools import wraps
+from django.utils.decorators import method_decorator
 from django.utils.decorators import decorator_from_middleware
 
 
@@ -114,3 +116,36 @@ class DecoratorFromMiddlewareTests(SimpleTestCase):
         self.assertTrue(getattr(request, 'process_response_reached', False))
         # process_response saw the rendered content
         self.assertEqual(request.process_response_content, b"Hello world")
+
+
+class MethodDecoratorTests(SimpleTestCase):
+    """Tests for method_decorator."""
+
+    def test_method_decorator_preserves_attributes(self):
+        """
+        method_decorator() should preserve function attributes like __name__
+        when the decorator uses functools.wraps.
+        """
+        decorator_called = False
+        original_func_name = ''
+
+        def simple_decorator(func):
+            @wraps(func)
+            def wrapper(*args, **kwargs):
+                nonlocal decorator_called, original_func_name
+                decorator_called = True
+                original_func_name = func.__name__  # Access __name__
+                return func(*args, **kwargs)
+            return wrapper
+
+        class MyClass:
+            @method_decorator(simple_decorator)
+            def my_method(self):
+                return "original method executed"
+
+        instance = MyClass()
+        result = instance.my_method()
+
+        self.assertEqual(result, "original method executed")
+        self.assertTrue(decorator_called)
+        self.assertEqual(original_func_name, 'my_method')
\ No newline at end of file
