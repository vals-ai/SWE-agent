diff --git a/sympy/core/add.py b/sympy/core/add.py
index 83a5f2aedc..92e687deed 100644
--- a/sympy/core/add.py
+++ b/sympy/core/add.py
@@ -528,12 +528,84 @@ def _eval_is_imaginary(self):
             return fuzzy_not(self.func(*im_I).is_zero)
         elif b.is_zero is False:
             return False
+    def _check_zero_norecurse(self, expr):
+        """Quick check for zero without using .is_zero"""
+        # Need S for Zero
+        from .singleton import S
+        if expr is S.Zero:
+            return True
+        # Check if it's an Add object with no args (result of Add() or _new_rawargs())
+        if isinstance(expr, Add) and not expr.args:
+            return True
+        # Maybe add checks for Number(0)?
+        if hasattr(expr, 'is_Number') and expr.is_Number and expr == 0:
+            return True
+        # Cannot determine easily, return None
+        return None
 
     def _eval_is_zero(self):
         if self.is_commutative is False:
             # issue 10528: there is no way to know if a nc symbol
             # is zero or not
-            return
+            return None # Explicitly return None
+
+        # Separates arguments into real, imaginary, and other parts.
+        re_part = []
+        im_part = []
+        # Need S for ImaginaryUnit and Zero
+        from .singleton import S
+        for a in self.args:
+            # Optimization: if a term is definitely zero, ignore it
+            is_zero = a.is_zero
+            if is_zero:
+                continue
+            if is_zero is None: # Cannot determine if this arg is zero
+                return None
+
+            # Now process non-zero args
+            if a.is_real:
+                re_part.append(a)
+            elif a.is_imaginary:
+                # Add the coefficient of I to im_part
+                im_part.append(-S.ImaginaryUnit * a)
+            else: # Not real, not imaginary. Could be complex or symbolic.
+                # Try to extract real and imaginary parts if possible.
+                # Use _eval_real_imag to avoid infinite recursion if a.as_real_imag calls is_zero
+                re_a, im_a = a.as_real_imag()
+                if re_a is None or im_a is None:
+                    # Cannot determine the parts, maybe symbolic.
+                    return None # Give up if we encounter terms we can't split
+
+                # Append non-zero parts (check their is_zero status)
+                im_a_zero = self._check_zero_norecurse(im_a)
+                if im_a_zero is None: return None
+                if not im_a_zero:
+                    im_part.append(im_a)
+
+                re_a_zero = self._check_zero_norecurse(re_a)
+                if re_a_zero is None: return None
+                if not re_a_zero:
+                    re_part.append(re_a)
+
+        # Check if the real part sums to zero
+        # Use _new_rawargs to avoid infinite recursion if Add._new calls Add.is_zero
+        # Check if list is empty first
+        sum_re = self._new_rawargs(*re_part) if re_part else S.Zero
+        re_is_zero = self._check_zero_norecurse(sum_re)
+
+        # Check if the imaginary part sums to zero
+        sum_im = self._new_rawargs(*im_part) if im_part else S.Zero
+        im_is_zero = self._check_zero_norecurse(sum_im)
+
+        # Determine final result
+        if re_is_zero is None or im_is_zero is None:
+            return None
+        elif re_is_zero and im_is_zero:
+            return True
+        else:
+            # If either part is definitely non-zero, or if both are, the sum is non-zero.
+            return False
+
         nz = []
         z = 0
         im_or_z = False
diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py
index e2398a4e7c..8890a6d6b4 100644
--- a/sympy/core/tests/test_arit.py
+++ b/sympy/core/tests/test_arit.py
@@ -1993,4 +1993,33 @@ def test_issue_14392():
 def test_divmod():
     assert divmod(x, y) == (x//y, x % y)
     assert divmod(x, 3) == (x//3, x % 3)
+
+
+def test_add_is_zero_complex():
+    """Test for issue #15873 regarding is_zero on complex Add expressions."""
+    from sympy import I, simplify
+
+    # Expression from the issue
+    e = -2*I + (1 + I)**2
+
+    # Before simplification, is_zero should be None (cannot determine)
+    assert e.is_zero is None
+
+    # After simplification, is_zero should be True
+    assert simplify(e).is_zero is True
+
+    # Another example: 1 + I - (1 + I)
+    e2 = 1 + I - (1 + I)
+    assert e2.is_zero is True
+    assert simplify(e2).is_zero is True
+
+    # Example that is not zero
+    e3 = 1 + 2*I
+    assert e3.is_zero is False
+
+    # Example with symbols that cancel
+    x = symbols('x', real=True)
+    e4 = x + I - (x + I)
+    assert e4.is_zero is True
+    assert simplify(e4).is_zero is True
     assert divmod(3, x) == (3//x, 3 % x)
