diff --git a/django/db/backends/mysql/schema.py b/django/db/backends/mysql/schema.py
index 562b209eef..d14352cbb0 100644
--- a/django/db/backends/mysql/schema.py
+++ b/django/db/backends/mysql/schema.py
@@ -167,6 +167,13 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
 
     def _alter_column_type_sql(self, model, old_field, new_field, new_type):
         new_type = self._set_field_new_type_null_status(old_field, new_type)
+        # Propagate db_collation from FK target to FK.
+        if (
+            new_field.is_relation
+            and new_field.db_collation is None
+            and new_field.target_field.db_collation
+        ):
+            new_type += " COLLATE %s" % new_field.target_field.db_collation
         return super()._alter_column_type_sql(model, old_field, new_field, new_type)
 
     def _rename_field_sql(self, table, old_field, new_field, new_type):
diff --git a/tests/schema/tests.py b/tests/schema/tests.py
index 2d12796cbd..8f4ddbedb0 100644
--- a/tests/schema/tests.py
+++ b/tests/schema/tests.py
@@ -792,6 +792,82 @@ class SchemaTests(TransactionTestCase):
         # Introspection treats BLOBs as TextFields
         self.assertEqual(columns["bits"][0], "TextField")
 
+    @unittest.skipUnless(connection.vendor == "mysql", "MySQL specific")
+    def test_alter_fk_target_collation(self):
+        """
+        Test that altering a FK's target field collation propagates the
+        collation to the FK field itself on MySQL.
+        """
+        from django.db import models  # Import models here
+
+        # Define initial models without collation
+        class Parent(models.Model):
+            id = models.CharField(primary_key=True, max_length=22)
+            class Meta:
+                app_label = 'schema'
+
+        class Child(models.Model):
+            parent = models.ForeignKey(Parent, models.CASCADE)
+            class Meta:
+                app_label = 'schema'
+
+        self.local_models = [Parent, Child]
+
+        # Create initial tables
+        with connection.schema_editor() as editor:
+            editor.create_model(Parent)
+            editor.create_model(Child)
+
+        # Define new Parent model with collation
+        class ParentNew(models.Model):
+            id = models.CharField(primary_key=True, max_length=22, db_collation='utf8_bin')
+            class Meta:
+                app_label = 'schema'
+                db_table = Parent._meta.db_table
+
+        # Define new Child model referencing the new Parent
+        class ChildNew(models.Model):
+            parent = models.ForeignKey(ParentNew, models.CASCADE)
+            class Meta:
+                app_label = 'schema'
+                db_table = Child._meta.db_table
+
+        self.local_models.extend([ParentNew, ChildNew]) # Add new models
+
+        old_parent_field = Parent._meta.get_field('id')
+        new_parent_field = ParentNew._meta.get_field('id')
+        old_child_field = Child._meta.get_field('parent')
+        new_child_field = ChildNew._meta.get_field('parent')
+
+        # Alter Parent's PK to add collation
+        with connection.schema_editor() as editor:
+            editor.alter_field(ParentNew, old_parent_field, new_parent_field)
+
+        # Check the SQL generated for altering Child's FK
+        with connection.schema_editor() as editor:
+            sql, params = editor._alter_column_type_sql(
+                ChildNew, old_child_field, new_child_field, new_child_field.db_type(connection)
+            )
+            # Check if the generated SQL string includes the collation.
+            generated_sql = sql % params
+            self.assertIn("COLLATE utf8_bin", generated_sql)
+
+        # Optional: Try to actually alter the field and add constraint
+        with connection.schema_editor() as editor:
+             # Drop the old FK constraint if it exists before altering the column
+            try:
+                # Construct the expected constraint name (this might vary)
+                constraint_name = editor._create_index_name(
+                    Child._meta.db_table, [old_child_field.column], suffix='_fk_%s' % Parent._meta.db_table
+                )
+                editor.execute(editor._delete_constraint_sql(editor.sql_delete_fk, Child, constraint_name))
+            except Exception: # Might fail if constraint name is different or doesn't exist
+                pass # Ignore errors, focus is on alter_field including collation
+            editor.alter_field(ChildNew, old_child_field, new_child_field)
+            # If collation wasn't propagated, adding the constraint might fail
+            fk_sql = editor._create_fk_sql(ChildNew, new_child_field, "_fk")
+            self.assertIsNotNone(fk_sql) # Basic check that FK SQL can be generated
+
     def test_remove_field(self):
         with connection.schema_editor() as editor:
             editor.create_model(Author)
