diff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py
index ac0b62d0bf..ea88c54b0d 100644
--- a/django/db/models/aggregates.py
+++ b/django/db/models/aggregates.py
@@ -68,7 +68,7 @@ class Aggregate(Func):
         return []
 
     def as_sql(self, compiler, connection, **extra_context):
-        extra_context['distinct'] = 'DISTINCT' if self.distinct else ''
+        extra_context['distinct'] = 'DISTINCT ' if self.distinct else ''
         if self.filter:
             if connection.features.supports_aggregate_filter_clause:
                 filter_sql, filter_params = self.filter.as_sql(compiler, connection)
diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py
index 8cac90f020..ef8668592a 100644
--- a/tests/aggregation/tests.py
+++ b/tests/aggregation/tests.py
@@ -5,8 +5,8 @@ from decimal import Decimal
 from django.core.exceptions import FieldError
 from django.db import connection
 from django.db.models import (
-    Avg, Count, DecimalField, DurationField, F, FloatField, Func, IntegerField,
-    Max, Min, Sum, Value,
+    Avg, Case, Count, DecimalField, DurationField, F, FloatField, Func, IntegerField,
+    Max, Min, Q, Sum, Value, When,
 )
 from django.test import TestCase
 from django.test.utils import Approximate, CaptureQueriesContext
@@ -1105,5 +1105,46 @@ class AggregateTestCase(TestCase):
             Book.objects.aggregate(FloatField())
         with self.assertRaisesMessage(TypeError, msg % True):
             Book.objects.aggregate(is_book=True)
+            Book.objects.aggregate(FloatField(), is_book=True)
         with self.assertRaisesMessage(TypeError, msg % ', '.join([str(FloatField()), 'True'])):
             Book.objects.aggregate(FloatField(), Avg('price'), is_book=True)
+
+    def test_distinct_conditional_aggregation(self):
+        """
+        Test aggregation with distinct=True and a filter condition.
+        """
+        # Test data:
+        # Publisher 1 (Apress): 2 books (rating 4.5, 4.0) -> 1 distinct rating >= 4.0
+        # Publisher 2 (Sams): 1 book (rating 3.0) -> 0 distinct ratings >= 4.0
+        # Publisher 3 (Prentice Hall): 2 books (rating 4.0, 4.0) -> 1 distinct rating >= 4.0
+        # Publisher 4 (Morgan Kaufmann): 1 book (rating 5.0) -> 1 distinct rating >= 4.0
+        # Publisher 5 (Jonno's): 0 books -> 0 distinct ratings >= 4.0
+        results = Publisher.objects.annotate(
+            distinct_high_ratings=Count(
+                'book__rating',
+                filter=Q(book__rating__gte=4.0),
+                distinct=True
+            )
+        ).order_by('name').values_list('name', 'distinct_high_ratings')
+        self.assertSequenceEqual(list(results), [
+            ('Apress', 2),
+            ('Jonno\'s House of Books', 0),
+            ('Morgan Kaufmann', 1),
+            ('Prentice Hall', 1),
+            ('Sams', 0),
+        ])
+
+        # Test with Case/When directly (should also work)
+        results_case = Publisher.objects.annotate(
+            distinct_high_ratings_case=Count(
+                Case(When(book__rating__gte=4.0, then='book__rating')),
+                distinct=True
+            )
+        ).order_by('name').values_list('name', 'distinct_high_ratings_case')
+        self.assertSequenceEqual(list(results_case), [
+            ('Apress', 2),
+            ('Jonno\'s House of Books', 0),
+            ('Morgan Kaufmann', 1),
+            ('Prentice Hall', 1),
+            ('Sams', 0),
+        ])
