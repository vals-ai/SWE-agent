diff --git a/django/forms/models.py b/django/forms/models.py
index 192d9fad94..0b571662cf 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -259,11 +259,11 @@ class ModelFormMetaclass(DeclarativeFieldsMetaclass):
     def __new__(mcs, name, bases, attrs):
         base_formfield_callback = None
         for b in bases:
-            if hasattr(b, "Meta") and hasattr(b.Meta, "formfield_callback"):
-                base_formfield_callback = b.Meta.formfield_callback
+            if hasattr(b, "formfield_callback"): # Check base class directly
+                base_formfield_callback = b.formfield_callback # Get from base class
                 break
 
-        formfield_callback = attrs.pop("formfield_callback", base_formfield_callback)
+        formfield_callback = attrs.get("formfield_callback", base_formfield_callback)
 
         new_class = super().__new__(mcs, name, bases, attrs)
 
@@ -630,13 +630,16 @@ def modelform_factory(
     # creating needs to inherit from the parent's inner meta.
     bases = (form.Meta,) if hasattr(form, "Meta") else ()
     Meta = type("Meta", bases, attrs)
-    if formfield_callback:
-        Meta.formfield_callback = staticmethod(formfield_callback)
     # Give this new form class a reasonable name.
     class_name = model.__name__ + "Form"
 
     # Class attributes for the new form class.
-    form_class_attrs = {"Meta": Meta, "formfield_callback": formfield_callback}
+    # Determine the formfield_callback to use.
+    callback = formfield_callback
+    if callback is None and hasattr(form, 'formfield_callback'):
+        callback = form.formfield_callback
+
+    form_class_attrs = {"Meta": Meta, "formfield_callback": callback}
 
     if getattr(Meta, "fields", None) is None and getattr(Meta, "exclude", None) is None:
         raise ImproperlyConfigured(
diff --git a/reproduce_bug.py b/reproduce_bug.py
new file mode 100644
index 0000000000..1bdce859ff
--- /dev/null
+++ b/reproduce_bug.py
@@ -0,0 +1,76 @@
+
+import os
+import sys
+from django import forms
+from django.db import models
+from django.conf import settings
+from django.core.management import execute_from_command_line
+
+# Minimal Django settings
+BASE_DIR = os.path.dirname(os.path.abspath(__file__))
+settings.configure(
+    SECRET_KEY='a-test-secret-key',
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+        '__main__', # Add the current script as an app
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
+        }
+    },
+    DEFAULT_AUTO_FIELD='django.db.models.AutoField',
+)
+import django
+django.setup()
+
+# Define the model
+class MyModel(models.Model):
+    active = models.BooleanField()
+    name = models.CharField(max_length=64, blank=True, null=True)
+
+    class Meta:
+        app_label = '__main__' # Important for standalone scripts
+
+# Define the callback
+def all_required(field, **kwargs):
+    # print(f"Callback called for field: {field.name}") # Debug print
+    formfield = field.formfield(**kwargs)
+    if formfield: # formfield can return None for some fields
+        formfield.required = True
+    return formfield
+
+# Define the base form with the callback in Meta
+class MyForm(forms.ModelForm):
+    formfield_callback = all_required
+    class Meta:
+        model = MyModel
+        fields = ['active', 'name']
+
+# Create the form using the factory
+FactoryForm = forms.modelform_factory(MyModel, form=MyForm)
+
+# Check the fields in the original form
+my_form_instance = MyForm()
+print("MyForm fields required:")
+print(f"  active: {my_form_instance.fields['active'].required}")
+print(f"  name: {my_form_instance.fields['name'].required}")
+
+
+# Check the fields in the factory-generated form
+factory_form_instance = FactoryForm()
+print("\nFactoryForm fields required (Buggy behavior):")
+print(f"  active: {factory_form_instance.fields['active'].required}")
+print(f"  name: {factory_form_instance.fields['name'].required}")
+
+# Assert expected behavior (should fail with the bug)
+expected_active_required = True
+expected_name_required = True # Even though model field has blank=True, callback should override
+
+print("\nChecking assertions...")
+assert factory_form_instance.fields['active'].required == expected_active_required, "FactoryForm 'active' field should be required"
+assert factory_form_instance.fields['name'].required == expected_name_required, "FactoryForm 'name' field should be required"
+
+print("\nScript completed successfully, expected behavior observed.")
diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py
index d2ce3348c5..c99234b238 100644
--- a/tests/model_forms/tests.py
+++ b/tests/model_forms/tests.py
@@ -3540,6 +3540,74 @@ class LocalizedModelFormTest(TestCase):
                     localized_fields = "foo"
 
 
+class ModelFormFactoryCallbackTests(SimpleTestCase):
+    def test_factory_inherits_formfield_callback(self):
+        """modelform_factory should inherit formfield_callback from the base form."""
+
+        def make_all_fields_required(field, **kwargs):
+            formfield = field.formfield(**kwargs)
+            if formfield:
+                formfield.required = True
+            return formfield
+
+        class BaseCallbackForm(forms.ModelForm):
+            formfield_callback = make_all_fields_required
+
+            class Meta:
+                model = Article # Use Article model
+                fields = ["headline", "status"] # headline is required, status is optional
+
+        # Check base form
+        base_form = BaseCallbackForm()
+        self.assertTrue(base_form.fields["headline"].required)
+        self.assertTrue(base_form.fields["status"].required) # Callback overrides model
+
+        # Create form with factory, inheriting callback
+        FactoryForm = modelform_factory(Article, form=BaseCallbackForm)
+        factory_form = FactoryForm()
+        self.assertTrue(factory_form.fields["headline"].required)
+        self.assertTrue(
+            factory_form.fields["status"].required,
+            "Factory form should inherit formfield_callback from BaseCallbackForm",
+        )
+
+    def test_factory_callback_overrides_base_form_callback(self):
+        """formfield_callback passed to factory should override base form's callback."""
+
+        def make_all_fields_optional(field, **kwargs):
+            formfield = field.formfield(**kwargs)
+            if formfield:
+                formfield.required = False
+            return formfield
+
+        def make_all_fields_required(field, **kwargs):
+            formfield = field.formfield(**kwargs)
+            if formfield:
+                formfield.required = True
+            return formfield
+
+        class BaseCallbackForm(forms.ModelForm):
+            formfield_callback = make_all_fields_required
+
+            class Meta:
+                model = Article
+                fields = ["headline", "status"]
+
+        # Create form with factory, providing overriding callback
+        FactoryForm = modelform_factory(
+            Article, form=BaseCallbackForm, formfield_callback=make_all_fields_optional
+        )
+        factory_form = FactoryForm()
+        self.assertFalse(
+            factory_form.fields["headline"].required,
+            "Factory callback should make headline optional",
+        )
+        self.assertFalse(
+            factory_form.fields["status"].required,
+            "Factory callback should make status optional",
+        )
+
+
 class CustomMetaclass(ModelFormMetaclass):
     def __new__(cls, name, bases, attrs):
         new = super().__new__(cls, name, bases, attrs)
