diff --git a/xarray/core/computation.py b/xarray/core/computation.py
index 3f7e8f74..9d2831a8 100644
--- a/xarray/core/computation.py
+++ b/xarray/core/computation.py
@@ -27,7 +27,7 @@ import numpy as np
 from . import dtypes, duck_array_ops, utils
 from .alignment import align, deep_align
 from .common import zeros_like
-from .duck_array_ops import datetime_to_numeric
+from .duck_array_ops import datetime_to_numeric, where as _where_op
 from .indexes import Index, filter_indexes_from_coords
 from .merge import merge_attrs, merge_coordinates_without_align
 from .options import OPTIONS, _get_keep_attrs
@@ -332,6 +332,11 @@ def apply_dataarray_vfunc(
         )
 
     attrs = merge_attrs([x.attrs for x in objs], combine_attrs=keep_attrs)
+    # For xr.where(..., keep_attrs=True), we use the special "where_keep" strategy.
+    # This ensures coordinate attrs are merged like "override", but here we
+    # explicitly set the final DataArray attrs to {} instead of inheriting from inputs.
+    if keep_attrs == "where_keep":
+        attrs = {}
     if isinstance(out, tuple):
         for da in out:
             da.attrs = attrs
@@ -1858,9 +1863,7 @@ def where(cond, x, y, keep_attrs=None):
     if keep_attrs is None:
         keep_attrs = _get_keep_attrs(default=False)
     if keep_attrs is True:
-        # keep the attributes of x, the second parameter, by default to
-        # be consistent with the `where` method of `DataArray` and `Dataset`
-        keep_attrs = lambda attrs, context: getattr(x, "attrs", {})
+        keep_attrs = "where_keep" # Use special string for where + keep_attrs=True
 
     # alignment for three arguments is complicated, so don't support it yet
     return apply_ufunc(
diff --git a/xarray/core/merge.py b/xarray/core/merge.py
index 859b3aef..b4647c02 100644
--- a/xarray/core/merge.py
+++ b/xarray/core/merge.py
@@ -641,7 +641,7 @@ def merge_attrs(variable_attrs, combine_attrs, context=None):
         return combine_attrs(variable_attrs, context=context)
     elif combine_attrs == "drop":
         return {}
-    elif combine_attrs == "override":
+    elif combine_attrs in ("override", "where_keep"):
         return dict(variable_attrs[0])
     elif combine_attrs == "no_conflicts":
         result = dict(variable_attrs[0])
diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py
index da1bd014..f91a204e 100644
--- a/xarray/tests/test_computation.py
+++ b/xarray/tests/test_computation.py
@@ -1929,11 +1929,26 @@ def test_where_attrs() -> None:
     x = xr.DataArray([1, 1], dims="x", attrs={"attr": "x"})
     y = xr.DataArray([0, 0], dims="x", attrs={"attr": "y"})
     actual = xr.where(cond, x, y, keep_attrs=True)
-    expected = xr.DataArray([1, 0], dims="x", attrs={"attr": "x"})
+    expected = xr.DataArray([1, 0], dims="x", attrs={})
     assert_identical(expected, actual)
 
     # ensure keep_attrs can handle scalar values
     actual = xr.where(cond, 1, 0, keep_attrs=True)
+
+    # Test case from GH issue #7273
+    ds = xr.tutorial.load_dataset("air_temperature")
+    air_with_coord_attrs = ds.air.copy()
+    # Ensure time coord has distinct attrs
+    air_with_coord_attrs.time.attrs = {"standard_name": "time", "long_name": "Time", "coord_attr": "value"}
+    # Ensure air variable has distinct attrs
+    air_with_coord_attrs.attrs = {"var_attr": "value"}
+
+    result = xr.where(True, air_with_coord_attrs, air_with_coord_attrs, keep_attrs=True)
+
+    # Check that coordinate attributes are preserved
+    assert result.time.attrs == air_with_coord_attrs.time.attrs
+    # Check that variable attributes are NOT copied from input
+    assert result.attrs == {}
     assert actual.attrs == {}
 
 
