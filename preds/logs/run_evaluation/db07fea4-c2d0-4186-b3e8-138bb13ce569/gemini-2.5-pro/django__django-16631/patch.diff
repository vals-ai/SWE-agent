diff --git a/django/contrib/auth/__init__.py b/django/contrib/auth/__init__.py
index 155330c596..92dc238d2f 100644
--- a/django/contrib/auth/__init__.py
+++ b/django/contrib/auth/__init__.py
@@ -198,13 +198,39 @@ def get_user(request):
             user = backend.get_user(user_id)
             # Verify the session
             if hasattr(user, "get_session_auth_hash"):
+                rotate_hash_needed = False
                 session_hash = request.session.get(HASH_SESSION_KEY)
-                session_hash_verified = session_hash and constant_time_compare(
-                    session_hash, user.get_session_auth_hash()
-                )
+
+                session_hash_verified = False
+                if session_hash:
+                    # Try the primary key first
+                    if constant_time_compare(session_hash, user.get_session_auth_hash()):
+                        session_hash_verified = True
+                    else:
+
+                        # Try fallbacks
+                        for fallback_secret in settings.SECRET_KEY_FALLBACKS:
+                            if constant_time_compare(
+                                session_hash,
+                                user.get_session_auth_hash(secret=fallback_secret),
+                            ):
+
+                                rotate_hash_needed = True
+
+                                session_hash_verified = True
+                                break  # Found a match
+
                 if not session_hash_verified:
+                    # Session hash invalid, flush and return AnonymousUser
                     request.session.flush()
-                    user = None
+                    return AnonymousUser()
+        # If the user was authenticated using a fallback key, rotate the hash
+        # to the primary key to mitigate subsequent checks and potential timing
+        # attacks.
+        if user and rotate_hash_needed:
+            request.session[HASH_SESSION_KEY] = user.get_session_auth_hash()
+            # Session is modified, ensure it's saved later by middleware.
+            request.session.modified = True
 
     return user or AnonymousUser()
 
diff --git a/django/contrib/auth/base_user.py b/django/contrib/auth/base_user.py
index 5ee30bf59c..1bb77a7702 100644
--- a/django/contrib/auth/base_user.py
+++ b/django/contrib/auth/base_user.py
@@ -131,7 +131,7 @@ class AbstractBaseUser(models.Model):
         """
         return is_password_usable(self.password)
 
-    def get_session_auth_hash(self):
+    def get_session_auth_hash(self, secret=None):
         """
         Return an HMAC of the password field.
         """
@@ -139,6 +139,7 @@ class AbstractBaseUser(models.Model):
         return salted_hmac(
             key_salt,
             self.password,
+            secret=secret,
             algorithm="sha256",
         ).hexdigest()
 
diff --git a/tests/auth_tests/test_models.py b/tests/auth_tests/test_models.py
index fe1afcbdc3..afee80446e 100644
--- a/tests/auth_tests/test_models.py
+++ b/tests/auth_tests/test_models.py
@@ -19,6 +19,12 @@ from django.db.migrations.state import ModelState, ProjectState
 from django.db.models.signals import post_save
 from django.test import SimpleTestCase, TestCase, TransactionTestCase, override_settings
 from django.test.utils import ignore_warnings
+
+from django.conf import settings
+from django.contrib import auth
+from django.contrib.auth import HASH_SESSION_KEY, login, SESSION_KEY, BACKEND_SESSION_KEY
+from django.contrib.sessions.middleware import SessionMiddleware
+from django.test import RequestFactory, override_settings
 from django.utils.deprecation import RemovedInDjango51Warning
 
 from .models import CustomEmailField, IntegerUsernameUser
@@ -312,6 +318,92 @@ class AbstractUserTestCase(TestCase):
         finally:
             hasher.iterations = old_iterations
 
+    def test_session_auth_hash_fallback(self):
+        """
+        Test that get_user() successfully authenticates a user using a
+        session hash created with a SECRET_KEY now in SECRET_KEY_FALLBACKS.
+        """
+        # Use specific keys for clarity
+        old_key = "old-secret-key"
+        new_key = "new-secret-key"
+        fallback_keys = [old_key]
+
+        user = User.objects.create_user(username="fallback_test", password="password")
+        factory = RequestFactory()
+
+        # 1. Simulate login with the old key to store the session hash
+        with override_settings(SECRET_KEY=old_key, SECRET_KEY_FALLBACKS=[]):
+            request = factory.get("/test/")
+            # Need session middleware to process session
+            middleware = SessionMiddleware(lambda req: None)
+            middleware.process_request(request)
+            request.session.save()  # Ensure session key exists
+
+            login(request, user)
+            session_key = request.session.session_key
+            user_id = request.session[SESSION_KEY]
+            backend_path = request.session[BACKEND_SESSION_KEY]
+            session_hash_old = request.session[HASH_SESSION_KEY]
+            self.assertEqual(
+                session_hash_old, user.get_session_auth_hash(secret=old_key)
+            )
+
+        # 2. Rotate keys: new key becomes primary, old key is fallback
+        with override_settings(SECRET_KEY=new_key, SECRET_KEY_FALLBACKS=fallback_keys):
+            request_new = factory.get("/test/")
+            request_new.COOKIES[settings.SESSION_COOKIE_NAME] = session_key
+
+
+
+
+            middleware_new = SessionMiddleware(lambda req: None)
+
+
+
+
+            middleware_new.process_request(request_new)
+            # Manually populate session data as RequestFactory doesn't persist it
+            request_new.session[SESSION_KEY] = user_id
+            request_new.session[BACKEND_SESSION_KEY] = backend_path
+            request_new.session[HASH_SESSION_KEY] = session_hash_old
+            request_new.session.save() # Ensure data is saved if backend requires it
+
+
+            # 3. Verify get_user() works with the fallback key
+            authenticated_user = auth.get_user(request_new)
+            self.assertEqual(authenticated_user, user)
+            # Check that the session hash hasn't been rotated yet
+
+
+            # Check that the session hash *has* been rotated to the new key
+            session_hash_new = request_new.session[HASH_SESSION_KEY]
+            self.assertNotEqual(session_hash_new, session_hash_old)
+            self.assertEqual(
+                session_hash_new, user.get_session_auth_hash(secret=new_key)
+            )
+
+        # 5. Remove fallback key and verify get_user() fails
+            middleware_fail = SessionMiddleware(lambda req: None)
+        with override_settings(SECRET_KEY=new_key, SECRET_KEY_FALLBACKS=[]):
+            request_fail = factory.get("/test/")
+            # Use the original session key with the hash created by the old secret
+            request_fail.COOKIES[settings.SESSION_COOKIE_NAME] = session_key
+            middleware_fail.process_request(request_fail)
+            # Manually set the old hash as it might have been rotated previously
+            request_fail.session[HASH_SESSION_KEY] = session_hash_old
+            request_fail.session.save()
+
+            # Re-fetch request with the old hash set
+            request_fail_refetch = factory.get("/test/")
+            request_fail_refetch.COOKIES[settings.SESSION_COOKIE_NAME] = session_key
+            middleware_fail.process_request(request_fail_refetch)
+
+
+            authenticated_user_fail = auth.get_user(request_fail_refetch)
+            self.assertNotEqual(authenticated_user_fail, user)
+            self.assertTrue(authenticated_user_fail.is_anonymous)
+            # Session should be flushed
+
 
 class CustomModelBackend(ModelBackend):
     def with_perm(
