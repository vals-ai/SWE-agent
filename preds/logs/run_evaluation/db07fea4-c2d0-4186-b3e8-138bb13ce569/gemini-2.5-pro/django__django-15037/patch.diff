diff --git a/django/core/management/commands/inspectdb.py b/django/core/management/commands/inspectdb.py
index f9b4bfb477..91b331fca9 100644
--- a/django/core/management/commands/inspectdb.py
+++ b/django/core/management/commands/inspectdb.py
@@ -123,7 +123,27 @@ class Command(BaseCommand):
                         rel_to = (
                             "self" if relations[column_name][1] == table_name
                             else table2model(relations[column_name][1])
+\
                         )
+                        # Determine target column and table PK
+                        ref_col_name = relations[column_name][0]
+                        ref_table_name = relations[column_name][1]
+                        # Need to handle potential errors if introspection fails for related table
+                        try:
+                            ref_pk_col = connection.introspection.get_primary_key_column(cursor, ref_table_name)
+                        except Exception as e:
+                            ref_pk_col = None
+                            comment_notes.append(f'Could not determine PK for {ref_table_name!r}: {e}')
+
+                        # Add 'to_field' if relation points to a non-primary key column
+                        if ref_pk_col is not None and ref_col_name != ref_pk_col:
+                            # Using the raw column name for 'to_field' as the target model's
+                            # field name isn't known at this stage.
+                            extra_params['to_field'] = ref_col_name
+                            comment_notes.append(
+                                f'ForeignKey points to column {ref_col_name!r} on {table2model(ref_table_name)!r}. '
+                                f'Set to_field={ref_col_name!r}. Verify that this corresponds to the correct field name on the target model.'
+                            )
                         if rel_to in known_models:
                             field_type = '%s(%s' % (rel_type, rel_to)
                         else:
diff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py
index 8be1681106..d2fdc93b9b 100644
--- a/tests/inspectdb/tests.py
+++ b/tests/inspectdb/tests.py
@@ -221,6 +221,86 @@ class InspectDBTestCase(TestCase):
         self.assertNotIn('    45extra = models.%s' % char_field_type, output, msg=error_message)
         self.assertIn('number_45extra = models.%s' % char_field_type, output)
 
+    @skipUnlessDBFeature('can_introspect_foreign_keys')
+    def test_foreign_key_to_non_pk_field(self):
+        """
+        Test introspection of foreign keys pointing to a non-primary key field.
+        (#21487)
+        """
+        # Import necessary modules locally within the test
+        from io import StringIO
+        from django.core.management import call_command
+        from django.db import connection
+        from django.test import skipUnlessDBFeature
+
+        table_target = 'inspectdb_fk_target_21487'
+        table_source = 'inspectdb_fk_source_21487'
+        out = StringIO()
+
+        # Use raw SQL to create tables
+        with connection.cursor() as cursor:
+            # Drop tables if they exist (for cleanup in case of previous failure)
+            try:
+                cursor.execute(f"DROP TABLE {table_source}")
+            except Exception:
+                pass
+            try:
+                cursor.execute(f"DROP TABLE {table_target}")
+            except Exception:
+                pass
+
+            # Create target table
+            cursor.execute(
+                f"CREATE TABLE {table_target} ("
+                f" id {connection.features.introspected_field_types['AutoField']}, "
+                f" unique_int {connection.features.introspected_field_types['IntegerField']} UNIQUE"
+                f")"
+            )
+            # Create source table with FK to non-PK field
+            cursor.execute(
+                f"CREATE TABLE {table_source} ("
+                f" id {connection.features.introspected_field_types['AutoField']}, "
+                f" target_int_id {connection.features.introspected_field_types['IntegerField']}, "
+                f" FOREIGN KEY(target_int_id) REFERENCES {table_target}(unique_int)"
+                f")"
+            )
+
+        try:
+            # Run inspectdb on the source table
+            call_command('inspectdb', table_source, stdout=out)
+            output = out.getvalue()
+
+            # Define the expected ForeignKey string with to_field and db_column
+            # inspectdb should generate field 'target_int' from column 'target_int_id'
+            expected_fk_string = (
+                "    target_int = models.ForeignKey("
+                # Model name derived from table name by inspectdb
+                f"'{connection.introspection.identifier_converter(table_target)}', models.DO_NOTHING, db_column='target_int_id', to_field='unique_int', blank=True, null=True"
+                ")"
+            )
+            # Check the generated field definition
+            self.assertIn(
+                expected_fk_string,
+                output,
+                f"Expected ForeignKey with to_field and db_column not found in output:\\n{output}"
+            )
+            # Also check that the comment added in the fix is present
+            target_model_name = connection.introspection.identifier_converter(table_target)
+            self.assertIn(f"# ForeignKey points to column 'unique_int' on '{target_model_name}'.", output)
+            self.assertIn("# Set to_field='unique_int'. Verify that this corresponds to the correct field name on the target model.", output)
+
+        finally:
+            # Clean up the tables using raw SQL
+            with connection.cursor() as cursor:
+                try:
+                    cursor.execute(f"DROP TABLE {table_source}")
+                except Exception:
+                    pass
+                try:
+                    cursor.execute(f"DROP TABLE {table_target}")
+                except Exception:
+                    pass
+
     def test_special_column_name_introspection(self):
         """
         Introspection of column names containing special characters,
