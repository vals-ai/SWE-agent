diff --git a/lib/matplotlib/cbook.py b/lib/matplotlib/cbook.py
index c9699b2e21..15a81e9ebf 100644
--- a/lib/matplotlib/cbook.py
+++ b/lib/matplotlib/cbook.py
@@ -788,6 +788,44 @@ class Grouper:
     def __init__(self, init=()):
         self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}
 
+    def __getstate__(self):
+        # Convert weakrefs to strong references for pickling.
+        # Filter out dead references during the process.
+        state = {}
+        processed_sets = set()  # Keep track of sets already processed
+        for key_ref, value_list in self._mapping.items():
+            key = key_ref()
+            if key is None:  # Skip dead references
+                continue
+
+            # Use the id of the list as a proxy for the set identity
+            value_list_id = id(value_list)
+            if value_list_id in processed_sets:
+                continue
+
+            # Process the set if not already done
+            strong_value_list = []
+            for item_ref in value_list:
+                item = item_ref()
+                if item is not None:
+                    strong_value_list.append(item)
+
+            if strong_value_list: # Only add if the list is not empty after removing dead refs
+                state[key] = strong_value_list
+                processed_sets.add(value_list_id)
+        return state
+
+    def __setstate__(self, state):
+        # Reconstruct the _mapping with weakrefs from the pickled state.
+        self._mapping = {}
+        for key, value_list in state.items():
+            # Create the list of weakrefs for this set
+            weak_value_list = [weakref.ref(item) for item in value_list]
+            # Map each item's weakref to this shared list
+            for item_ref in weak_value_list:
+                self._mapping[item_ref] = weak_value_list
+
+
     def __contains__(self, item):
         return weakref.ref(item) in self._mapping
 
diff --git a/lib/matplotlib/tests/test_figure_pickling.py b/lib/matplotlib/tests/test_figure_pickling.py
new file mode 100644
index 0000000000..859ef7cf0d
--- /dev/null
+++ b/lib/matplotlib/tests/test_figure_pickling.py
@@ -0,0 +1,49 @@
+
+import pickle
+import matplotlib.pyplot as plt
+import pytest
+
+def test_pickle_figure_with_aligned_labels():
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    ax1.set_ylabel('YLabel 1')
+    ax2.set_ylabel('YLabel 2')
+    ax1.set_xlabel('XLabel 1')
+    ax2.set_xlabel('XLabel 2')
+
+    fig.align_labels()
+
+    # Pickle and unpickle the figure
+    pickled_fig = pickle.dumps(fig)
+    unpickled_fig = pickle.loads(pickled_fig)
+
+    # Basic check to ensure the unpickled figure is usable
+    assert len(unpickled_fig.axes) == 2
+    assert unpickled_fig.axes[0].get_ylabel() == 'YLabel 1'
+    assert unpickled_fig.axes[1].get_ylabel() == 'YLabel 2'
+    assert unpickled_fig.axes[0].get_xlabel() == 'XLabel 1'
+    assert unpickled_fig.axes[1].get_xlabel() == 'XLabel 2'
+
+    # Check if the alignment groups are restored (indirectly)
+    # We can check if the internal _align_label_groups exists and has items
+    # Note: Accessing private attributes is generally discouraged in tests,
+    # but necessary here to verify the state restoration.
+    assert hasattr(unpickled_fig, '_align_label_groups')
+    # Check if the grouper contains the axes (using weakrefs internally)
+    assert unpickled_fig.axes[0] in unpickled_fig._align_label_groups['y']
+    assert unpickled_fig.axes[1] in unpickled_fig._align_label_groups['y']
+    # Check if they are joined (for y-labels)
+    # Check x-label grouper
+    assert unpickled_fig.axes[0] in unpickled_fig._align_label_groups['x']
+    assert unpickled_fig.axes[1] in unpickled_fig._align_label_groups['x']
+    # Check if they are joined (for x-labels - they shouldn't be joined by default 
+    # unless sharex=True or align_xlabels called explicitly on specific axes)
+    assert not unpickled_fig._align_label_groups['x'].joined(unpickled_fig.axes[0], unpickled_fig.axes[1])
+    assert unpickled_fig._align_label_groups['y'].joined(unpickled_fig.axes[0], unpickled_fig.axes[1])
+
+    # Check alignment after unpickling (optional, might be complex)
+    # For simplicity, we rely on the state restoration check above.
+
+    plt.close(fig)
+    plt.close(unpickled_fig)
\ No newline at end of file
