diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py
index c5d87f647a..99faeb9bf8 100644
--- a/django/db/models/fields/related_descriptors.py
+++ b/django/db/models/fields/related_descriptors.py
@@ -61,6 +61,7 @@ and two directions (forward and reverse) for a total of six combinations.
 
    If you're looking for ``ForwardManyToManyDescriptor`` or
    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.
+from asgiref.sync import sync_to_async
 """
 
 from django.core.exceptions import FieldError
@@ -634,6 +635,7 @@ def create_reverse_many_to_one_manager(superclass, rel):
     This manager subclasses another manager, generally the default manager of
     the related model, and adds behaviors specific to many-to-one relations.
     """
+    from asgiref.sync import sync_to_async
 
     class RelatedManager(superclass, AltersData):
         def __init__(self, instance):
@@ -793,22 +795,40 @@ def create_reverse_many_to_one_manager(superclass, rel):
 
         create.alters_data = True
 
+        async def acreate(self, **kwargs):
+            return await sync_to_async(self.create)(**kwargs)
+
+        acreate.alters_data = True
+
+
         def get_or_create(self, **kwargs):
             self._check_fk_val()
             kwargs[self.field.name] = self.instance
             db = router.db_for_write(self.model, instance=self.instance)
             return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)
 
+
         get_or_create.alters_data = True
 
+        async def aget_or_create(self, **kwargs):
+            return await sync_to_async(self.get_or_create)(**kwargs)
+
+        aget_or_create.alters_data = True
+
         def update_or_create(self, **kwargs):
             self._check_fk_val()
             kwargs[self.field.name] = self.instance
             db = router.db_for_write(self.model, instance=self.instance)
             return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)
 
+
         update_or_create.alters_data = True
 
+        async def aupdate_or_create(self, **kwargs):
+            return await sync_to_async(self.update_or_create)(**kwargs)
+
+        aupdate_or_create.alters_data = True
+
         # remove() and clear() are only provided if the ForeignKey can have a
         # value of null.
         if rel.field.null:
@@ -945,6 +965,7 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):
     This manager subclasses another manager, generally the default manager of
     the related model, and adds behaviors specific to many-to-many relations.
     """
+    from asgiref.sync import sync_to_async
 
     class ManyRelatedManager(superclass, AltersData):
         def __init__(self, instance=None):
@@ -1189,7 +1210,13 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):
             self.add(new_obj, through_defaults=through_defaults)
             return new_obj
 
-        create.alters_data = True
+        async def acreate(self, *, through_defaults=None, **kwargs):
+            return await sync_to_async(self.create)(
+                through_defaults=through_defaults, **kwargs
+            )
+
+        acreate.alters_data = True
+
 
         def get_or_create(self, *, through_defaults=None, **kwargs):
             db = router.db_for_write(self.instance.__class__, instance=self.instance)
@@ -1202,7 +1229,13 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):
                 self.add(obj, through_defaults=through_defaults)
             return obj, created
 
-        get_or_create.alters_data = True
+
+        async def aget_or_create(self, *, through_defaults=None, **kwargs):
+            return await sync_to_async(self.get_or_create)(
+                through_defaults=through_defaults, **kwargs
+            )
+
+        aget_or_create.alters_data = True
 
         def update_or_create(self, *, through_defaults=None, **kwargs):
             db = router.db_for_write(self.instance.__class__, instance=self.instance)
@@ -1215,7 +1248,13 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):
                 self.add(obj, through_defaults=through_defaults)
             return obj, created
 
-        update_or_create.alters_data = True
+
+        async def aupdate_or_create(self, *, through_defaults=None, **kwargs):
+            return await sync_to_async(self.update_or_create)(
+                through_defaults=through_defaults, **kwargs
+            )
+
+        aupdate_or_create.alters_data = True
 
         def _get_target_ids(self, target_field_name, objs):
             """
diff --git a/tests/async/models.py b/tests/async/models.py
index 8cb051258c..ffaec0a31b 100644
--- a/tests/async/models.py
+++ b/tests/async/models.py
@@ -5,7 +5,11 @@ from django.utils import timezone
 class RelatedModel(models.Model):
     simple = models.ForeignKey("SimpleModel", models.CASCADE, null=True)
 
+class ManyToManyModel(models.Model):
+    name = models.CharField(max_length=50)
+
 
 class SimpleModel(models.Model):
     field = models.IntegerField()
+    many = models.ManyToManyField("ManyToManyModel", related_name="simples")
     created = models.DateTimeField(default=timezone.now)
diff --git a/tests/async/test_async_queryset.py b/tests/async/test_async_queryset.py
index 253183ea10..c260ee8556 100644
--- a/tests/async/test_async_queryset.py
+++ b/tests/async/test_async_queryset.py
@@ -8,7 +8,7 @@ from django.db import NotSupportedError, connection
 from django.db.models import Sum
 from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature
 
-from .models import SimpleModel
+from .models import ManyToManyModel, RelatedModel, SimpleModel
 
 
 class AsyncQuerySetTest(TestCase):
@@ -246,3 +246,97 @@ class AsyncQuerySetTest(TestCase):
         sql = "SELECT id, field FROM async_simplemodel WHERE created=%s"
         qs = SimpleModel.objects.raw(sql, [self.s1.created])
         self.assertEqual([o async for o in qs], [self.s1])
+
+
+class AsyncRelatedManagerTest(TestCase):
+    @classmethod
+    def setUpTestData(cls):
+        cls.s1 = SimpleModel.objects.create(field=1)
+        cls.m2m_1 = ManyToManyModel.objects.create(name="m2m_1")
+        cls.m2m_2 = ManyToManyModel.objects.create(name="m2m_2")
+        cls.s1.many.add(cls.m2m_1)
+
+    async def test_reverse_fk_acreate(self):
+        # Test acreate on a reverse foreign key manager
+        related = await self.s1.relatedmodel_set.acreate()
+        self.assertIsNotNone(related.pk)
+        self.assertEqual(related.simple, self.s1)
+        self.assertEqual(await self.s1.relatedmodel_set.acount(), 1)
+
+    async def test_reverse_fk_aget_or_create(self):
+        # Test aget_or_create on a reverse foreign key manager (create)
+        related, created = await self.s1.relatedmodel_set.aget_or_create(pk=99)
+        self.assertTrue(created)
+        self.assertEqual(related.pk, 99)
+        self.assertEqual(related.simple, self.s1)
+        self.assertEqual(await self.s1.relatedmodel_set.acount(), 1)
+
+        # Test aget_or_create on a reverse foreign key manager (get)
+        related_again, created_again = await self.s1.relatedmodel_set.aget_or_create(pk=99)
+        self.assertFalse(created_again)
+        self.assertEqual(related_again, related)
+
+    async def test_reverse_fk_aupdate_or_create(self):
+        # Test aupdate_or_create on a reverse foreign key manager (create)
+        related, created = await self.s1.relatedmodel_set.aupdate_or_create(
+            pk=100, defaults={"simple": self.s1} # Explicitly pass FK
+        )
+        self.assertTrue(created)
+        self.assertEqual(related.pk, 100)
+        self.assertEqual(related.simple, self.s1)
+
+        # Test aupdate_or_create on a reverse foreign key manager (update)
+        # Need another SimpleModel instance to update the relation
+        s2 = await SimpleModel.objects.acreate(field=2)
+        related_updated, created_updated = await self.s1.relatedmodel_set.aupdate_or_create(
+            pk=100, defaults={"simple": s2}
+        )
+        self.assertFalse(created_updated)
+        self.assertEqual(related_updated, related)
+        await related_updated.arefresh_from_db()
+        self.assertEqual(related_updated.simple_id, s2.id)
+        self.assertEqual(await self.s1.relatedmodel_set.acount(), 0) # Moved to s2
+        self.assertEqual(await s2.relatedmodel_set.acount(), 1)
+
+    async def test_m2m_acreate(self):
+        # Test acreate on a many-to-many manager
+        new_m2m = await self.s1.many.acreate(name="new_m2m")
+        self.assertIsNotNone(new_m2m.pk)
+        self.assertEqual(await self.s1.many.acount(), 2)
+        self.assertTrue(await self.s1.many.filter(pk=new_m2m.pk).aexists())
+
+    async def test_m2m_aget_or_create(self):
+        # Test aget_or_create on a many-to-many manager (create)
+        new_m2m, created = await self.s1.many.aget_or_create(name="another_m2m")
+        self.assertTrue(created)
+        self.assertIsNotNone(new_m2m.pk)
+        self.assertEqual(await self.s1.many.acount(), 2)
+        self.assertTrue(await self.s1.many.filter(pk=new_m2m.pk).aexists())
+
+        # Test aget_or_create on a many-to-many manager (get)
+        existing_m2m, created_again = await self.s1.many.aget_or_create(name="m2m_1")
+        self.assertFalse(created_again)
+        self.assertEqual(existing_m2m, self.m2m_1)
+        self.assertEqual(await self.s1.many.acount(), 2) # Still 2
+
+    async def test_m2m_aupdate_or_create(self):
+        # Test aupdate_or_create on a many-to-many manager (create)
+        new_m2m, created = await self.s1.many.aupdate_or_create(
+            name="yet_another", defaults={"name": "yet_another_m2m"}
+        )
+        self.assertTrue(created)
+        self.assertIsNotNone(new_m2m.pk)
+        self.assertEqual(new_m2m.name, "yet_another_m2m")
+        self.assertEqual(await self.s1.many.acount(), 2)
+        self.assertTrue(await self.s1.many.filter(pk=new_m2m.pk).aexists())
+
+        # Test aupdate_or_create on a many-to-many manager (update)
+        updated_m2m, created_again = await self.s1.many.aupdate_or_create(
+            name="m2m_1", defaults={"name": "m2m_1_updated"}
+        )
+        self.assertFalse(created_again)
+        self.assertEqual(updated_m2m, self.m2m_1)
+        await updated_m2m.arefresh_from_db()
+        self.assertEqual(updated_m2m.name, "m2m_1_updated")
+        self.assertEqual(await self.s1.many.acount(), 2) # Still 2
+        self.assertTrue(await self.s1.many.filter(pk=self.m2m_1.pk).aexists())
\ No newline at end of file
