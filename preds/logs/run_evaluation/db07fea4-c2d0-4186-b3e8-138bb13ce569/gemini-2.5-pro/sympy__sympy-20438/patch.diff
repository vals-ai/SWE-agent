diff --git a/sympy/core/relational.py b/sympy/core/relational.py
index e2e0b7fbcc..4f1a8e4f00 100644
--- a/sympy/core/relational.py
+++ b/sympy/core/relational.py
@@ -311,7 +311,7 @@ def _eval_simplify(self, **kwargs):
             v = None
             if dif.is_comparable:
                 v = dif.n(2)
-            elif dif.equals(0):  # XXX this is expensive
+            elif dif is S.EmptySet: # Check if the difference is the empty set
                 v = S.Zero
             if v is not None:
                 r = r.func._eval_relation(v, S.Zero)
diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py
index 3c4aa86e36..9c55cd397d 100644
--- a/sympy/sets/sets.py
+++ b/sympy/sets/sets.py
@@ -809,6 +809,50 @@ def as_relational(self, *symbols):
                 'number of symbols must match the number of sets')
         return And(*[s.as_relational(i) for s, i in zip(self.sets, symbols)])
 
+    def _eval_is_subset(self, other):
+        if other.is_ProductSet:
+            if len(self.sets) != len(other.sets):
+                return False
+            return fuzzy_and(f.is_subset(s) for f, s in zip(self.sets, other.sets))
+        elif other.is_FiniteSet:
+            # If self is infinite, it cannot be a subset of a finite set
+            if self.is_finite_set is False:
+                return False
+            # If self is finite, iterate and check elements
+            if self.is_finite_set is True:
+                return fuzzy_and(el in other for el in self)
+            # If finiteness is unknown, return None
+            return None
+        # Fallback for other set types
+        return None
+
+    def _eval_is_superset(self, other):
+        if other.is_ProductSet:
+            if len(self.sets) != len(other.sets):
+                return False
+            return fuzzy_and(f.is_superset(s) for f, s in zip(self.sets, other.sets))
+        elif other.is_FiniteSet:
+            # Check if all elements of the FiniteSet 'other' are in self
+            return fuzzy_and(el in self for el in other)
+        # Fallback for other set types
+        return None
+
+    def _eval_rewrite_as_FiniteSet(self, *args, **kwargs):
+        """Rewrite ProductSet as FiniteSet if possible."""
+        # Check if all component sets are finite and iterable
+        if self.is_finite_set is not True or self.is_iterable is not True:
+            # Cannot rewrite if not finite or not iterable
+            # Return None to indicate rewrite is not possible under these conditions
+            return None
+
+        # Compute the Cartesian product of elements
+        # Ensure component FiniteSets are iterated correctly
+        product_elements = iproduct(*(s.args if s.is_FiniteSet else s for s in self.sets))
+        # Wrap elements in Tuples as ProductSet elements are tuples
+        elements = [Tuple(*prod) for prod in product_elements]
+        return FiniteSet(*elements)
+
+
     @property
     def _boundary(self):
         return Union(*(ProductSet(*(b + b.boundary if i != j else b.boundary
